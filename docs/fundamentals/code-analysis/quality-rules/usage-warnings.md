---
title: Правила использования (анализ кода)
description: Сведения о правилах использования анализа кода.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- rules, usage
- managed code analysis rules, usage rules
- usage rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: b05edde3c6faef39aa724dd49d159abe23d049f5
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2021
ms.locfileid: "102102975"
---
# <a name="usage-rules"></a>Правила использования

Правила использования поддерживают правильное использование .NET.

## <a name="in-this-section"></a>В этом разделе

|Правило|Описание|
|----------|-----------------|
|[CA1801. Проверьте неиспользуемые параметры](ca1801.md)|Сигнатура метода включает параметр, не использующийся в основной части метода.|
|[CA1816. Вызов GC.SuppressFinalize должен осуществляться правильно](ca1816.md)|Метод, который является реализацией Dispose, не вызывает `GC.SuppressFinalize` ; или метод, который не является реализацией `Dispose` вызовов `GC.SuppressFinalize` ; или метод вызывает `GC.SuppressFinalize` и передает нечто, отличное от `this` ( `Me` в Visual Basic).|
|[CA2200. Повторно порождайте исключения для сохранения сведений стека](ca2200.md)|В операторе throw повторно создается и явным образом задается исключение. Если исключение повторно создается заданием исключения в операторе throw, список вызовов метода между исходным методом, создавшим исключение, и текущим методом будет утерян.|
|[CA2201. Не порождайте исключения зарезервированных типов](ca2201.md)|Это делает исходную ошибку трудной для обнаружения и отладки.|
|[CA2207. Используйте встроенную инициализацию статических полей типов значений](ca2207.md)|Тип значения объявляет явный статический конструктор. Чтобы устранить нарушение данного правила, выполните инициализацию всех статических данных при их объявлении и удалите статический конструктор.|
|[CA2208. Правильно создавайте экземпляры исключений аргументов](ca2208.md)|Вызывается конструктор по умолчанию (без параметров), принадлежащий к типу исключения ArgumentException или унаследованный от него, или неправильный аргумент строки передается параметризованному конструктору, принадлежащему к типу исключения ArgumentException или унаследованному от него.|
|[CA2211. Поля, не являющиеся константами, не должны быть видимыми](ca2211.md)|Статические поля, не являющиеся константами или только для чтения, не являются потокобезопасными. Доступ к такому полю должен быть тщательно контролируемым и требует расширенных методов программирования для синхронизации доступа к объекту класса.|
|[CA2213. Следует высвобождать высвобождаемые поля](ca2213.md)|Тип, реализующий <xref:System.IDisposable?displayProperty=fullName> объявление полей, имеющих типы, которые также реализуют `IDisposable` . `Dispose`Метод этого поля не вызывается `Dispose` методом объявляющего типа.|
|[CA2214. Не вызывайте переопределяемые методы в конструкторах](ca2214.md)|Если конструктор вызывает виртуальный метод, возможно, конструктор для экземпляра, который вызывает метод, не выполнялся.|
|[CA2215. Метод Dispose должен вызывать базовый класс Dispose](ca2215.md)|Если тип наследуется от удаляемого типа, он должен вызывать `Dispose` метод базового типа из своего собственного `Dispose` метода.|
|[CA2216. Высвобождаемые типы должны объявлять методы завершения](ca2216.md)|Тип, реализующий <xref:System.IDisposable?displayProperty=fullName> и имеющий поля, предлагающие использование неуправляемых ресурсов, не реализует метод завершения, как описано в `Object.Finalize` .|
|[CA2217. Не помечайте перечисляемые типы с помощью FlagsAttribute](ca2217.md)|Перечисление, видимое извне, помечено атрибутом `FlagsAttribute` и имеет одно или несколько значений, не являющихся степенями двух, или сочетанием других определенных значений в перечислении.|
|[CA2218. Переопределяйте GetHashCode при переопределении Equals](ca2218.md)|Открытый тип переопределяет <xref:System.Object.Equals%2A?displayProperty=fullName> , но не переопределяет <xref:System.Object.GetHashCode%2A?displayProperty=fullName> .|
|[CA2219. В предложениях с исключениями не должны порождаться исключения](ca2219.md)|Если исключение создается в предложении finally или fault, новое исключение скрывает активное исключение. Если исключение создается в предложении filter, среда выполнения перехватывает исключение без оповещения. Это делает исходную ошибку трудной для обнаружения и отладки.|
|[CA2224. Переопределяйте Equals при перегрузке оператора равенства](ca2224.md)|Открытый тип реализует оператор равенства, но не переопределяет его <xref:System.Object.Equals%2A?displayProperty=fullName> .|
|[CA2225. Для перегрузок операторов существуют варианты с именами](ca2225.md)|Обнаружена перегрузка оператора, однако не найден ожидаемый именованный альтернативный метод. Именованный альтернативный элемент предоставляет доступ к тем же функциональным возможностям, что и оператор, и предоставляется разработчикам, которые запрограммированы на языках, не поддерживающих перегруженные операторы.|
|[CA2226. Перегрузки операторов должны быть симметричными](ca2226.md)|Тип реализует оператор равенства или неравенства и не реализует противоположный оператор.|
|[CA2227. Свойства, возвращающие коллекции, должны быть доступными только для чтения](ca2227.md)|Свойство коллекции, допускающее запись, позволяет пользователю заменять одну коллекцию другой. Свойство только для чтения предотвращает замену коллекции, но по-прежнему допускает установку, настройку отдельных членов.|
|[CA2229. Реализуйте конструкторы сериализации](ca2229.md)|Чтобы устранить нарушение этого правила, реализуйте конструктор сериализации. Для запечатанного класса конструктор должен быть закрытым, а в иных случаях — защищенным.|
|[CA2231. Перегрузите оператор равенства на переопределяющем типе ValueType.Equals](ca2231.md)|Тип значения переопределяет `Object.Equals` , но не реализует оператор равенства.|
|[CA2234. Передавайте объекты System.Uri вместо строк](ca2234.md)|Вызывается метод, имеющий параметр строки, имя которого содержит uri, URI, urn, URN, url или URL.  Объявляющий тип метода содержит соответствующую перегрузку метода, имеющую <xref:System.Uri?displayProperty=fullName> параметр.|
|[CA2235. Пометьте все несериализуемые поля](ca2235.md)|Экземпляр поля несериализуемого типа объявлен в сериализуемом типе.|
|[CA2237. Пометьте типы ISerializable атрибутом SerializableAttribute](ca2237.md)|Для распознавания общеязыковой средой выполнения в качестве сериализуемых типы должны быть помечены атрибутом SerializableAttribute, даже если тип использует пользовательскую подпрограммы сериализации посредством реализации `ISerializable` интерфейса.|
|[CA2241. Задайте правильные аргументы для методов форматирования](ca2241.md)|Аргумент формата, переданный в <xref:System.String.Format%2A?displayProperty=nameWithType> , не содержит элемент форматирования, соответствующий аргументу объекта, или наоборот.|
|[CA2242. Правильно выполняйте проверку NaN](ca2242.md)|Это выражение проверяет значение относительно `Single.Nan` или `Double.Nan` . Используйте `Single.IsNan(Single)` или `Double.IsNan(Double)` для проверки значения.|
|[CA2243. Синтаксический разбор строковых литералов должен осуществляться правильно](ca2243.md)|Параметр строкового литерала атрибута не анализируется правильно для URL-адреса, идентификатора GUID или версии.|
|[CA2244: не повторяйте инициализацию индексируемых элементов](ca2244.md)|Инициализатор объекта имеет более одного инициализатора индексированных элементов с одинаковым индексом константы. Все, кроме последнего инициализатора, являются избыточными.|
|[CA2245: не назначайте свойство самому себе](ca2245.md)|Свойство было случайно назначено самому себе.|
|[CA2246: не присваивайте значения символу и его элементу в одном операторе](ca2246.md)|Не рекомендуется назначать символ и его член, то есть поле или свойство в одной и той же инструкции. Неясно, если доступ к члену был предназначен для использования старого значения символа до присваивания или нового значения из назначения в этой инструкции.|
|[CA2247: аргумент, переданный в конструктор TaskCompletionSource, должен быть перечислением TaskCreationOptions, а не TaskContinuationOptions](ca2247.md)|TaskCompletionSource имеет конструкторы, принимающие TaskCreationOptions, которые управляют базовой задачей, и конструкторы, которые принимают состояние объекта, сохраненное в задаче.  Случайная передача TaskContinuationOptions вместо TaskCreationOptions приведет к тому, что в вызове будут рассматриваться параметры как состояние.|
|[CA2248: укажите правильный аргумент Enum в "Enum. HasFlag"](ca2248.md)|Тип перечисления, переданный в качестве аргумента в `HasFlag` вызов метода, отличается от вызывающего типа перечисления.|
|[CA2249. Попробуйте использовать String.Contains вместо String.IndexOf.](ca2249.md)|Вызовы, `string.IndexOf` где результат используется для проверки наличия или отсутствия подстроки, можно заменить на `string.Contains` .|
