---
description: Дополнительные сведения см. в разделе Пошаговое руководство. вызов API Windows (Visual Basic)
title: Пошаговое руководство. Вызов API Windows
ms.date: 07/20/2015
helpviewer_keywords:
- DLLs, calling
- Windows API, walkthroughs
- platform invoke, walkthroughs
- API calls [Visual Basic], walkthroughs [Visual Basic]
- Windows API, calling
- walkthroughs [Visual Basic], API calls
- DllImport attribute, calling Windows API
- Declare statement [Visual Basic], declaring DLL functions
ms.assetid: 9280ca96-7a93-47a3-8d01-6d01be0657cb
ms.openlocfilehash: 9ffe89cabade780dbe1ced189a92c37e822c59e9
ms.sourcegitcommit: 10e719780594efc781b15295e499c66f316068b8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2021
ms.locfileid: "100427262"
---
# <a name="walkthrough-calling-windows-apis-visual-basic"></a>Пошаговое руководство. Вызов API Windows (Visual Basic)

Windows API — это библиотеки динамической компоновки (DLL), которые являются частью операционной системы Windows. Они используются для выполнения задач, когда трудно писать эквивалентные процедуры. Например, Windows предоставляет функцию с именем `FlashWindowEx` , которая позволяет сделать строку заголовка для приложения альтернативой светлой и темной тени.  
  
 Преимущество использования API-интерфейсов Windows в коде состоит в том, что они могут сэкономить время разработки, поскольку они содержат десятки полезных функций, которые уже написаны и ожидают использования. Недостаток заключается в том, что API Windows может быть трудно работать с и унфоргивинг в случае неправильной работы.  
  
 Интерфейсы API Windows представляют особую категорию взаимодействия. Интерфейсы API Windows не используют управляемый код, не имеют встроенных библиотек типов и используют типы данных, отличные от используемых в Visual Studio. Из-за этих различий и, поскольку интерфейсы API Windows не являются объектами COM, взаимодействия с API Windows и платформа .NET Framework выполняются с помощью вызова неуправляемого кода или PInvoke. Платформенный вызов — это служба, которая позволяет управляемому коду вызывать неуправляемые функции, реализованные в библиотеках DLL. Дополнительные сведения см. в разделе [Использование неуправляемых функций DLL](../../../framework/interop/consuming-unmanaged-dll-functions.md). Вы можете использовать PInvoke в Visual Basic, используя либо `Declare` инструкцию, либо применяя `DllImport` атрибут к пустой процедуре.  
  
 Вызовы Windows API были важной частью Visual Basic программирования в прошлом, но они редко требуются для Visual Basic .NET. Везде, где это возможно, следует использовать управляемый код из платформа .NET Framework для выполнения задач, а не вызовов Windows API. В этом пошаговом руководстве содержатся сведения о ситуациях, в которых требуется использовать API Windows.  
  
[!INCLUDE[note_settings_general](~/includes/note-settings-general-md.md)]  
  
## <a name="api-calls-using-declare"></a>Вызовы API с помощью Declare  

 Наиболее распространенным способом вызова API Windows является использование `Declare` инструкции.  
  
### <a name="to-declare-a-dll-procedure"></a>Объявление процедуры DLL  
  
1. Определите имя функции, которую необходимо вызвать, а также ее аргументы, типы аргументов и возвращаемое значение, а также имя и расположение библиотеки DLL, содержащей ее.  
  
    > [!NOTE]
    > Полные сведения о API Windows см. в документации по пакету SDK для Win32 в Windows API Platform SDK. Дополнительные сведения о константах, используемых API Windows, см. в файлах заголовков, таких как Windows. h, входящих в состав пакета Platform SDK.  
  
2. Откройте новый проект приложения Windows, щелкнув **создать** в меню **файл** , а затем выбрав пункт **проект**. Откроется диалоговое окно **Новый проект** .  
  
3. Выберите **приложение Windows** в списке шаблонов проектов Visual Basic. Отобразится новый проект.  
  
4. Добавьте следующую `Declare` функцию либо в класс, либо в модуль, в котором требуется использовать библиотеку DLL:  
  
     [!code-vb[VbVbalrInterop#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#9)]  
  
### <a name="parts-of-the-declare-statement"></a>Части инструкции DECLARE  

 `Declare`Инструкция включает следующие элементы.  
  
#### <a name="auto-modifier"></a>Модификатор Auto  

 `Auto`Модификатор указывает среде выполнения преобразовать строку на основе имени метода в соответствии с правилами среды CLR (или именем псевдонима, если оно указано).  
  
#### <a name="lib-and-alias-keywords"></a>Ключевые слова lib и Alias  

 Имя, следующее за `Function` ключевым словом, — это имя, которое программа использует для доступа к импортируемой функции. Оно может совпадать с реальным именем вызываемой функции, или можно использовать любое допустимое имя процедуры, а затем применить `Alias` ключевое слово, чтобы указать реальное имя вызываемой функции.  
  
 Укажите `Lib` ключевое слово, а затем имя и расположение библиотеки DLL, содержащей вызываемую функцию. Указывать путь к файлам, расположенным в системных каталогах Windows, не требуется.  
  
 Используйте `Alias` ключевое слово, если имя вызываемой функции не является допустимым Visual Basic именем процедуры или конфликтует с именами других элементов в приложении. `Alias` Указывает на истинное имя вызываемой функции.  
  
#### <a name="argument-and-data-type-declarations"></a>Объявления аргументов и типов данных  

 Объявите аргументы и их типы данных. Эта часть может быть сложной, поскольку типы данных, используемые Windows, не соответствуют типам данных Visual Studio. Visual Basic выполняет большой объем работы, преобразуя аргументы в совместимые типы данных, процесс, называемый *упаковкой*. Можно явно управлять упаковкой аргументов с помощью <xref:System.Runtime.InteropServices.MarshalAsAttribute> атрибута, определенного в <xref:System.Runtime.InteropServices> пространстве имен.  
  
> [!NOTE]
> Предыдущие версии Visual Basic позволяли объявлять параметры `As Any` , то есть могут использоваться данные любого типа данных. Visual Basic требует, чтобы для всех инструкций использовался конкретный тип данных `Declare` .  
  
#### <a name="windows-api-constants"></a>Константы Windows API  

 Некоторые аргументы являются сочетаниями констант. Например, API, `MessageBox` показанный в этом пошаговом руководстве, принимает целочисленный аргумент `Typ` с именем, который управляет отображением окна сообщения. Можно определить числовое значение этих констант, изучив `#define` инструкции в файле WinUser. h. Числовые значения обычно отображаются в шестнадцатеричном виде, поэтому для их добавления и преобразования в десятичный формат может потребоваться калькулятор. Например, если вы хотите объединить константы для стиля с восклицательным знаком `MB_ICONEXCLAMATION` 0x00000030, а стиль «да/нет `MB_YESNO` », можно добавить числа и получить результат 0x00000034 или 52 Decimal. Хотя вы можете использовать десятичный результат непосредственно, лучше объявить эти значения как константы в приложении и объединить их с помощью `Or` оператора.  
  
##### <a name="to-declare-constants-for-windows-api-calls"></a>Объявление констант для вызовов API Windows  
  
1. Обратитесь к документации по функции Windows, которую вы вызываете. Определите имена констант, которые он использует, и имя h файла, содержащего числовые значения для этих констант.  
  
2. Используйте текстовый редактор, например Блокнот, для просмотра содержимого файла заголовка (. h) и поиска значений, связанных с используемыми константами. Например, `MessageBox` API использует константу `MB_ICONQUESTION` для отображения вопросительного знака в окне сообщения. Определение для `MB_ICONQUESTION` находится в файле WinUser. h и выглядит следующим образом:  
  
     `#define MB_ICONQUESTION             0x00000020L`  
  
3. Добавьте эквивалентные `Const` операторы в класс или модуль, чтобы сделать эти константы доступными для приложения. Пример:  
  
     [!code-vb[VbVbalrInterop#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#11)]  
  
###### <a name="to-call-the-dll-procedure"></a>Вызов процедуры DLL  
  
1. Добавьте кнопку с именем `Button1` в форму запуска проекта, а затем дважды щелкните ее, чтобы просмотреть код. Появится обработчик событий для кнопки.  
  
2. Добавьте код в `Click` обработчик событий для добавленной кнопки, чтобы вызвать процедуру и предоставить соответствующие аргументы:  
  
     [!code-vb[VbVbalrInterop#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#12)]  
  
3. Запустите проект, нажав клавишу F5. Появится окно сообщения с кнопками **Да** и **нет** . Щелкните один из них.  
  
#### <a name="data-marshaling"></a>Маршалирование данных  

 Visual Basic автоматически преобразует типы данных параметров и возвращаемые значения для вызовов API Windows, но можно использовать `MarshalAs` атрибут, чтобы явно указать неуправляемые типы данных, которые ОЖИДАЕТ API. Дополнительные сведения о маршалинге взаимодействия см. в разделе [Маршалинг взаимодействия](../../../framework/interop/interop-marshaling.md).  
  
##### <a name="to-use-declare-and-marshalas-in-an-api-call"></a>Использование Declare и MarshalAs в вызове API  
  
1. Определите имя функции, которую необходимо вызвать, а также ее аргументы, типы данных и возвращаемое значение.  
  
2. Чтобы упростить доступ к `MarshalAs` атрибуту, добавьте `Imports` оператор в начало кода для класса или модуля, как показано в следующем примере:  
  
     [!code-vb[VbVbalrInterop#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#13)]  
  
3. Добавьте прототип функции для импортированной функции в класс или модуль, который вы используете, и примените `MarshalAs` атрибут к параметрам или возвращаемому значению. В следующем примере вызов API, который принимает тип, `void*` маршалируется как `AsAny` :  
  
     [!code-vb[VbVbalrInterop#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#14)]  
  
## <a name="api-calls-using-dllimport"></a>Вызовы API с помощью DllImport  

 `DllImport`Атрибут предоставляет второй способ вызова функций в библиотеках DLL без библиотек типов. `DllImport` примерно эквивалентно использованию оператора, `Declare` но обеспечивает более полный контроль над вызовом функций.  
  
 `DllImport`С большинством вызовов API Windows можно использовать, если вызов ссылается на общий (иногда называемый *статическим*) метод. Нельзя использовать методы, для которых требуется экземпляр класса. В отличие от `Declare` инструкций `DllImport` вызовы не могут использовать `MarshalAs` атрибут.  
  
### <a name="to-call-a-windows-api-using-the-dllimport-attribute"></a>Вызов API Windows с помощью атрибута DllImport  
  
1. Откройте новый проект приложения Windows, щелкнув **создать** в меню **файл** , а затем выбрав пункт **проект**. Откроется диалоговое окно **Новый проект** .  
  
2. Выберите **приложение Windows** в списке шаблонов проектов Visual Basic. Отобразится новый проект.  
  
3. Добавьте кнопку с именем `Button2` в форму запуска.  
  
4. Дважды щелкните, `Button2` чтобы открыть представление кода для формы.  
  
5. Чтобы упростить доступ к `DllImport` , добавьте `Imports` оператор в начало кода для класса формы Startup:  
  
     [!code-vb[VbVbalrInterop#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#13)]  
  
6. Объявите пустую функцию перед `End Class` оператором для формы и назовите функцию `MoveFile` .  
  
7. Примените `Public` `Shared` модификаторы и к объявлению функции и задайте параметры в `MoveFile` зависимости от аргументов, используемых функцией Windows API:  
  
     [!code-vb[VbVbalrInterop#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#16)]  
  
     Функция может иметь любое допустимое имя процедуры; `DllImport` атрибут указывает имя в библиотеке DLL. Он также обрабатывает упаковку взаимодействия для параметров и возвращаемых значений, поэтому можно выбирать типы данных Visual Studio, аналогичные типам данных, используемым API.  
  
8. Примените `DllImport` атрибут к пустой функции. Первый параметр — это имя и расположение библиотеки DLL, содержащей вызываемую функцию. Указывать путь к файлам, расположенным в системных каталогах Windows, не требуется. Второй параметр — это именованный аргумент, указывающий имя функции в API Windows. В этом примере `DllImport` атрибут принудительно `MoveFile` перенаправляет вызовы в `MoveFileW` в KERNEL32.DLL. `MoveFileW`Метод копирует файл из пути `src` в путь `dst` .  
  
     [!code-vb[VbVbalrInterop#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#17)]  
  
9. Добавьте код в `Button2_Click` обработчик событий для вызова функции:  
  
     [!code-vb[VbVbalrInterop#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#18)]  
  
10. Создайте файл с именем Test.txt и поместите его в каталог К:\тмп на жестком диске. При необходимости создайте каталог tmp.  
  
11. Нажмите клавишу F5 для запуска приложения. Откроется Главная форма.  
  
12. Нажмите кнопку **Button2**. Если файл можно переместить, отображается сообщение "файл перемещен успешно".  
  
## <a name="see-also"></a>См. также раздел

- <xref:System.Runtime.InteropServices.DllImportAttribute>
- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [Declare Statement](../../language-reference/statements/declare-statement.md)
- [Автоматически](../../language-reference/modifiers/auto.md)
- [Псевдоним](../../language-reference/statements/alias-clause.md)
- [COM-взаимодействие](index.md)
- [Создание прототипов в управляемом коде](../../../framework/interop/creating-prototypes-in-managed-code.md)
- [Маршалинг делегата как метода обратного вызова](../../../framework/interop/marshaling-a-delegate-as-a-callback-method.md)
