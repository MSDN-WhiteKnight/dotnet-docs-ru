---
description: 'Дополнительные сведения: объекты и классы в Visual Basic'
title: Объекты и классы
ms.date: 05/26/2020
helpviewer_keywords:
- classes [Visual Basic]
- objects [Visual Basic]
ms.assetid: c68c5752-1006-46e1-975a-6717b62a42fc
ms.openlocfilehash: 9cefcc117c9dd4ac42940f342dbf75d8ddb4f41d
ms.sourcegitcommit: 10e719780594efc781b15295e499c66f316068b8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2021
ms.locfileid: "100462728"
---
# <a name="objects-and-classes-in-visual-basic"></a>Объекты и классы Visual Basic

*Объект* представляет собой сочетание кода и данных, которое рассматривается как единое целое. Объект может быть частью приложения, как, например, элемент управления или форма. Также объектом может являться само приложение в целом.

При создании приложения в Visual Basic вы постоянно работаете с объектами. Можно использовать объекты, предоставляемые Visual Basic, такие как элементы управления, формы и объекты доступа к данным. Кроме того, в приложении Visual Basic можно использовать объекты других приложений. Вы даже можете создать собственные объекты и определить для них дополнительные свойства и методы. Объекты выполняют функцию готовых блоков для создания программ — вы можете один раз написать фрагмент кода и использовать его многократно.

В этой статье мы подробно расскажем вам про объекты.

## <a name="objects-and-classes"></a>Объекты и классы

Каждый объект в Visual Basic определяется *классом*. Класс описывает переменные, свойства, процедуры и события объекта. Объекты являются экземплярами классов. Определив класс, вы можете создать из него любое количество объектов.

Взаимосвязь между объектом и его классом можно проиллюстрировать на примере печенья и формочки для печенья. Форма для печенья — это класс. Она определяет характеристики каждого печенья, то есть размер и форму. Класс используется для создания объектов. Отдельные печенья — это и есть объекты.

Необходимо создать объект, чтобы получить доступ к его членам, за исключением [`Shared`](../../../language-reference/modifiers/shared.md) элементов, к которым можно получить доступ без объекта класса.

### <a name="create-an-object-from-a-class"></a>Создание объекта из класса

1. Определите, из какого класса нужно создать объект, или определите собственный класс. Пример:

   ```vb
   Public Class Customer
       Public Property AccountNumber As Integer
   End Class
   ```

2. Напишите [оператор Dim](../../../language-reference/statements/dim-statement.md) для создания переменной, значением которой будет новый экземпляр класса. Переменная должна иметь тип, соответствующий нужному классу.

   ```vb
   Dim nextCustomer As Customer
   ```

3. Добавьте ключевое слово [New Operator](../../../language-reference/operators/new-operator.md), сохранить новый экземпляр класса в переменную.

   ```vb
   Dim nextCustomer As New Customer
   ```

4. Теперь члены класса будут доступны через переменную объекта.

   ```vb
   nextCustomer.AccountNumber = lastAccountNumber + 1
   ```

> [!NOTE]
> Всегда, если это возможно, следует объявлять переменную с типом того класса, который будет в ней храниться. Этот принцип называется *раннее связывание*. Если во время компиляции тип класса не известен, можно использовать *позднее связывание*, объявив переменную с [типом данных объекта](../../../language-reference/data-types/object-data-type.md). Но помните, что позднее связывание может снижать производительность и ограничивать доступ к членам объекта во время выполнения. Дополнительные сведения см. в статье [Object Variable Declaration](../variables/object-variable-declaration.md) (Объявление объектной переменной).

### <a name="multiple-instances"></a>Несколько экземпляров

Обычно все только что созданные из класса объекты идентичны друг другу. Но с того момента, когда они возникают как отдельные объекты, их переменные и свойства изменяются независимо от других экземпляров объекта. Например, если вы добавляете в форму три флажка, каждый из объектов флажков является экземпляром класса <xref:System.Windows.Forms.CheckBox>. Отдельные объекты <xref:System.Windows.Forms.CheckBox> имеют одинаковый набор характеристик и возможностей (свойства, переменные, процедуры и события), которые определены в этом классе. Но каждый из объектов имеет собственное имя, каждый можно отдельно включать и отключать, а также перемещать в другое место на форме.

## <a name="object-members"></a>Члены объекта

Объект является элементом приложения и представляет собой *экземпляр* некоторого класса. Поля, свойства, методы и события являются составными частями объекта, и совокупно именуются *членами* объекта.

### <a name="member-access"></a>Доступ к членам

Чтобы обратиться к члену объекта, нужно указать имя соответствующей переменной объекта и имя нужного члена, отделив его точкой (`.`). В следующем примере задается свойство <xref:System.Windows.Forms.Control.Text%2A> объекта <xref:System.Windows.Forms.Label>.

```vb
warningLabel.Text = "Data not saved"
```

#### <a name="intellisense-listing-of-members"></a>Список членов IntelliSense

Технология IntelliSense перечисляет члены класса, когда вы обращаетесь к функции списка членов, например вводите точку (`.`) в контексте доступа к члену. Если точка ставится после имени переменной, объявленной как экземпляр некоторого класса, IntelliSense перечисляет все члены экземпляра, но опускает общие члены. Если точка ставится после имени класса, то IntelliSense перечисляет все общие члены, но опускает члены экземпляра. Дополнительные сведения см. в разделе [Using IntelliSense](/visualstudio/ide/using-intellisense).

### <a name="fields-and-properties"></a>Поля и свойства

*Поля* и *свойства* представляют сведения, содержащиеся в объекте. Их значения можно задавать и получать с помощью инструкций присваивания, так же как для локальных переменных в процедуре. В следующем примере мы получаем значение свойства <xref:System.Windows.Forms.Control.Width%2A> и устанавливаем значение свойства <xref:System.Windows.Forms.Control.ForeColor%2A> для объекта <xref:System.Windows.Forms.Label>.

```vb
Dim warningWidth As Integer = warningLabel.Width
warningLabel.ForeColor = System.Drawing.Color.Red
```

Поле можно также называть *переменная-член*.

Процедуры свойств удобно использовать в следующих случаях.

- Вы хотите контролировать, когда и как значения будут задаваться и извлекаться.

- Свойство имеет строго определенный набор значений, которые требуется проверять.

- Изменение значения приводит к существенному изменению состояния объекта (как, например, значение свойства `IsVisible`).

- Изменение значения свойства изменяет другие внутренние переменные или значения других свойств.

- Перед установкой или получением свойства необходимо выполнить определенный набор действий.

Если выполняются следующие условия, можно использовать поля.

- Значение имеет тип, для которого существует встроенная проверка. Например, если присвоить переменной типа `Boolean` любое значение, кроме `True` или `False`, создается ошибка или выполняется автоматическое преобразование данных.

- Допустимым является любое значение из диапазона, поддерживаемого для этого типа данных. Это справедливо для многих свойств с типами `Single` или `Double`.

- Свойство имеет тип данных `String` и не имеет ограничений на размер или значение строки.

- Дополнительные сведения см. в статье [Property Procedures (Visual Basic)](../procedures/property-procedures.md) (Процедуры свойств в Visual Basic).

> [!TIP]
> Всегда оставляйте неконстантные поля частными. Если вы хотите сделать его общедоступным, используйте вместо него свойство.

### <a name="methods"></a>Методы

Действие, которое выполняет объект, называется *методом*. Например, <xref:System.Windows.Forms.ComboBox.ObjectCollection.Add%2A> — это метод объекта <xref:System.Windows.Forms.ComboBox>, который добавляет новую запись в поле со списком.

В следующем примере иллюстрируется использование метода <xref:System.Windows.Forms.Timer.Start%2A> объекта <xref:System.Windows.Forms.Timer>.

```vb
Dim safetyTimer As New System.Windows.Forms.Timer
safetyTimer.Start()
```

По сути метод — это просто *процедура*, предоставляемая объектом.

Дополнительные сведения см. в разделе [Procedures in Visual Basic](../procedures/index.md) (Процедуры в Visual Basic).

### <a name="events"></a>События

Событие — это действие, распознаваемое объектом, например, щелчок мышью или нажатие клавиши. Вы можете написать код для реагирования на эти события. События могут происходить в результате действий пользователя, выполнения программного кода или изменения состояния системы. Принято говорить, что код, который объявляет о наступлении события, *создает* это событие, а код, который реагирует на него, *обрабатывает* событие.

Вы можете разработать собственные события, которые будут создаваться и обрабатываться созданными вами объектами. Дополнительные сведения см. в статье [Events (Visual Basic)](../events/index.md) (События в Visual Basic).

### <a name="instance-members-and-shared-members"></a>Члены экземпляров и общие члены

Когда вы создаете объект на основе класса, вы получаете экземпляр этого класса. Члены, которые объявлены без ключевого слова [Shared](../../../language-reference/modifiers/shared.md), являются *членами экземпляра*, то есть принадлежат исключительно одному определенному экземпляру. Член экземпляра в одном экземпляре никак не зависит от такого же члена в другом экземпляре того же класса. Например, переменная-член экземпляра может иметь разные значения в разных экземплярах.

Члены, объявленные с ключевым словом `Shared`, являются *общими членами*, то есть относятся к классу в целом, а не к отдельному экземпляру. Существует только одна копия каждого общего члена, независимо от количества созданных экземпляров. Общий член определен даже в том случае, если не создано ни одного экземпляра. Например, общая переменная-член имеет только одно значение, которое можно получить из любого фрагмента кода, имеющего доступ к соответствующему классу.

#### <a name="accessing-non-shared-members"></a>Доступ к членам, не являющимся общими

1. Убедитесь, что объект уже создан на основе нужного класса и сохранен в объектной переменной.

   ```vb
   Dim secondForm As New System.Windows.Forms.Form
   ```

2. В инструкции, которая обращается к члену, укажите имя объектной переменной с помощью *оператора доступа к члену* ( `.` ), а затем имя члена.

   ```vb
   secondForm.Show()
   ```

#### <a name="accessing-shared-members"></a>Доступ к общим членам

- Укажите имя класса с помощью *оператора доступа к члену* ( `.` ), а затем имя члена. К члену объекта, объявленному с ключевым словом `Shared`, нужно всегда обращаться напрямую через имя класса.

   ```vb
   Console.WriteLine("This computer is called " & Environment.MachineName)
   ```

- Если вы уже создали из этого класса объект, вы можете обращаться к члену, объявленному с ключевым словом `Shared`, и через переменную этого объекта.

### <a name="differences-between-classes-and-modules"></a>Различия между классами и модулями

Основное различие между классами и модулями заключается в том, что для классов можно создавать экземпляры в качестве объектов. Модули таким свойством не обладают. Поскольку все данные стандартного модуля существуют только в одной копии, любые изменения общей переменной стандартного модуля, выполненные в любой части программы, будут влиять на все остальные обращения к значению этой переменной. Данные объекта, наоборот, существуют отдельно для каждого созданного экземпляра объекта. Еще одно важное различие состоит в том, что классы могут реализовывать интерфейсы, а модули — нет. Если класс помечен модификатором [MustInherit](../../../language-reference/modifiers/mustinherit.md) , он не может быть создан напрямую. Однако он по-прежнему отличается от модуля, так как он может быть унаследован, пока модули не могут быть унаследованы.

> [!NOTE]
> Если к члену класса применяется модификатор `Shared`, он устанавливается для класса в целом, а не для конкретного экземпляра класса. Прямой доступ к члену осуществляется через имя класса, так же как и к членам модуля.

Также классы и модули используют разные области действия для своих членов. Члены, определенные внутри класса, относятся к определенному экземпляру класса и существуют только в то время, когда существует этот объект. Для обращения к членам класса из кода за пределами этого класса следует использовать полные имена в формате *Объект*.*Член*.

С другой стороны, все объявленные в модуле члены по умолчанию свободно используются из любого места в коде, откуда есть доступ к этому модулю. Это означает, что переменные стандартного модуля являются фактически глобальными переменными. Они видимы из любой точки проекта и существуют в течение всего времени жизни программы.

## <a name="reusing-classes-and-objects"></a>Повторное использование классов и объектов

Объекты позволяют один раз объявить переменную или процедуру, а затем использовать ее везде, где потребуется. Например, если в приложении вам нужно средство проверки орфографии, то для него потребуется определить все необходимые переменные и служебные функции. Создав специальный класс для средства проверки орфографии, вы сможете использовать его снова в других приложениях, просто добавив ссылку на скомпилированную сборку. Более того, вы можете сэкономить время и силы, взяв готовый класс проверки орфографии, созданный ранее кем-то другим.

.NET предоставляет множество примеров компонентов, доступных для использования. В следующем примере используется класс <xref:System.TimeZone> в пространстве имен <xref:System>. Члены класса <xref:System.TimeZone> позволяют получить сведения о часовом поясе, выбранном на компьютере.

```vb
Public Sub ExamineTimeZone()
    Dim tz As System.TimeZone = System.TimeZone.CurrentTimeZone
    Dim s As String = "Current time zone is "
    s &= CStr(tz.GetUtcOffset(Now).Hours) & " hours and "
    s &= CStr(tz.GetUtcOffset(Now).Minutes) & " minutes "
    s &= "different from UTC (coordinated universal time)"
    s &= vbCrLf & "and is currently "
    If tz.IsDaylightSavingTime(Now) = False Then s &= "not "
    s &= "on ""summer time""."
    Console.WriteLine(s)
End Sub
```

В предыдущем примере первый [оператор Dim](../../../language-reference/statements/dim-statement.md) объявляет переменную объекта типа <xref:System.TimeZone> и присваивает ей объект <xref:System.TimeZone>, который возвращается свойством <xref:System.TimeZone.CurrentTimeZone%2A>.

## <a name="relationships-among-objects"></a>Отношения между объектами

Между объектами могут существовать связи нескольких видов. В первую очередь эти связи подразделяются на *иерархию* и *вложенность*.

### <a name="hierarchical-relationship"></a>Иерархические связи

Если классы являются производным от других, более фундаментальных классов, такие отношения именуются *иерархической связью*. Иерархии классов удобны при описании объектов, являющихся подтипами более общих классов.

Для следующего примера предположим, что нам нужен особый вид объекта <xref:System.Windows.Forms.Button>, который действует как обычная кнопка <xref:System.Windows.Forms.Button>, но в дополнение имеет метод, меняющий местами цвет фона и цвет переднего плана.

#### <a name="define-a-class-that-is-derived-from-an-already-existing-class"></a>Определить класс, производный от уже существующего класса

1. С помощью [инструкции Class](../../../language-reference/statements/class-statement.md) определите класс, из которого вы будете создавать нужный объект.

   ```vb
   Public Class ReversibleButton
   ```

   Код определения класса должен завершаться строкой `End Class`. По умолчанию интегрированная среда разработки (IDE) автоматически создает `End Class` при вводе инструкции `Class`.

2. Сразу за инструкцией `Class` создайте [инструкцию Inherits](../../../language-reference/statements/inherits-statement.md). Укажите класс, производным от которого будет этот новый класс.

   ```vb
   Inherits System.Windows.Forms.Button
   ```

   Новый класс наследует все члены, определенные в базовом классе.

3. Добавьте код для дополнительных элементов, которые будет предоставлять производный класс. Например, вы можете добавить метод `ReverseColors`, тогда определение производного класса будет выглядеть примерно так:

   ```vb
   Public Class ReversibleButton
       Inherits System.Windows.Forms.Button
           Public Sub ReverseColors()
               Dim saveColor As System.Drawing.Color = Me.BackColor
               Me.BackColor = Me.ForeColor
               Me.ForeColor = saveColor
          End Sub
   End Class
   ```

   При создании объекта из `ReversibleButton` класса он может получить доступ ко всем членам <xref:System.Windows.Forms.Button> класса, а также к `ReverseColors` методу и другим новым элементам, определенным в `ReversibleButton` .

Производные классы наследуют члены класса, на котором они основаны, что позволяет постепенно повышать сложность при продвижении по иерархии классов. Дополнительные сведения см. в статье [Inheritance Basics (Visual Basic)](inheritance-basics.md) (Основная информация о наследовании в Visual Basic).

### <a name="compile-the-code"></a>Компиляция кода

Убедитесь, что компилятор сможет получить доступ к классу, на основе которого вы намерены создать новый класс. Возможно, для этого придется указать его полное имя, как в предыдущем примере, или определить его пространства имен в [операторе Imports](../../../language-reference/statements/imports-statement-net-namespace-and-type.md). Если класс находится в другом проекте, может потребоваться ссылка на этот проект. Дополнительные сведения см. в статье [Управление ссылками в проекте](/visualstudio/ide/managing-references-in-a-project).

### <a name="containment-relationship"></a>Отношение вложения

Также объекты могут быть связаны *отношением вложения*. Объекты-контейнеры на логическом уровне содержат в себе другие объекты. Например, объект <xref:System.OperatingSystem> логически содержит объект <xref:System.Version>, который он возвращает с помощью свойства <xref:System.OperatingSystem.Version%2A>. Важно понимать, что физически объект-контейнер не содержит в себе других объектов.

#### <a name="collections"></a>Коллекции

В качестве примера объектов-контейнеров можно привести *коллекции*. Коллекции представляют собой группы однотипных перечисляемых объектов. Visual Basic поддерживает конкретный синтаксис в области [For Each... Оператор Next](../../../language-reference/statements/for-each-next-statement.md) , позволяющий выполнять итерацию по элементам коллекции. Кроме того, коллекции часто позволяют использовать свойство <xref:Microsoft.VisualBasic.Collection.Item%2A> для обращения к элементам по индексу или по уникальной строке. Коллекции иногда проще в использовании, чем массивы, поскольку они позволяют добавлять или удалять элементы без использования индексов. Благодаря простоте использования коллекции часто применяются для хранения форм и элементов управления.

## <a name="related-topics"></a>Связанные разделы

[Пошаговое руководство. Определение классов](walkthrough-defining-classes.md)\
Пошаговые инструкции по созданию класса.

[Перегруженные свойства и методы](overloaded-properties-and-methods.md)\
Перегруженные свойства и методы

[Основы наследования](inheritance-basics.md)\
Описание модификаторов наследования, переопределения методов и свойств, MyClass и MyBase.

[Время существования объекта: как создаются и уничтожаются объекты](object-lifetime-how-objects-are-created-and-destroyed.md)\
Вопросы создания и уничтожения экземпляров классов.

[Анонимные типы](anonymous-types.md)\
Описание создания и использования анонимных типов, которые позволяют создавать объекты без определения класса для типа данных.

[Инициализаторы объектов: именованные и анонимные типы](object-initializers-named-and-anonymous-types.md)\
Описание инициализаторов объектов, которые позволяют создавать экземпляры именованных и анонимных типов с помощью одного выражения.

[Как вывести имена и типы свойств в объявлениях анонимного типа](how-to-infer-property-names-and-types-in-anonymous-type-declarations.md)\
Обсуждение имен свойств и типов в контексте объявлений анонимных типов. Содержит примеры успешного и неуспешного вывода.
