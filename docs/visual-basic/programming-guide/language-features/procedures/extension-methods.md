---
description: 'Дополнительные сведения: методы расширения (Visual Basic)'
title: Методы расширения
ms.date: 07/20/2015
f1_keywords:
- vb.ExtensionMethods
helpviewer_keywords:
- extending data types [Visual Basic]
- extension methods [Visual Basic]
ms.assetid: b8020aae-374d-46a9-bcb7-8cc2390b93b6
ms.openlocfilehash: 5a1482502b144524c0be90e1c83a38f49b4a4d26
ms.sourcegitcommit: 10e719780594efc781b15295e499c66f316068b8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2021
ms.locfileid: "100434359"
---
# <a name="extension-methods-visual-basic"></a>Методы расширения (Visual Basic)

Методы расширения позволяют разработчикам добавлять пользовательские функции к типам данных, которые уже определены без создания нового производного типа. Методы расширения позволяют написать метод, который может вызываться, как если бы он был методом экземпляра существующего типа.

## <a name="remarks"></a>Remarks

Метод расширения может быть только `Sub` процедурой или `Function` процедурой. Невозможно определить свойство, поле или событие расширения. Все методы расширения должны быть помечены атрибутом расширения `<Extension>` из <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> пространства имен и должны быть определены в [модуле](../../../language-reference/statements/module-statement.md). Если метод расширения определен за пределами модуля, Visual Basic компилятор создает ошибку [BC36551](../../../misc/bc36551.md), "методы расширения могут быть определены только в модулях".

Первый параметр в определении метода расширения указывает тип данных, который расширяет метод. При выполнении метода первый параметр привязывается к экземпляру типа данных, который вызывает метод.

`Extension`Атрибут можно применить только к Visual Basic [`Module`](../../../language-reference/statements/module-statement.md) , [`Sub`](../../../language-reference/statements/sub-statement.md) или [`Function`](../../../language-reference/statements/function-statement.md) . Если применить его к `Class` или `Structure` , Visual Basic компилятор создает ошибку [BC36550](../../../language-reference/error-messages/extension-attribute-can-be-applied-only-to-module-sub-or-function-declarations.md), атрибут "Extension" можно применить только к объявлениям "Module", "" или "Function".

## <a name="example"></a>Пример

В следующем примере определяется `Print` расширение для <xref:System.String> типа данных. Метод использует `Console.WriteLine` для вывода строки. Параметр `Print` метода `aString` определяет, что метод расширяет <xref:System.String> класс.

[!code-vb[VbVbalrExtensionMethods#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/StringExtensions.vb#1)]

Обратите внимание, что определение метода расширения помечено атрибутом Extension `<Extension()>` . Маркировка модуля, в котором определен метод, является необязательной, но каждый метод расширения должен быть помечен. <xref:System.Runtime.CompilerServices> необходимо импортировать, чтобы получить доступ к атрибуту расширения.

Методы расширения могут объявляться только внутри модулей. Как правило, модуль, в котором определен метод расширения, не совпадает с модулем, в котором он вызывается. Вместо этого модуль, содержащий метод расширения, импортируется, если требуется, чтобы перевести его в область. После того, как модуль, содержащий, `Print` находится в области, метод можно вызвать так, как если бы он был обычным методом экземпляра, не принимающим аргументы, например `ToUpper` :

[!code-vb[VbVbalrExtensionMethods#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class1.vb#2)]

Следующий пример, `PrintAndPunctuate` , также является расширением для, на <xref:System.String> этот раз определен с двумя параметрами. Первый параметр, `aString` задает расширение метода расширения <xref:System.String> . Второй параметр, `punc` , — это строка знаков препинания, которая передается в качестве аргумента при вызове метода. Метод отображает строку, за которой следуют знаки пунктуации.

[!code-vb[VbVbalrExtensionMethods#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class2.vb#3)]

Метод вызывается путем отправки в строковый аргумент для `punc` : `example.PrintAndPunctuate(".")`

В следующем примере показаны `Print` и `PrintAndPunctuate` определяются и вызываются. <xref:System.Runtime.CompilerServices> импортируется в модуль определения, чтобы обеспечить доступ к атрибуту расширения.

```vb
Imports System.Runtime.CompilerServices

Module StringExtensions

    <Extension()>
    Public Sub Print(aString As String)
        Console.WriteLine(aString)
    End Sub

    <Extension()>
    Public Sub PrintAndPunctuate(aString As String, punc As String)
        Console.WriteLine(aString & punc)
    End Sub
End Module
```

Далее методы расширения переносятся в область и называются:

```vb
Imports ConsoleApplication2.StringExtensions

Module Module1

    Sub Main()
        Dim example As String = "Example string"
        example.Print()

        example = "Hello"
        example.PrintAndPunctuate(".")
        example.PrintAndPunctuate("!!!!")
    End Sub
End Module
```

Все, что необходимо для выполнения этих или аналогичных методов расширения, заключается в том, что они находятся в области. Если модуль, содержащий метод расширения, находится в области видимости, он отображается в IntelliSense и может быть вызван как обычный метод экземпляра.

Обратите внимание, что при вызове методов для первого параметра не отправляется ни один аргумент. Параметр `aString` в предыдущих определениях метода привязан к `example` экземпляру `String` , который вызывает их. Компилятор будет использовать `example` в качестве аргумента, отправляемого в первый параметр.

Если метод расширения вызывается для объекта, для которого задано значение `Nothing` , метод расширения выполняется. Это не относится к обычным методам экземпляра. Можно выполнить явную проверку `Nothing` в методе расширения.

## <a name="types-that-can-be-extended"></a>Типы, которые могут быть расширены

Можно определить метод расширения для большинства типов, которые могут быть представлены в списке параметров Visual Basic, включая следующие:

- Классы (ссылочные типы)
- Структуры (типы значений)
- Интерфейсы
- Делегаты
- Аргументы ByRef и ByVal
- Параметры универсального метода
- Массивы

Поскольку первый параметр указывает тип данных, который расширяет метод расширения, он является обязательным и не может быть необязательным. По этой причине `Optional` Параметры и `ParamArray` параметры не могут быть первыми параметрами в списке параметров.

Методы расширения не рассматриваются в позднем связывании. В следующем примере инструкция `anObject.PrintMe()` вызывает <xref:System.MissingMemberException> исключение, то же самое исключение отображается, если `PrintMe` было удалено определение второго метода расширения.

[!code-vb[VbVbalrExtensionMethods#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class6.vb#9)]

## <a name="best-practices"></a>Рекомендации

Методы расширения предоставляют удобный и мощный способ расширения существующего типа. Тем не менее, чтобы использовать их успешно, необходимо учитывать некоторые моменты. Эти рекомендации относятся главным образом к авторам библиотек классов, но они могут повлиять на любое приложение, использующее методы расширения.

Чаще всего методы расширения, добавляемые к несобственным типам, более уязвимы, чем методы расширения, добавляемые к управляемым типам. В несобственных классах могут возникать некоторые вещи, которые могут повлиять на методы расширения.

- Если существует любой доступный член экземпляра, имеющий сигнатуру, совместимую с аргументами в вызывающей инструкции, без сужающих преобразований из аргумента в параметр, метод экземпляра будет использоваться в качестве предпочтений любому методу расширения. Таким образом, если в какой-то момент в классе добавляется соответствующий метод экземпляра, существующий член расширения, который вы используете, может стать недоступным.

- Автор метода расширения не может препятствовать написанию другими программистами конфликтующих методов расширения, которые могут иметь приоритет над исходным расширением.

- Надежность можно повысить, поместив методы расширения в собственное пространство имен. Потребители библиотеки могут добавить пространство имен или исключить ее, или выбрать пространства имен отдельно от остальной части библиотеки.

- Расширение интерфейсов может быть более безопасным, чем расширение классов, особенно если вы не владеете интерфейсом или классом. Изменение интерфейса влияет на каждый класс, реализующий его. Таким образом, автор может снизить вероятность добавления или изменения методов в интерфейсе. Однако если класс реализует два интерфейса, у которых есть методы расширения с одинаковой сигнатурой, то ни один из методов расширения не виден.

- Расширьте наиболее конкретный тип, который можно. В иерархии типов при выборе типа, от которого наследуются многие другие типы, существуют уровни возможностей для введения методов экземпляра или других методов расширения, которые могут мешать работе.

## <a name="extension-methods-instance-methods-and-properties"></a>Методы расширения, методы экземпляров и свойства

Если метод экземпляра в области имеет сигнатуру, совместимую с аргументами вызывающей инструкции, метод экземпляра выбирается в качестве предпочтений любому методу расширения. Метод экземпляра имеет приоритет, даже если метод расширения лучше соответствует. В следующем примере `ExampleClass` содержит метод экземпляра с именем `ExampleMethod` , имеющий один параметр типа `Integer` . Метод расширения `ExampleMethod` расширяет `ExampleClass` и имеет один параметр типа `Long` .

[!code-vb[VbVbalrExtensionMethods#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class4.vb#4)]

Первый вызов `ExampleMethod` в следующем коде вызывает метод расширения, поскольку `arg1` имеет значение `Long` и совместимо только с `Long` параметром в методе расширения. Второй вызов `ExampleMethod` `Integer` метода содержит аргумент, `arg2` и вызывает метод экземпляра.

[!code-vb[VbVbalrExtensionMethods#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class4.vb#5)]

Теперь измените типы данных параметров в двух методах:

[!code-vb[VbVbalrExtensionMethods#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class5.vb#6)]

В этот раз код `Main` вызывает метод экземпляра в обоих случаях. Это происходит потому `arg1` , что и, и `arg2` имеют расширяющее преобразование в `Long` , а метод экземпляра имеет приоритет над методом расширения в обоих случаях.

[!code-vb[VbVbalrExtensionMethods#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class5.vb#7)]

Поэтому метод расширения не может заменить существующий метод экземпляра. Однако, если метод расширения имеет то же имя, что и метод экземпляра, но подписи не конфликтуют, доступ к обоим методам возможен. Например, если класс `ExampleClass` содержит метод с именем `ExampleMethod` , который не принимает аргументы, методы расширения с тем же именем, но с разными сигнатурами разрешены, как показано в следующем коде.

[!code-vb[VbVbalrExtensionMethods#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Module3.vb#8)]

Результат выполнения этого кода выглядит следующим образом:

```console
Extension method
Instance method
```

Ситуация упрощается с помощью свойств: Если метод расширения имеет то же имя, что и свойство класса, который он расширяет, метод расширения не будет виден и к нему нельзя получить доступ.

## <a name="extension-method-precedence"></a>Приоритет метода расширения

Если два метода расширения, имеющие идентичные сигнатуры, находятся в области видимости и доступны, будет вызван один из них с более высоким приоритетом. Приоритет метода расширения основан на механизме, который используется для приведения метода в область. В следующем списке показана иерархия очередностью, от самого высокого до самого низкого.

1. Методы расширения, определенные в текущем модуле.

2. Методы расширения, определенные внутри типов данных в текущем пространстве имен или на любом из его родителей, с дочерними пространствами имен с более высоким приоритетом, чем у родительских пространств имен.

3. Методы расширения, определенные внутри любых импортов типов в текущем файле.

4. Методы расширения, определенные в любом импорте пространства имен в текущем файле.

5. Методы расширения, определенные внутри любых импортов типа на уровне проекта.

6. Методы расширения, определенные внутри любых импортов пространства имен на уровне проекта.

Если приоритет не позволяет устранить неоднозначность, можно использовать полное имя, чтобы указать вызываемый метод. Если `Print` метод в предыдущем примере определен в модуле с именем `StringExtensions` , полное имя `StringExtensions.Print(example)` вместо `example.Print()` .

## <a name="see-also"></a>См. также

- <xref:System.Runtime.CompilerServices>
- <xref:System.Runtime.CompilerServices.ExtensionAttribute>
- [Методы расширения](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)
- [Оператор Module](../../../language-reference/statements/module-statement.md)
- [Параметры и аргументы процедуры](procedure-parameters-and-arguments.md)
- [Необязательные параметры](optional-parameters.md)
- [Массивы параметров](parameter-arrays.md)
- [Обзор атрибутов](../../concepts/attributes/index.md)
- [Область видимости в Visual Basic](../declared-elements/scope.md)
