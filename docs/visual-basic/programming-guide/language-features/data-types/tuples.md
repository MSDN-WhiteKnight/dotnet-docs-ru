---
description: Дополнительные сведения о кортежах (Visual Basic)
title: Кортежи
ms.date: 04/23/2017
helpviewer_keywords:
- tuples [Visual Basic]
ms.assetid: 3e66cd1b-3432-4e1d-8c37-5ebacae8f53f
ms.openlocfilehash: f598facb446b7d50864c0cf9151195cfcde158bb
ms.sourcegitcommit: 10e719780594efc781b15295e499c66f316068b8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2021
ms.locfileid: "100454460"
---
# <a name="tuples-visual-basic"></a>Кортежи (Visual Basic)

Начиная с Visual Basic 2017, язык Visual Basic предлагает встроенную поддержку кортежей, которые упрощают создание кортежей и доступ к элементам кортежей. Кортеж — это упрощенная структура данных, которая имеет определенное число и последовательность значений. При создании экземпляра кортежа вы определяете число и тип данных каждого значения (или элемента). Например, 2 кортежа (или пара) имеет два элемента. Первый может быть `Boolean` значением, а вторым — `String` . Поскольку кортежи упрощают хранение нескольких значений в одном объекте, они часто используются в качестве упрощенного способа возврата нескольких значений из метода.

> [!IMPORTANT]
> Для поддержки кортежей требуется <xref:System.ValueTuple> тип. Если платформа .NET Framework 4,7 не установлен, необходимо добавить пакет NuGet `System.ValueTuple` , доступный в коллекции NuGet. Без этого пакета может возникнуть ошибка компиляции, аналогичная "предопределенный тип ValueTuple (Of,,,)" не определен или не импортирован ".

## <a name="instantiating-and-using-a-tuple"></a>Создание экземпляров и использование кортежа

Вы создаете экземпляр кортежа, заключая в круглые скобки значения, разделенные запятыми. Каждое из этих значений затем превращается в поле кортежа. Например, следующий код определяет тройной (или 3-кортежный) элемент, а в качестве `Date` его первого значения в `String` качестве второго, а в `Boolean` качестве третьего.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#1)]

По умолчанию имя каждого поля в кортеже состоит из строки `Item` вместе с позицией поля, основанной на единице, в кортеже. Для этого трехмерного кортежа `Date` поле имеет значение `Item1` , `String` поле — `Item2` , а `Boolean` поле — `Item3` . В следующем примере выводятся значения полей кортежа, созданного в предыдущей строке кода.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#2)]

Поля Visual Basic кортежа доступны для чтения и записи; После создания экземпляра кортежа можно изменить его значения. В следующем примере изменяются два из трех полей кортежа, созданного в предыдущем примере, и отображается результат.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#3)]

## <a name="instantiating-and-using-a-named-tuple"></a>Создание экземпляров и использование именованного кортежа

Вместо использования имен по умолчанию для полей кортежа можно создать экземпляр *именованного кортежа* , назначив собственные имена элементам кортежа. Затем к полям кортежа можно получить доступ по их назначенным именам *или* по именам по умолчанию. В следующем примере создается один и тот же 3-кортеж, как раньше, за исключением того, что он явно именует первое поле `EventDate` , второе `Name` и третье `IsHoliday` . Затем он отображает значения полей, изменяет их и снова отображает значения полей.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#4)]

## <a name="inferred-tuple-element-names"></a>Выводимые имена элементов кортежа

Начиная с Visual Basic 15,3, Visual Basic может определять имена элементов кортежа. их не нужно назначать явным образом. Выводимые имена кортежей полезны при инициализации кортежа из набора переменных и если имя элемента кортежа должно совпадать с именем переменной.

В следующем примере создается `stateInfo` кортеж, содержащий три явно именованных элемента, `state` , `stateName` и `capital` . Обратите внимание, что при именовании элементов оператор инициализации кортежа просто присваивает именованным элементам значения переменных с одинаковыми именами.

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#1)]

Поскольку элементы и переменные имеют одинаковое имя, компилятор Visual Basic может вывести имена полей, как показано в следующем примере.

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

Чтобы включить выводимые имена элементов кортежа, необходимо определить версию компилятора Visual Basic для использования в файле проекта Visual Basic ( \* VBPROJ):

```xml
<PropertyGroup>
  <LangVersion>15.3</LangVersion>
</PropertyGroup>
```

Номер версии может быть любой версией компилятора Visual Basic, начиная с 15,3. Вместо того чтобы жестко программировать конкретную версию компилятора, можно также указать "latest" в качестве значения `LangVersion` для компиляции с последней версией компилятора Visual Basic, установленного в системе.

Дополнительные сведения см. [в разделе Задание версии языка Visual Basic](../../../language-reference/configure-language-version.md).

В некоторых случаях компилятор Visual Basic не может определить имя элемента кортежа из имени кандидата, а на поле кортежа можно ссылаться только по имени по умолчанию, например `Item1` , и `Item2` т. д. К ним относятся:

- Имя кандидата совпадает с именем элемента кортежа, например `Item3` , `Rest` или `ToString` .

- Имя кандидата дублируется в кортеже.

При сбое определения имени поля Visual Basic не создает ошибку компилятора, а во время выполнения не создается исключение. Вместо этого на поля кортежа должны ссылаться их предопределенные имена, такие как `Item1` и `Item2` .

## <a name="tuples-versus-structures"></a>Кортежи и структуры

Visual Basic кортеж — это тип значения, который является экземпляром одного из универсальных типов **System. ValueTuple** . Например, кортеж, `holiday` определенный в предыдущем примере, является экземпляром <xref:System.ValueTuple%603> структуры. Она разработана как облегченный контейнер для данных. Поскольку кортеж предназначен для упрощения создания объекта с несколькими элементами данных, в нем отсутствуют некоторые функции, которые могут иметься в пользовательской структуре. Сюда входит следующее.

- Пользовательские элементы. Нельзя определить собственные свойства, методы или события для кортежа.

- Проверка. Невозможно проверить данные, назначенные полям.

- Неизменяемости. Visual Basic кортежи являются изменяемыми. В отличие от этого, пользовательская структура позволяет контролировать, является ли экземпляр изменяемым или неизменяемым.

Если важны пользовательские члены, проверка свойств и полей или неизменность, следует использовать инструкцию Visual Basic [Structure](../../../language-reference/statements/structure-statement.md) для определения пользовательского типа значения.

Visual Basicный кортеж наследует члены его типа **ValueTuple** . Помимо полей, в их число входят следующие методы.

| Метод | Описание |
| ---|---|
| CompareTo | Сравнивает текущий кортеж с другим кортежем с тем же количеством элементов. |
| Равно | Определяет, равен ли текущий кортеж другому кортежу или объекту. |
| GetHashCode | Вычисляет хэш-код для текущего экземпляра. |
| ToString | Возвращает строковое представление этого кортежа, которое принимает форму `(Item1, Item2...)` , где `Item1` и `Item2` представляет значения полей кортежа. |

Кроме того, типы **ValueTuple** реализуют <xref:System.Collections.IStructuralComparable> <xref:System.Collections.IStructuralEquatable> интерфейсы и, которые позволяют определять пользовательские компараторы.

## <a name="assignment-and-tuples"></a>Назначение и кортежи

Visual Basic поддерживает присваивание между типами кортежей, которые имеют одинаковое число полей. Типы полей можно преобразовать, если выполняется одно из следующих условий.

- Исходное и целевое поля имеют один и тот же тип.

- Определено расширяющее (или неявное) преобразование исходного типа в целевой тип.

- `Option Strict` имеет значение `On` , и определяется суженное (или явное) преобразование исходного типа в целевой тип. Это преобразование может вызвать исключение, если исходное значение находится за пределами диапазона целевого типа.

Другие преобразования в контексте назначений не учитываются. Рассмотрим возможные виды назначений между типами кортежей.

В приведенных ниже примерах можно использовать указанные переменные:

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#1)]

Первые две переменные, `unnamed` и `anonymous` , не имеют семантических имен, предоставленных для полей. По умолчанию используются имена полей `Item1` и `Item2` . Две последние переменные `named` и `differentName` имеют имена семантических полей. Обратите внимание на то, что поля в этих двух кортежах называются по-разному.

Все четыре из этих кортежей имеют одинаковое число полей (называемое арностью), а типы этих полей идентичны. Таким образом, все эти назначения работают:

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#2)]

Обратите внимание на то, что имена кортежей не назначаются. Значения полей назначаются в соответствии с порядком полей в кортеже.

Наконец, обратите внимание, что можно присвоить `named` кортеж `conversion` кортежу, даже если первое поле `named` является `Integer` , а первое поле `conversion` — `Long` . Это назначение выполнено, так как преобразование `Integer` в в `Long` представляет собой расширяющее преобразование.

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#3)]

Кортежи с разными числами полей не могут быть назначены:

```vb
' Does not compile.
' VB30311: Value of type '(Integer, Integer, Integer)' cannot be converted
'          to '(Answer As Integer, Message As String)'
var differentShape = (1, 2, 3)
named = differentShape
```

## <a name="tuples-as-method-return-values"></a>Кортежи как возвращаемые значения методов

Метод может возвращать только одно значение. Однако часто требуется, чтобы вызов метода возвращал несколько значений. Существует несколько способов обойти это ограничение:

- Можно создать пользовательский класс или структуру, свойства или поля которой представляют значения, возвращаемые методом. Таким решением является высокоплотное решение; для этого необходимо определить пользовательский тип, предназначенный только для извлечения значений из вызова метода.

- Можно вернуть одно значение из метода и вернуть оставшиеся значения, передав их по ссылке к методу. Это включает дополнительные издержки при создании экземпляра переменной и риск непреднамеренной перезаписи значения переменной, которую вы передаете по ссылке.

- Можно использовать кортеж, который предоставляет упрощенное решение для извлечения нескольких возвращаемых значений.

Например, методы **TryParse** в .NET возвращают `Boolean` значение, указывающее, была ли операция анализа успешной. Результат операции синтаксического анализа возвращается в переменную, передаваемой по ссылке на метод. Как правило, вызов метода синтаксического анализа, например, <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> выглядит следующим образом:

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#1)]

Мы можем вернуть кортеж из операции синтаксического анализа, если заключить вызов <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> метода в собственный метод. В следующем примере `NumericLibrary.ParseInteger` вызывается <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> метод и возвращается именованный кортеж с двумя элементами.

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

Затем можно вызвать метод с помощью следующего кода:

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

## <a name="visual-basic-tuples-and-tuples-in-the-net-framework"></a>Visual Basic кортежи и кортежи в платформа .NET Framework

Visual Basic кортеж — это экземпляр одного из универсальных типов **System. ValueTuple** , которые появились в платформа .NET Framework 4,7. Платформа .NET Framework также включает набор универсальных классов **System. Tuple** . Однако эти классы отличаются от Visual Basic кортежей и универсальных типов **System. ValueTuple** несколькими способами:

- Элементы классов **кортежей** — это свойства с именами `Item1` , `Item2` и т. д. В Visual Basic кортежах и типах **ValueTuple** элементы кортежа являются полями.

- Нельзя присваивать осмысленные имена элементам экземпляра **кортежа** или экземпляра **ValueTuple** . Visual Basic позволяет назначать имена, которые сообщают значение полей.

- Свойства экземпляра **кортежа** доступны только для чтения; кортежи являются неизменяемыми. В Visual Basic кортежах и типах **ValueTuple** поля кортежей доступны для чтения и записи. кортежи являются изменяемыми.

- Универсальные типы **кортежей** являются ссылочными типами. Использование этих типов **кортежей** означает выделение объектов. В критических путях это может заметно влиять на производительность приложения. Visual Basic кортежи и типы **ValueTuple** являются типами значений.

Методы расширения в <xref:System.TupleExtensions> классе упрощают преобразование между Visual Basic кортежами и объектами **кортежей** .NET. Метод **тотупле** преобразует кортеж Visual Basic в объект **кортежа** .NET, а метод **товалуетупле** преобразует объект **кортежа** .NET в кортеж Visual Basic.

В следующем примере создается кортеж, преобразуется в объект **кортежа** .NET и преобразуется обратно в Visual Basic кортеж. Затем в примере сравнивается этот кортеж с исходным, чтобы убедиться, что он равен.

[!code-vb[Convert](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple2.vb#1)]

## <a name="see-also"></a>См. также

- [Справочник по языку Visual Basic](index.md)
