---
description: 'Дополнительные сведения: вызов свойства или метода с помощью имени строки (Visual Basic)'
title: Вызов свойства или метода с помощью строкового имени
ms.date: 07/20/2015
helpviewer_keywords:
- passing operators [Visual Basic]
- strings [Visual Basic], passing new operators as
- objects [Visual Basic], setting properties
- setting properties, object properties at run time
- method calls [Visual Basic], strings
- methods [Visual Basic], calling with string names
- calling methods [Visual Basic], string names
- properties [Visual Basic], setting at run time
- CallByName function
ms.assetid: 79a7b8b4-b8c7-4ad8-aca8-12a9a2b32f03
ms.openlocfilehash: ad14f66ef4e3e06b969cb39a0203442cb0a4f1bb
ms.sourcegitcommit: 10e719780594efc781b15295e499c66f316068b8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2021
ms.locfileid: "100434424"
---
# <a name="calling-a-property-or-method-using-a-string-name-visual-basic"></a>Вызов свойства или метода с помощью строкового имени (Visual Basic)

В большинстве случаев можно обнаружить свойства и методы объекта во время разработки и написать код для их обработки. Однако в некоторых случаях вам не известно о свойствах и методах объекта заранее, или вам может потребоваться гибкость, позволяющая пользователю указывать свойства или выполнять методы во время выполнения.  
  
## <a name="callbyname-function"></a>Функция CallByName  

 Рассмотрим, например, клиентское приложение, которое оценивает выражения, вводимых пользователем, передавая оператор в COM-компонент. Предположим, что вы постоянно добавляете новые функции в компонент, требующий новых операторов. При использовании методов доступа к стандартным объектам необходимо перекомпилировать и повторно распространить клиентское приложение, прежде чем оно сможет использовать новые операторы. Чтобы избежать этого, можно использовать `CallByName` функцию для передачи новых операторов в виде строк без изменения приложения.  
  
 `CallByName`Функция позволяет использовать строку для указания свойства или метода во время выполнения. Сигнатура для `CallByName` функции выглядит следующим образом:  
  
   =  Результат `CallByName` (*Object*, *ProcedureName*, *каллтипе*, *arguments*())  
  
 Первый аргумент, *объект*, принимает имя объекта, с которым вы хотите работать. Аргумент *ProcedureName* принимает строку, содержащую имя метода или процедуры свойства, которые необходимо вызвать. Аргумент *каллтипе* принимает константу, представляющую тип вызываемой процедуры: метод ( `Microsoft.VisualBasic.CallType.Method` ), свойство Read ( `Microsoft.VisualBasic.CallType.Get` ) или набор свойств ( `Microsoft.VisualBasic.CallType.Set` ). Аргумент *arguments* , который является необязательным, принимает массив типа `Object` , который содержит любые аргументы для процедуры.  
  
 `CallByName`В текущем решении можно использовать с классами, но чаще всего они используются для доступа к COM-объектам или объектам из платформа .NET Framework сборок.  
  
 Предположим, что вы добавили ссылку на сборку, содержащую класс с именем `MathClass` , который содержит новую функцию с именем `SquareRoot` , как показано в следующем коде:  
  
 [!code-vb[VbVbalrOOP#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#53)]  
  
 Приложение может использовать элементы управления "текстовое поле" для управления тем, какой метод будет вызываться, и его аргументы. Например, если `TextBox1` содержит выражение для вычисления и `TextBox2` используется для ввода имени функции, можно использовать следующий код для вызова `SquareRoot` функции в выражении в `TextBox1` :  
  
 [!code-vb[VbVbalrOOP#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#54)]  
  
 Если ввести «64» в `TextBox1` , «SquareRoot» в `TextBox2` , а затем вызвать `CallMath` процедуру, вычисляется квадратный корень числа в `TextBox1` . Код в примере вызывает `SquareRoot` функцию (которая принимает строку, содержащую выражение, которое должно быть оценено как обязательный аргумент) и возвращает "8" в `TextBox1` (квадратный корень из 64). Конечно, если пользователь вводит недопустимую строку в `TextBox2` , если строка содержит имя свойства вместо метода или если метод имел дополнительный обязательный аргумент, возникает ошибка времени выполнения. Необходимо добавить надежный код обработки ошибок, если вы используете `CallByName` , чтобы предвидеть эти или любые другие ошибки.  
  
> [!NOTE]
> Хотя `CallByName` функция может быть полезной в некоторых случаях, необходимо взвесить ее полезность относительно влияния на производительность `CallByName` . использование для вызова процедуры немного медленнее, чем вызов с поздним связыванием. При вызове функции, которая вызывается многократно, например внутри цикла, `CallByName` может серьезно повлиять на производительность.  
  
## <a name="see-also"></a>См. также раздел

- <xref:Microsoft.VisualBasic.Interaction.CallByName%2A>
- [Определение типа объекта](determining-object-type.md)
