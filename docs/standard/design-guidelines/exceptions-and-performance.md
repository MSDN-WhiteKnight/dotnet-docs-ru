---
description: 'Узнайте подробнее о: Исключения и производительность'
title: Исключения и производительность
ms.date: 10/22/2008
helpviewer_keywords:
- tester-doer pattern
- TryParse pattern
- exceptions, throwing
- exceptions, performance
- throwing exceptions, performance
ms.assetid: 3ad6aad9-08e6-4232-b336-0e301f2493e6
ms.openlocfilehash: 72b35ccca5514e56dcc04fc0a07d1f9887c4a2f7
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99642127"
---
# <a name="exceptions-and-performance"></a>Исключения и производительность

Одной из распространенных проблем, связанных с исключениями, является то, что если исключения используются для кода, который регулярно завершается ошибкой, производительность реализации будет неприемлемой. Это является действительной проблемой. Когда элемент выдает исключение, его производительность может быть на порядок ниже. Тем не менее можно достичь хорошей производительности, строго придерживаясь рекомендаций по исключениям, которые не допускают использование кодов ошибок. В двух шаблонах, описанных в этом разделе, предложены способы сделать это.

 ❌ НЕ используйте коды ошибок из-за опасений, что исключения могут негативно сказаться на производительности.

 Повысить производительность можно с помощью шаблона Tester-Doer или Try-Parse, описанных в следующих двух разделах.

## <a name="tester-doer-pattern"></a>Шаблон Tester-Doer

 Иногда производительность элемента, вызывающего исключение, можно улучшить, разбив его на два элемента. Рассмотрим метод <xref:System.Collections.Generic.ICollection%601.Add%2A> интерфейса <xref:System.Collections.Generic.ICollection%601>.

```csharp
ICollection<int> numbers = ...
numbers.Add(1);
```

 Будет возвращен метод `Add`, если коллекция доступна только для чтения. В сценариях, когда ожидается, что вызов метода будет часто завершаться ошибкой, это может быть проблемой с производительностью. Один из способов устранения проблемы — проверить, является ли коллекция доступной для записи, прежде чем пытаться добавить значение.

```csharp
ICollection<int> numbers = ...
...
if (!numbers.IsReadOnly)
{
    numbers.Add(1);
}
```

 Элемент, используемый для проверки условия, которое в нашем примере является свойством `IsReadOnly`, называется тестировщиком (tester). Элемент, используемый для выполнения операции, которая может приводить к исключениям (метод `Add` в нашем примере), называется исполнителем (doer).

 ✔️ Рассмотрите возможность использования шаблона Test-Doer для элементов, которые могут выдавать исключения в распространенных сценариях, чтобы избежать проблем с производительностью, вызванных исключениями.

## <a name="try-parse-pattern"></a>Шаблон Try-Parse

 Для API-интерфейсов, в которых очень важна производительность, следует использовать более быстрый шаблон, чем шаблон Test-Doer, описанный в предыдущем разделе. Шаблон вызывает метод для корректировки имени элемента, чтобы сделать строго определенный тестовый случай частью семантики элемента. Например, <xref:System.DateTime> определяет метод <xref:System.DateTime.Parse%2A>, который выдает исключение, если синтаксический анализ строки завершается ошибкой. Он также определяет соответствующий метод <xref:System.DateTime.TryParse%2A>, который пытается выполнить синтаксический анализ, но возвращает значение false, если синтаксический анализ завершается неудачно, и возвращает результат успешного синтаксического анализа с помощью параметра `out`.

```csharp
public struct DateTime
{
    public static DateTime Parse(string dateTime)
    {
        ...
    }
    public static bool TryParse(string dateTime, out DateTime result)
    {
        ...
    }
}
```

 При использовании этого шаблона важно определить функциональность Try в сжатые сроки. Если элемент завершается ошибкой по какой-либо причине, отличной от правильно определенного шаблона Try, элемент должен по-прежнему вызывать соответствующее исключение.

 ✔️ Рассмотрите возможность использования шаблона Try-Parse для элементов, которые могут выдавать исключения в распространенных сценариях, чтобы избежать проблем с производительностью, вызванных исключениями.

 ✔️ ИСПОЛЬЗУЙТЕ префикс "Try" и логический тип возвращаемого значения для методов, реализующих этот шаблон.

 ✔️ ПРЕДОСТАВЬТЕ элемент, выдающий исключения, для каждого элемента с помощью шаблона Try-Parse.

 *Фрагменты: © Корпорация Майкрософт (Microsoft Corporation), 2005, 2009. Все права защищены.*

 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*

## <a name="see-also"></a>См. также

- [Рекомендации по проектированию на основе Framework](index.md)
- [Правила разработки исключений](exceptions.md)
