---
title: Вопросы безопасности сборок
description: При создании сборки .NET можно указать разрешения, которые требуются для ее выполнения. В этой статье описаны сборки со строгими именами и средства подписывания.
ms.date: 08/20/2019
helpviewer_keywords:
- assemblies [.NET], security
- signcodes
- names [.NET], assemblies
- strong-named assemblies, security considerations
- signing assemblies
- assemblies [.NET], signing
- granting permissions, assemblies
- assemblies [.NET], strong-named
- names [.NET], strong names
- permissions [.NET], assemblies
- security [.NET], assemblies
- integrity with assemblies
ms.assetid: 1b5439c1-f3d5-4529-bd69-01814703d067
ms.openlocfilehash: 91ea206abf80da275651854b9f13aa0116b7a1c5
ms.sourcegitcommit: 279fb6e8d515df51676528a7424a1df2f0917116
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/27/2020
ms.locfileid: "92687269"
---
# <a name="assembly-security-considerations"></a>Вопросы безопасности сборок

При создании сборки можно указать набор разрешений, который требуется для ее выполнения. От свидетельства зависит, предоставляются ли сборке определенные разрешения. 

> [!NOTE]
> Безопасность доступа кода (Code Access Security) является устаревшей технологией, которая не реализована в .NET Core и .NET 5+, и не рекомендуется к использованию в .NET Framework 4.0+. Дополнительные сведения см. в разделе [Большинство API управления доступом для кода устарело](https://docs.microsoft.com/ru-ru/dotnet/core/compatibility/core-libraries/5.0/code-access-security-apis-obsolete).
  
 Существует два различных способа использования свидетельств.  
  
- Входное свидетельство объединяется со свидетельством, собранным загрузчиком для создания окончательного набора свидетельств, используемых для разрешения политики. К методам, использующим такую модель, относятся **Assembly.Load** , **Assembly.LoadFrom** и **Activator.CreateInstance** .  
  
- В качестве окончательного набора свидетельств для разрешения политики используется неизмененное входное свидетельство. К методам, использующим такую модель, относятся **Assembly.Load(byte[])** и **AppDomain.DefineDynamicAssembly()** .  
  
  Дополнительные разрешения могут предоставляться [политикой безопасности](https://docs.microsoft.com/en-us/previous-versions/dotnet/framework/code-access-security/code-access-security-basics), заданной на компьютере, где будет работать сборка. Для обработки в коде всех возможных исключений безопасности необходимо выполнить одно из следующих действий.  
  
- Добавить запрос разрешения для всех разрешений, которые должны быть у кода, и заранее обрабатывать сбои загрузки, которые происходят, если такие разрешения не предоставляются.  
  
- Не использовать запросы разрешения для получения необходимых разрешений для кода, но подготовиться к обработке исключений безопасности в случае, если разрешения не будут предоставлены.  
  
  > [!NOTE]
  > Безопасность является сложной областью, допускающей много вариантов настройки. Дополнительные сведения см. в разделе [Основные понятия безопасности](https://docs.microsoft.com/dotnet/standard/security/key-security-concepts).  
  
 В момент загрузки свидетельство сборки используется в качестве входных данных для политики безопасности. Политика безопасности устанавливается как организацией и администратором компьютера, так и параметрами безопасности пользователя, и определяет набор разрешений, предоставленных всему управляемому коду при его выполнении. Политика безопасности может устанавливаться для издателя сборки (если у него есть средство для создания цифровой подписи), для веб-узла и зоны (в терминах Internet Explorer), откуда была загружена сборка, или для строгого имени сборки. Например, администратор компьютера может установить политику безопасности, разрешающую всему коду, загруженному с веб-узла и подписанному определенной компанией-производителем программного обеспечения, иметь доступ к базе данных на компьютере, но запрещающую запись на диск компьютера.  
  
## <a name="strong-named-assemblies-and-signing-tools"></a>Сборки со строгими именами и средства подписывания  

 > [!WARNING]
 > Строгие имена не являются средством обеспечения безопасности. Они служат только для однозначной идентификации.

 Сборку можно подписать двумя разными, но взаимодополняющими способами: с помощью строгого имени или с помощью [SignTool.exe (программы подписывания)](https://docs.microsoft.com/dotnet/framework/tools/signtool-exe). При подписи сборки строгим именем в файл, содержащий манифест сборки, добавляется зашифрованный открытый ключ. Подпись строгим именем гарантирует уникальность имени, предотвращает подмену имени и после разрешения ссылки предоставляет вызывающему объекту определенное удостоверение.  
  
 При использовании строгого имени отсутствует связанный с ним уровень доверия, поэтому важно использовать [SignTool.exe (программу подписывания)](https://docs.microsoft.com/dotnet/framework/tools/signtool-exe). У этих двух средств подписи должен быть издатель, который может доказать свою подлинность стороннему центру сертификации и получить сертификат. После этого указанный сертификат включается в файл и может использоваться администратором для решения о том, следует ли доверять подлинности кода.  
  
 Можно присвоить сборке и строгое имя, и цифровую подпись, созданные с помощью [SignTool.exe (программы подписывания)](https://docs.microsoft.com/dotnet/framework/tools/signtool-exe), или можно использовать их по отдельности. При использовании средств подписи можно подписывать одновременно только один файл; для сборки, состоящей из нескольких файлов, подписывается файл, содержащий манифест сборки. Строгое имя хранится в файле, содержащем манифест сборки, но цифровая подпись, созданная с помощью [SignTool.exe (программы подписывания)](https://docs.microsoft.com/dotnet/framework/tools/signtool-exe), хранится в зарезервированном месте переносимого исполняемого (PE) файла, содержащего манифест сборки. Подпись сборки с помощью [SignTool.exe (программы подписывания)](https://docs.microsoft.com/dotnet/framework/tools/signtool-exe) может использоваться (со строгим именем или без него), когда уже существует иерархия доверия, основанная на подписях [SignTool.exe (программы подписывания)](https://docs.microsoft.com/dotnet/framework/tools/signtool-exe), или когда в политике используется только часть ключа и не проверяется цепочка доверия.  
  
> [!NOTE]
> При использовании для сборки как строгого имени, так и подписи сначала необходимо назначить строгое имя.  
  
 Среда CLR также выполняет проверку хэша, поскольку манифест сборки содержит список составляющих сборку файлов, в который входит и хэш каждого файла на момент создания манифеста. При загрузке каждого файла его содержимое хэшируется и сравнивается с хэш-значением в манифесте. Если хэши не совпадают, сборка не загружается.  
  
 Так как строгое именование и подпись с помощью [SignTool.exe (программы подписывания)](https://docs.microsoft.com/dotnet/framework/tools/signtool-exe) гарантирует целостность, политику управления доступом для кода можно основать на этих двух видах свидетельства сборки. Строгое именование и подпись с помощью [SignTool.exe (программы подписывания)](https://docs.microsoft.com/dotnet/framework/tools/signtool-exe) гарантируют целостность благодаря цифровым подписям и сертификатам. Все перечисленные технологии (проверка хэша, использование строгих имен и цифровая подпись с помощью [SignTool.exe (программы подписывания)](https://docs.microsoft.com/dotnet/framework/tools/signtool-exe)) используются вместе, чтобы гарантировать, что сборка не была каким-либо образом изменена.  
  
## <a name="see-also"></a>См. также

- [Сборки со строгими именами](strong-named.md)
- [Сборки в .NET](index.md)
- [SignTool.exe (программа подписывания)](https://docs.microsoft.com/dotnet/framework/tools/signtool-exe)
