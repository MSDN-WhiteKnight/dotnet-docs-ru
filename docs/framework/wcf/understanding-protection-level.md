---
description: 'Подробнее: основные сведения об уровне защиты'
title: Основные сведения об уровне защиты
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- WCF, security
- ProtectionLevel property
ms.assetid: 0c034608-a1ac-4007-8287-b1382eaa8bf2
ms.openlocfilehash: 8c6e5bc97c02e9cec4841dac0d7cf8c8b59931e1
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99631714"
---
# <a name="understanding-protection-level"></a>Основные сведения об уровне защиты

Свойство `ProtectionLevel` обнаруживается во многих классах, например в классах <xref:System.ServiceModel.ServiceContractAttribute> и <xref:System.ServiceModel.OperationContractAttribute>. Это свойство определяет, как защищается часть сообщения (или все сообщение). В этом разделе объясняется функция Windows Communication Foundation (WCF) и принципы ее работы.

Инструкции по настройке уровня защиты см. в разделе [инструкции. Установка свойства ProtectionLevel](how-to-set-the-protectionlevel-property.md).

> [!NOTE]
> Уровни защиты можно задавать только в коде, а не в конфигурации.

## <a name="basics"></a>Основные

Ниже приведены основные сведения о функции уровня защиты.

- Для любой части сообщения существуют три базовых уровня защиты. Для свойства (где бы оно ни появлялось) задается одно из значений перечисления <xref:System.Net.Security.ProtectionLevel>. Эти значения указаны ниже в порядке возрастания уровня защиты.

  - `None`.

  - `Sign`. Защищенная часть подписывается цифровой подписью. Это гарантирует защиту защищенной части сообщения от любой подделки.

  - `EncryptAndSign`. Для обеспечения конфиденциальности часть сообщения перед подписанием шифруется.

- Вы можете задать требования к защите только для *данных приложений* с помощью этой функции. Например, заголовки WS-Addressing являются данными инфраструктуры и, следовательно, `ProtectionLevel` их не затрагивает.

- Когда для режима безопасности задано значение `Transport`, все сообщение защищается механизмом транспорта. Поэтому установка отдельного уровня защиты для разных частей сообщения не имеет эффекта.

- `ProtectionLevel`— Это способ, с помощью которого разработчик может задать *минимальный уровень* , которым должна соответствовать привязка. Когда служба развернута, фактическая привязка, заданная в конфигурации, может поддерживать или не поддерживать этот минимальный уровень. Например, по умолчанию класс <xref:System.ServiceModel.BasicHttpBinding> не обеспечивает безопасность (хотя обеспечение безопасности может быть включено). Поэтому использование этого класса с контрактом, параметр которого отличен от `None`, будет приводить к вызову исключения.

- Если служба требует, чтобы минимум `ProtectionLevel` для всех сообщений был `Sign` , клиент (возможно, созданный с помощью технологии, отличной от WCF) может шифровать и подписать все сообщения (которые больше минимального необходимого). В этом случае WCF не создает исключение, так как клиент выполнил больше минимума. Однако обратите внимание, что приложения WCF (службы или клиенты) не будут перебезопасовать часть сообщения, если это возможно, но будут соответствовать минимальному уровню. Обратите также внимание, что при использовании режима `Transport` в качестве режима безопасности транспорт может чрезмерно защищать поток сообщений, поскольку он не способен обеспечить защиту на более детальном уровне.

- Если для `ProtectionLevel` явно задается значение `Sign` или `EncryptAndSign`, необходимо использовать привязку с разрешенным обеспечением безопасности. В противном случае будет вызвано исключение.

- Если выбирается привязка, разрешающая обеспечение безопасности, а свойство `ProtectionLevel` нигде в контракте не задается, все данные приложений будут шифроваться и подписываться.

- Если выбирается привязка, в которой не разрешено обеспечение безопасности (например, в классе `BasicHttpBinding` обеспечение безопасности запрещено по умолчанию), и уровень `ProtectionLevel` явно не задан, данные приложений защищаться не будут.

- Если используется привязка, которая обеспечивает безопасность на транспортном уровне, все данные приложений будут защищаться в соответствии с возможностями транспорта.

- Если используется привязка, которая обеспечивает безопасность на уровне сообщений, данные приложений будут защищаться в соответствии с уровнями защиты, заданными в контракте. Если уровень защиты не задается, все данные приложений в сообщениях будут шифроваться и подписываться.

- `ProtectionLevel` можно задать на разных уровнях области действия. Существует иерархия, связанная с областью действия, которая рассматривается в следующем разделе.

## <a name="scoping"></a>Scoping

При задании `ProtectionLevel` на самом верхнем API задается уровень для всех уровней ниже данного. Если для `ProtectionLevel` задается другое значение на более низком уровне, все интерфейсы API, расположенные ниже этого уровня в иерархии, сбрасываются на этот новый уровень (однако интерфейсы API, расположенные выше этого уровня, остаются под влиянием самого верхнего уровня). Иерархия имеет представленный ниже вид. Атрибуты на одном и том же уровне являются одноранговыми.

- <xref:System.ServiceModel.ServiceContractAttribute>

- <xref:System.ServiceModel.OperationContractAttribute>

- <xref:System.ServiceModel.FaultContractAttribute>

- <xref:System.ServiceModel.MessageContractAttribute>

- <xref:System.ServiceModel.MessageHeaderAttribute>

- <xref:System.ServiceModel.MessageBodyMemberAttribute>

## <a name="programming-protectionlevel"></a>Программирование ProtectionLevel

Чтобы запрограммировать `ProtectionLevel` в любом месте иерархии, задайте для этого свойства соответствующее значение при применении атрибута. Примеры см. в разделе [как задать свойство ProtectionLevel](how-to-set-the-protectionlevel-property.md).

> [!NOTE]
> Чтобы задать данное свойство в контрактах сбоев и сообщений, необходимо понимать работу этих функций. Дополнительные сведения см. в разделе [инструкции. Установка свойства ProtectionLevel](how-to-set-the-protectionlevel-property.md) и [использование контрактов сообщений](./feature-details/using-message-contracts.md).

## <a name="ws-addressing-dependency"></a>Зависимость от WS-Addressing

В большинстве случаев использование [средства служебной программы метаданных ServiceModel (Svcutil.exe)](servicemodel-metadata-utility-tool-svcutil-exe.md) для создания клиента гарантирует идентичность клиентских и сервисных контрактов. Однако одинаковые на первый взгляд контракты могут приводить к вызову клиентом исключения. Это происходит всякий раз, когда привязка не поддерживает спецификацию WS-Addressing и в контракте определено несколько уровней защиты. Например, это происходит при использовании класса <xref:System.ServiceModel.BasicHttpBinding>, не поддерживающего данную спецификацию, или при создании пользовательской привязки, которая не поддерживает WS-Addressing. Чтобы в одном контракте разрешить разные уровни защиты, функция `ProtectionLevel` полагается на спецификацию WS-Addressing. Если привязка не поддерживает спецификацию WS-Addressing, для всех уровней задается один и тот же уровень защиты. В качестве фактического уровня защиты для всех областей в контракте задается уровень самой мощной защиты, используемый в контракте.

Это может привести к проблеме, которую на первый взгляд сложно устранить. Можно создать контракт клиента (интерфейс), который содержит методы для нескольких служб. То есть для создания клиента, взаимодействующего с несколькими службами, используется один и тот же интерфейс, и этот единственный интерфейс содержит методы для всех служб. Разработчику следует быть внимательным в этом редком сценарии, чтобы обеспечить вызов только тех методов, которые подходят для каждой конкретной службы. Если привязкой является класс <xref:System.ServiceModel.BasicHttpBinding>, поддержка нескольких уровней защиты невозможна. Однако служба, отвечающая клиенту, может ответить и клиенту с более низким уровнем защиты, чем требуется. В этом случае клиент вызовет исключение, поскольку он ожидает более высокий уровень защиты.

В примере кода иллюстрируется эта проблема. В представленном ниже примере показаны контракты службы и клиента. Предположим, что привязка является [\<basicHttpBinding>](../configure-apps/file-schema/wcf/basichttpbinding.md) элементом. Следовательно, все операции в контракте имеют один и тот же уровень защиты. Этот одинаковый уровень защиты определяется как максимальный уровень защиты для всех операций.

Ниже приведен контракт службы:

[!code-csharp[c_ProtectionLevel#7](../../../samples/snippets/csharp/VS_Snippets_CFX/c_protectionlevel/cs/source.cs#7)]
[!code-vb[c_ProtectionLevel#7](../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_protectionlevel/vb/source.vb#7)]

В следующем коде показан интерфейс контракта клиента. Обратите внимание, что он содержит метод `Tax`, предназначенный для использования с другой службой:

[!code-csharp[c_ProtectionLevel#8](../../../samples/snippets/csharp/VS_Snippets_CFX/c_protectionlevel/cs/source.cs#8)]
[!code-vb[c_ProtectionLevel#8](../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_protectionlevel/vb/source.vb#8)]

Когда клиент вызывает метод `Price`, при получении ответа от службы он вызывает исключение. Причина этого в том, что клиент не задает `ProtectionLevel` в `ServiceContractAttribute` и, следовательно, использует значение по умолчанию (<xref:System.Net.Security.ProtectionLevel.EncryptAndSign>) для всех методов, включая метод `Price`. Однако служба возвращает значение, используя уровень <xref:System.Net.Security.ProtectionLevel.Sign>, поскольку контракт службы определяет единственный метод, в качестве уровня защиты которого задано значение <xref:System.Net.Security.ProtectionLevel.Sign>. В этом случае при проверке ответа от службы клиент вызовет ошибку.

## <a name="see-also"></a>См. также

- <xref:System.ServiceModel.ServiceContractAttribute>
- <xref:System.ServiceModel.OperationContractAttribute>
- <xref:System.ServiceModel.FaultContractAttribute>
- <xref:System.ServiceModel.MessageContractAttribute>
- <xref:System.ServiceModel.MessageHeaderAttribute>
- <xref:System.ServiceModel.MessageBodyMemberAttribute>
- <xref:System.Net.Security.ProtectionLevel>
- [Защита служб](securing-services.md)
- [Практическое руководство. Установка свойства ProtectionLevel](how-to-set-the-protectionlevel-property.md)
- [Задание и обработка сбоев в контрактах и службах](specifying-and-handling-faults-in-contracts-and-services.md)
- [Использование контрактов сообщений](./feature-details/using-message-contracts.md)
