---
description: 'Дополнительные сведения: рекомендации по обмену данными в очереди'
title: Рекомендации по взаимодействию с использованием очередей
ms.date: 03/30/2017
helpviewer_keywords:
- queues [WCF], best practices
- best practices [WCF], queued communication
ms.assetid: 446a6383-cae3-4338-b193-a33c14a49948
ms.openlocfilehash: 895b0a1a87bc84cf590f3dd4b5269b61e9399d15
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99643687"
---
# <a name="best-practices-for-queued-communication"></a>Рекомендации по взаимодействию с использованием очередей

В этом разделе приводятся рекомендации по обмену данными в очереди в Windows Communication Foundation (WCF). В последующих разделах рассматриваются рекомендации с точки зрения сценариев.  
  
## <a name="fast-best-effort-queued-messaging"></a>Быстрый наилучший обмен сообщениями с использованием очередей  

 Для сценариев, в которых требуется разделение, обеспечиваемое обменом сообщений с использованием очередей, и быстрый высокоэффективный обмен сообщениями с гарантиями наилучшего из возможного, используйте нетранзакционную очередь и задайте для свойства <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> значение `false`.  
  
 Дополнительно можно исключить затраты на запись на диск, задав для свойства <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> значение `false`.  
  
 Безопасность влияет на производительность. Дополнительные сведения см. в разделе [вопросы производительности](performance-considerations.md).  
  
## <a name="reliable-end-to-end-queued-messaging"></a>Надежный сквозной обмен сообщениями с использованием очередей  

 В последующих разделах приводятся рекомендации для сценариев, требующих надежного сквозного обмена сообщениями.  
  
### <a name="basic-reliable-transfer"></a>Базовая надежная передача  

 Для сквозной надежности установите для свойства <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> значение `true`, чтобы обеспечить передачу. Для свойства <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> можно задать значение `true` или `false`, в зависимости от требований (значение по умолчанию - `true`). Как правило, для свойства <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> задается значение `true` как составная часть сквозной надежности. Компромисс достигается за счет производительности, но сообщения становятся устойчивыми и не теряются в случае сбоя диспетчера очередей.  
  
### <a name="use-of-transactions"></a>Использование транзакций  

 Необходимо использовать транзакции для обеспечения сквозной надежности. Гарантии `ExactlyOnce` обеспечивают только доставку сообщений в целевую очередь. Чтобы гарантировать получение сообщений, используйте транзакции. Без транзакций в случае сбоя службы будет потеряно сообщение, находящееся в процессе доставки, но фактически доставленное в приложение.  
  
### <a name="use-of-dead-letter-queues"></a>Использование очередей недоставленных сообщений  

 Очереди недоставленных сообщений обеспечивают уведомления в случаях, когда не удалось доставить сообщение в целевую очередь. Можно использовать системную очередь недоставленных сообщений или пользовательскую очередь недоставленных сообщений. Как правило, лучше использовать пользовательскую очередь недоставленных сообщений, так как она позволяет отправлять недоставленные сообщения из одного приложения в отдельную очередь недоставленных сообщений. В противном случае все недоставленные сообщения из всех работающих в системе приложений будут доставляться в одну очередь. Затем каждое приложение должно просматривать очередь недоставленных сообщений, чтобы найти недоставленные сообщения, относящиеся к этому приложению. Иногда использование пользовательской очереди недоставленных сообщений невозможно, например, при использовании MSMQ 3.0.  
  
 Для сквозной надежности связи не рекомендуется выключать очереди недоставленных сообщений.  
  
 Дополнительные сведения см. [в разделе Использование очередей Dead-Letter для управления сбоями при обмене сообщениями](using-dead-letter-queues-to-handle-message-transfer-failures.md).  
  
### <a name="use-of-poison-message-handling"></a>Использование обработки подозрительных сообщений  

 Обработка подозрительных сообщений обеспечивает возможность восстановления после сбоя при обработке сообщений.  
  
 При использовании возможности обработки подозрительных сообщений убедитесь, что для свойства <xref:System.ServiceModel.MsmqBindingBase.ReceiveErrorHandling%2A> задано подходящее значение. Если свойству присвоено значение <xref:System.ServiceModel.ReceiveErrorHandling.Drop>, это означает потерю данных. С другой стороны, значение <xref:System.ServiceModel.ReceiveErrorHandling.Fault> этого свойства вызывает сбой узла службы в случае обнаружения подозрительного сообщения. При использовании MSMQ 3.0 значение <xref:System.ServiceModel.ReceiveErrorHandling.Fault> - это наилучший способ избежать потери данных и избавиться от подозрительного сообщения. При использовании MSMQ 4.0 <xref:System.ServiceModel.ReceiveErrorHandling.Move> является рекомендуемым способом. Операция <xref:System.ServiceModel.ReceiveErrorHandling.Move> обеспечивает перемещение подозрительного сообщения из очереди, чтобы служба могла продолжать обрабатывать новые сообщения. Затем служба подозрительных сообщений может отдельно обработать подозрительное сообщение.  
  
 Дополнительные сведения см. в разделе [Обработка подозрительных сообщений](poison-message-handling.md).  
  
## <a name="achieving-high-throughput"></a>Достижение высокой пропускной способности  

 Чтобы добиться высокой пропускной способности в одной конечной точке, используйте перечисленные ниже средства.  
  
- Пакетирование с поддержкой транзакций. Пакетирование с поддержкой транзакций обеспечивает возможность чтения нескольких сообщений в одной транзакции. При этом оптимизируются фиксации транзакции, что повышает общую производительность. Недостаток пакетирования заключается в том, что при сбое в одном сообщении из пакета производится откат всего пакета, и сообщения требуется обрабатывать по одному до тех пор, пока не появится возможность снова объединять их в пакет. В большинстве случаев подозрительные сообщения встречаются редко, поэтому пакетирование - это предпочтительный способ повышения производительности системы, особенно при наличии других диспетчеров ресурсов, участвующих в транзакции. Дополнительные сведения см. [в разделе пакетирование сообщений в транзакции](batching-messages-in-a-transaction.md).  
  
- Параллелизм. Параллелизм увеличивает пропускную способность, однако при этом влияет на состязание за общие ресурсы. Дополнительные сведения см. в разделе [Concurrency](../samples/concurrency.md).  
  
- Регулирование. Для получения оптимальной производительности следует регулировать количество сообщений в конвейере диспетчера. Пример того, как это сделать, см. в разделе [регулирование](../samples/throttling.md).  
  
 При использовании пакетирования помните, что параллелизм и регулирование означает параллельные пакеты.  
  
 Чтобы повысить пропускную способность и доступность, используйте ферму служб WCF, считывающую из очереди. Для этого необходимо, чтобы все эти службы предоставляли один и тот же контракт в одной конечной точке. Использование ферм больше всего подходит для приложений, создающих много сообщений, так как это позволяет нескольким службам производить чтение из одной очереди.  
  
 При использовании ферм помните, что в MSMQ 3.0 удаленные чтения в транзакциях не поддерживаются. В MSMQ 4.0 удаленные чтения в транзакциях поддерживаются.  
  
 Дополнительные сведения см. в разделе [пакетирование сообщений в транзакциях](batching-messages-in-a-transaction.md) и [различия в функциях очередей в Windows Vista, Windows Server 2003 и Windows XP](diff-in-queue-in-vista-server-2003-windows-xp.md).  
  
## <a name="queuing-with-unit-of-work-semantics"></a>Организация очереди с семантикой единицы работы  

 В некоторых сценариях очередь может содержать группу связанных между собой сообщений, для которых важен их порядок. В таких сценариях группу связанных сообщений следует обрабатывать вместе как одну единицу: либо все сообщения успешно обрабатываются, либо ни одно из сообщений не обрабатывается. Чтобы реализовать такое поведение, используйте сеансы с очередями.  
  
 Дополнительные сведения см. [в разделе Группирование сообщений, помещенных в очередь, в сеансе](grouping-queued-messages-in-a-session.md).  
  
## <a name="correlating-request-reply-messages"></a>Коррелирование сообщений типа «запрос-ответ»  

 Хотя очереди обычно являются однонаправленными, в некоторых сценариях может потребоваться корреляция полученного ответа с ранее переданным запросом. Если требуется такая корреляция, рекомендуется применять свой собственный заголовок сообщения SOAP, содержащий корреляционные сведения для сообщения. Обычно отправитель добавляет этот заголовок в сообщение, а получатель, после обработки сообщения и передачи нового ответного сообщения в очередь ответов, добавляет заголовок сообщения отправителя, содержащий корреляционную информацию, чтобы отправитель мог связать ответное сообщение с сообщением запроса.  
  
## <a name="integrating-with-non-wcf-applications"></a>Интеграция с приложениями, не являющимися приложениями WCF  

 Используется `MsmqIntegrationBinding` при интеграции служб WCF или клиентов со службами или клиентами, не являющимися WCF. Приложение, не являющееся приложением WCF, может быть приложением MSMQ, написанным с помощью System. Messaging, COM+, Visual Basic или C++.  
  
 При использовании `MsmqIntegrationBinding` помните следующее:  
  
- Текст сообщения WCF отличается от текста сообщения MSMQ. При отправке сообщения WCF с помощью привязки в очереди текст сообщения WCF помещается в сообщение MSMQ. Инфраструктура MSMQ не замечает эту дополнительную информацию - она видит только сообщение MSMQ.  
  
- Класс `MsmqIntegrationBinding` поддерживает распространенные типы сериализации. На основе типа сериализации тип тела универсального сообщения, <xref:System.ServiceModel.MsmqIntegration.MsmqMessage%601>, принимает параметры разных типов. Например, для <xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat.ByteArray> требуется `MsmqMessage\<byte[]>`, а для <xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat.Stream> требуется `MsmqMessage<Stream>`.  
  
- С помощью XML-сериализации можно указать известный тип с помощью `KnownTypes` атрибута [\<behavior>](../../configure-apps/file-schema/wcf/behavior-of-servicebehaviors.md) элемента, который затем используется для определения способа ДЕСЕРИАЛИЗАЦИИ XML-сообщения.  
  
## <a name="see-also"></a>См. также

- [Очереди в WCF](queuing-in-wcf.md)
- [Практическое руководство. Обмен сообщениями в очереди с конечными точками WCF](how-to-exchange-queued-messages-with-wcf-endpoints.md)
- [Практическое руководство. Обмен сообщениями с конечными точками WCF и приложениями очереди сообщений](how-to-exchange-messages-with-wcf-endpoints-and-message-queuing-applications.md)
- [Группирование сообщений в очереди в рамках сеанса](grouping-queued-messages-in-a-session.md)
- [Объединение сообщений в одну транзакцию](batching-messages-in-a-transaction.md)
- [Использование очередей недоставленных сообщений для обработки сбоев при передаче сообщений](using-dead-letter-queues-to-handle-message-transfer-failures.md)
- [Обработка подозрительных сообщений](poison-message-handling.md)
- [Различия в возможностях очередей в Windows Vista, Windows Server 2003 и Windows XP](diff-in-queue-in-vista-server-2003-windows-xp.md)
- [Защита сообщений с использованием средств обеспечения безопасности транспорта](securing-messages-using-transport-security.md)
- [Защита сообщений с использованием средств обеспечения безопасности сообщений](securing-messages-using-message-security.md)
- [Устранение неполадок обмена сообщениями с использованием очередей](troubleshooting-queued-messaging.md)
