---
description: 'Дополнительные сведения: повышение привилегий'
title: Повышение привилегий
ms.date: 03/30/2017
helpviewer_keywords:
- elevation of privilege [WCF]
- security [WCF], elevation of privilege
ms.assetid: 146e1c66-2a76-4ed3-98a5-fd77851a06d9
ms.openlocfilehash: 65aff3b8a1f258f68333fe39a2c980ae523d9ee9
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99704944"
---
# <a name="elevation-of-privilege"></a>Повышение привилегий

*Повышение прав доступа* от предоставления злоумышленнику разрешений, относящихся к учетным данным, которые не были предоставлены изначально. Например, злоумышленник, ранее имевший разрешение «только для чтения», может каким-либо образом расширить его до уровня «чтение и запись».  
  
## <a name="trusted-sts-should-sign-saml-token-claims"></a>Доверенная служба маркеров безопасности должна подписывать утверждения маркеров SAML  

 Маркер языка SAML (Security Assertions Markup Language) - это универсальный маркер XML, являющийся типом по умолчанию для выдаваемых маркеров. Маркер SAML может создаваться при обмене данными службой маркеров безопасности, которой веб-служба доверяет. Маркеры SAML содержат утверждения в операторах. Злоумышленник может скопировать утверждения из действительного маркера, создать новый маркер SAML и подписать его именем другого издателя. Идея состоит в том, чтобы проверить, проверяет ли сервер издателей, и, если сервер этого не делает, создать маркеры SAML, расширяющие права по сравнению с правами, которые выдаются доверенной службой маркеров безопасности.  
  
 Класс <xref:System.IdentityModel.Tokens.SamlAssertion> проверяет цифровые подписи в токене SAML, и класс <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> по умолчанию требует, чтобы токены SAML были подписаны сертификатом X.509, если свойство <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> класса <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> имеет значение <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>. Одного использования режима `ChainTrust` недостаточно, чтобы определить, является ли издатель токена SAML доверенным. Службы, которым требуется более детальная модель управления безопасностью, могут использовать политики авторизации и принудительного применения для проверки издателей наборов утверждений, создаваемых при проверке подлинности токенов, или использовать параметры проверки X.509 в <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> для ограничения набора разрешенных сертификатов подписи. Дополнительные сведения см. [в разделе Управление утверждениями и авторизация с помощью модели удостоверений](managing-claims-and-authorization-with-the-identity-model.md) и [Федерации и выданных маркеров](federation-and-issued-tokens.md).  
  
## <a name="switching-identity-without-a-security-context"></a>Смена удостоверения без контекста безопасности  

 Следующее применимо только к WinFX.  
  
 При установлении соединения между клиентом и сервером удостоверение клиента не меняется, за исключением одной ситуации: после открытия клиента WCF, если выполняются все перечисленные ниже условия.  
  
- Процедуры установки контекста безопасности (с использованием сеанса безопасности транспорта или сеанса безопасности сообщений) отключены ( <xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> свойство имеет значение `false` в случае безопасности сообщений или транспорта, не способных устанавливать сеансы безопасности, используется в случае безопасности транспорта. Пример подобного транспорта - HTTPS.);  
  
- используется проверка подлинности Windows;  
  
- учетные данные не задаются явным образом;  
  
- служба вызывается в олицетворенном контексте безопасности.  
  
 Если эти условия верны, удостоверение, используемое для проверки подлинности клиента со службой, может измениться (это может быть не олицетворенное удостоверение, а идентификатор процесса) после открытия клиента WCF. Это происходит потому, что удостоверение Windows, которое используется для проверки подлинности клиента на стороне службы, передается с каждым сообщением, а удостоверение, которое используется для проверки подлинности, получается из удостоверения Windows текущего потока. Если удостоверение Windows текущего потока изменяется (например, путем олицетворения другого вызывающего объекта), удостоверение, которое прикрепляется к сообщению и используется для проверки подлинности клиента на стороне службы, также может измениться.  
  
 Если при использовании проверки подлинности Windows совместно с олицетворением требуется детерминированное поведение, необходимо явным образом задать учетные данные Windows или установить со службой контекст безопасности. Для этого следует использовать сеанс безопасности сообщений или сеанс безопасности транспорта. Например, сеанс безопасности транспорта можно обеспечить с помощью транспорта net.tcp. Кроме того, при вызове службы необходимо использовать только синхронную версию операций клиента. При установки контекста безопасности сообщений необходимо поддерживать подключение к службе открытым дольше, чем длится настроенный период обновления сеанса, поскольку удостоверение также может измениться в процессе обновления сеанса.  
  
### <a name="credentials-capture"></a>Получение учетных данных  

 Следующее применимо к платформа .NET Framework 3,5 и следующим версиям.  
  
 Учетные данные, используемые клиентом или службой, основаны на текущем потоке контекста. Получение учетных данных происходит, когда вызывается метод `Open` (или `BeginOpen` для асинхронных вызовов) клиента или службы. Для классов <xref:System.ServiceModel.ServiceHost> и <xref:System.ServiceModel.ClientBase%601> методы `Open` и `BeginOpen` наследуются от методов <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> и <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> класса <xref:System.ServiceModel.Channels.CommunicationObject>.  
  
> [!NOTE]
> При использовании метода `BeginOpen` невозможно гарантировать, что получаемые учетные данные принадлежат процессу, вызвавшему метод.  
  
## <a name="token-caches-allow-replay-using-obsolete-data"></a>Кэширование делает возможным повторное использование маркеров с помощью устаревших данных  

 WCF использует функцию локального центра безопасности (LSA) `LogonUser` для проверки подлинности пользователей по имени пользователя и паролю. Поскольку функция входа в систему является дорогостоящей, WCF позволяет кэшировать маркеры, которые представляют пользователей, прошедших проверку подлинности, для повышения производительности. Механизм кэширования сохраняет результаты предыдущей функции `LogonUser` для использования в будущем. Этот механизм отключен по умолчанию. чтобы включить его, задайте <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> для свойства значение `true` или используйте `cacheLogonTokens` атрибут [\<userNameAuthentication>](../../configure-apps/file-schema/wcf/usernameauthentication.md) .  
  
 Чтобы установить срок жизни кэшированных маркеров, задайте для свойства <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> значение <xref:System.TimeSpan> или установите значение атрибута `cachedLogonTokenLifetime` элемента `userNameAuthentication`; значение по умолчанию - 15 минут. Обратите внимание, что пока маркер находится в кэше, любой клиент, который указывает соответствующие имя пользователя и пароль, может использовать маркер, даже если учетная запись была удалена из Windows или если пароль изменился. До истечения срока жизни и удаления маркера из кэша WCF позволяет пользователю (возможно, злоумышленнику) проходить проверку подлинности.  
  
 Чтобы ограничить связанные с этим угрозы, уменьшите вероятность атаки, задав в качестве значения `cachedLogonTokenLifetime` минимальный промежуток времени, который может потребоваться пользователям.  
  
## <a name="issued-token-authorization-expiration-reset-to-large-value"></a>Авторизация выданных маркеров: сброс времени истечения до больших значений  

 При выполнении некоторых условий для свойства <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> объекта <xref:System.IdentityModel.Policy.AuthorizationContext> может быть установлено неожиданно большое значение (значение поля <xref:System.DateTime.MaxValue> минус один день или 20 декабря 9999 г.).  
  
 Это происходит при использовании <xref:System.ServiceModel.WSFederationHttpBinding> и любой из предоставляемых системой привязок, которые получили в качестве типа удостоверения клиента выданный маркер.  
  
 Кроме того, это происходит при создании пользовательских привязок с помощью одного из следующих методов.  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement%2A>  
  
 Чтобы ограничить эту проблему, политика авторизации должна проверять действие и срок действия каждой политики авторизации.  
  
## <a name="the-service-uses-a-different-certificate-than-the-client-intended"></a>Служба использует не тот сертификат, который ожидает клиент  

 При выполнении определенных условий клиент может снабдить сообщение цифровой подписью с сертификатом X.509, но служба извлечет другой сертификат.  
  
 Это может произойти при следующих обстоятельствах.  
  
- Клиент снабжает сообщение цифровой подписью с сертификатом X.509, но не прикрепляет к сообщению сертификат X.509; вместо этого он только ссылается на сертификат, используя идентификатор ключа субъекта.  
  
- Компьютер службы содержит один или несколько сертификатов с одним и тем же открытым ключом, но они содержат различную информацию.  
  
- Служба извлекает сертификат, соответствующий идентификатору ключа субъекта, но оказывается, что это не тот сертификат, использования которого ожидал клиент. Когда WCF получает сообщение и проверяет подпись, WCF сопоставляет сведения в непреднамеренном сертификате X. 509 с набором утверждений, которые могут быть разными и потенциально более высоким от ожидаемого клиентом.  
  
 Чтобы избежать этого, следует ссылаться на сертификат X.509 иначе, например с помощью поля <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.  
  
## <a name="see-also"></a>См. также

- [Вопросы безопасности](security-considerations-in-wcf.md)
- [Раскрытие информации](information-disclosure.md)
- [Отказ в обслуживании](denial-of-service.md)
- [Атаки с повторением](replay-attacks.md)
- [Незаконное изменение](tampering.md)
- [Неподдерживаемые сценарии](unsupported-scenarios.md)
