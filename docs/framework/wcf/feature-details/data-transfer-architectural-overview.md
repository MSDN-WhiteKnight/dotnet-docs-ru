---
description: 'Дополнительные сведения: обзор архитектуры Передача данных'
title: Общие сведения об архитектуре передачи данных
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
ms.openlocfilehash: 3064797b41e146505062a07dc1786dd492a01298
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99756504"
---
# <a name="data-transfer-architectural-overview"></a>Общие сведения об архитектуре передачи данных

Windows Communication Foundation (WCF) можно рассматривать как инфраструктуру обмена сообщениями. где происходит получение, обработка и направление сообщений в пользовательский код для дальнейших действий или создание сообщений из данных, предоставленных пользовательским кодом, и доставка этих сообщений по назначению. В данном разделе, предназначенном для опытных программистов, описывается архитектура для обработки сообщений и данных, которые в них содержатся. Упрощенное изложение практических аспектов отправки и получения данных приводится в разделе [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).  
  
> [!NOTE]
> В этом разделе обсуждаются сведения о реализации WCF, которые не видны при проверке объектной модели WCF. Прежде чем приступать к описанию задокументированной реализации компонента, необходимо принять во внимание два замечания. Во-первых, все представленные описания упрощены, на практике реализация может быть более сложной из-за оптимизаций или по другим причинам. Во-вторых, никогда не стоит полагаться на определенные сведения о реализации (даже задокументированные), так как они могут изменяться без уведомления от версии к версии или даже в отдельных наборах исправлений.  
  
## <a name="basic-architecture"></a>Базовая архитектура  

 В основе возможностей обработки сообщений WCF лежит <xref:System.ServiceModel.Channels.Message> класс, который подробно описывается в разделе [использование класса Message](using-the-message-class.md). Компоненты среды выполнения WCF можно разделить на две основные части: стек каналов и инфраструктуру службы с <xref:System.ServiceModel.Channels.Message> классом, который является точкой подключения.  
  
 Стек каналов отвечает за преобразование между допустимым экземпляром <xref:System.ServiceModel.Channels.Message> и определенным действием, соответствующим отправке или получению данных сообщения. На отправляющей стороне стек каналов берет допустимый экземпляр <xref:System.ServiceModel.Channels.Message> и после определенной обработки совершает некое действие, логически соответствующее отправке сообщения. Это действие может заключаться в отправке TCP- или HTTP-пакетов, постановке сообщения в очередь сообщений, записи сообщения в базу данных, сохранении его в общей папке или любой другой операции в зависимости от реализации. Наиболее распространенным действием является отправка сообщения по сетевому протоколу. На получающей стороне происходят противоположные процессы: стек каналов обнаруживает действие (например, прибытие TCP- или HTTP-пакетов или любое другое действие), обрабатывает его и преобразует в допустимый экземпляр <xref:System.ServiceModel.Channels.Message> .  
  
 Вы можете использовать WCF с помощью <xref:System.ServiceModel.Channels.Message> класса и стека каналов напрямую. Однако такой подход сложен и может занимать много времени. Кроме того, <xref:System.ServiceModel.Channels.Message> объект не предоставляет поддержку метаданных, поэтому нельзя создавать строго типизированные клиенты WCF, если использовать WCF таким образом.  
  
 Таким образом, WCF включает платформу службы, которая предоставляет простую в использовании модель программирования, которую можно использовать для создания и получения `Message` объектов. Платформа службы сопоставляет службы с платформа .NET Framework типами через представление контрактов служб и отправляет сообщения в операции пользователя, которые просто платформа .NET Framework методы, помеченные <xref:System.ServiceModel.OperationContractAttribute> атрибутом (Дополнительные сведения см. в разделе [Конструирование контрактов служб](../designing-service-contracts.md)). Эти методы могут содержать параметры и возвращать значения. На стороне службы инфраструктура службы преобразует входящие экземпляры <xref:System.ServiceModel.Channels.Message> в параметры, а возвращаемые значения - в исходящие экземпляры <xref:System.ServiceModel.Channels.Message> . На стороне клиента инфраструктура службы выполняет противоположные действия. Например, см. операцию `FindAirfare` ниже.  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 Предположим, операция `FindAirfare` вызывается на стороне клиента. Инфраструктура службы на стороне клиента преобразует параметры `FromCity` и `ToCity` в исходящий экземпляр <xref:System.ServiceModel.Channels.Message> и передает его стеку каналов для отправки.  
  
 Когда экземпляр <xref:System.ServiceModel.Channels.Message> прибывает из стека каналов, на стороне службы инфраструктура службы извлекает из сообщения необходимые для заполнения параметров `FromCity` и `ToCity` данные, а затем вызывает метод `FindAirfare` на стороне службы. Когда метод возвращается, инфраструктура службы создает из возвращенного целочисленного значения и выходного параметра `IsDirectFlight` экземпляр объекта <xref:System.ServiceModel.Channels.Message> , содержащий данную информацию. Затем инфраструктура службы передает экземпляр `Message` стеку каналов для отправки обратно клиенту.  
  
 На стороне клиента из стека каналов появляется экземпляр <xref:System.ServiceModel.Channels.Message> , содержащий ответное сообщение. Инфраструктура службы извлекает возвращаемое значение и значение `IsDirectFlight` и возвращает их вызывающему объекту на стороне клиента.  
  
## <a name="message-class"></a>Класс сообщений  

 Подразумевается, что класс <xref:System.ServiceModel.Channels.Message> является абстрактным представлением сообщения, однако его структура строго связана с сообщением SOAP. Сообщение <xref:System.ServiceModel.Channels.Message> содержит три основных элемента информации: текст сообщения, заголовки сообщения и свойства сообщения.  
  
## <a name="message-body"></a>Текст сообщения  

 В теле сообщения представляется фактическая полезная нагрузка данных сообщения. Текст сообщения всегда представляется как набор сведений XML. Это не означает, что все сообщения, созданные или полученные в WCF, должны быть в формате XML. Стек каналов определяет, как интерпретировать текст сообщения. Он может отобразить текст сообщения в формате XML, преобразовать в другой формат или даже опустить его. Конечно, при использовании большинства привязок WCF текст сообщения представлен в виде XML-содержимого в разделе тела конверта SOAP.  
  
 Следует помнить, что в классе `Message` не обязательно содержится буфер с представляющими текст данными в формате XML. Логически сообщение `Message` содержит набор сведений XML, однако этот набор данных может создаваться динамически и никогда физически не существовать в памяти.  
  
### <a name="putting-data-into-the-message-body"></a>Размещение данных в теле сообщения  

 Не существует универсального механизма размещения данных в теле сообщения. Класс <xref:System.ServiceModel.Channels.Message> имеет абстрактный метод ( <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>), который принимает <xref:System.Xml.XmlDictionaryWriter>. Каждый подкласс класса <xref:System.ServiceModel.Channels.Message> отвечает за переопределение этого метода и запись собственного содержимого. Текст сообщения логически содержит набор сведений XML, создаваемый `OnWriteBodyContent` . Например, рассмотрим следующий подкласс `Message` .  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 Физически экземпляр `AirfareRequestMessage` содержит только две строки ("fromCity" и "toCity"). Однако логически сообщение содержит следующий набор сведений XML:  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 Конечно, обычно сообщения не создаются таким образом, потому что сообщения, подобные предыдущему, создаются с помощью инфраструктуры службы из параметров контракта операций подобно предыдущему. Более того, класс <xref:System.ServiceModel.Channels.Message> содержит статические методы `CreateMessage` , которые могут использоваться для создания сообщений с содержимым стандартных типов: пустое сообщение, сообщение, которое содержит сериализованный в XML с <xref:System.Runtime.Serialization.DataContractSerializer>объект, сообщение, которое содержит ошибку SOAP, сообщение, которое содержит XML, представленный <xref:System.Xml.XmlReader>, и т. д.  
  
### <a name="getting-data-from-a-message-body"></a>Получение данных из тела сообщения  

 Данные, которые хранятся в теле сообщения, можно извлекать двумя основными способами:  
  
- Вы можете получить весь текст сообщения одновременно, вызвав метод <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> и передавая в средство записи XML. Весь текст сообщения записывается в это средство записи. Получение всего тела сообщения одновременно также называется *запись сообщения*. Запись осуществляется в основном стеком каналов при отправке сообщений - как правило, какая-либо часть стека каналов получает доступ к всему телу сообщения, кодирует и отправляет его.  
  
- Еще одним способом извлечения информации из тела сообщения является вызов <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> и получение средства чтения XML. В этом случае доступ к телу сообщения может осуществляться последовательно по мере необходимости посредством вызова методов для средства чтения. Получение тела сообщения по частям также называется *прочтение сообщения*. Прочтение сообщения в основном используется инфраструктурой службы при получении сообщений. Например, при использовании <xref:System.Runtime.Serialization.DataContractSerializer> инфраструктура службы размещает средство чтения XML над текстом сообщения, а затем передает его механизму десериализации, который начинает считывать сообщение по элементам и создавать соответствующий граф объекта.  
  
 Текст сообщения можно извлечь только один раз. Это позволяет работать с потоками только в прямом направлении. Например, вы можете записать переопределение <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> , выполняющее чтение из потока <xref:System.IO.FileStream> и возвращающее результаты в виде набора сведений XML. Вам никогда не придется перематываться в начало файла.  
  
 Методы `WriteBodyContents` и `GetReaderAtBodyContents` просто проверяют, что тело сообщения никогда ранее не извлекалось, а затем вызывают `OnWriteBodyContents` или `OnGetReaderAtBodyContents`соответственно.  
  
## <a name="message-usage-in-wcf"></a>Использование сообщений в WCF  

 Большинство сообщений можно разбить на две группы: *исходящие* (создаваемые инфраструктурой службы для отправки стеком каналов) или *входящие* (прибывающие из стека каналов и интерпретируемые инфраструктурой службы). Более того, стек каналов может работать в режиме буферизации или в режиме потока. Инфраструктура службы также может отображать потоковую или непотоковую модель программирования. В связи с этим необходимо привести следующую таблицу, в которой перечисляются различные варианты использования сообщений, а также сообщаются упрощенные сведения об их реализации.  
  
|тип сообщений;|Данные основного текста в сообщении|Реализация записи (OnWriteBodyContents)|Реализация чтения (OnGetReaderAtBodyContents)|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|Исходящие, созданные из непотоковой модели программирования|Данные, необходимые для записи сообщения (например, объект и экземпляр <xref:System.Runtime.Serialization.DataContractSerializer> , необходимый для его сериализации)*|Пользовательская логика для записи сообщения на основании сохраненных данных (например, вызов метода `WriteObject` сериализатора `DataContractSerializer` , если используется именно этот сериализатор)*|Вызов `OnWriteBodyContents`, буферизация результатов, возврат средства чтения XML над буфером|  
|Исходящие, созданные из потоковой модели программирования|Объект `Stream` с записываемыми данными*|Запись данных из сохраненного потока с помощью механизма <xref:System.Xml.IStreamProvider> *|Вызов `OnWriteBodyContents`, буферизация результатов, возврат средства чтения XML над буфером|  
|Входящие из потокового стека каналов|Объект `Stream` , который представляет поступающие через сеть данные с помощью <xref:System.Xml.XmlReader> над ним|Запись содержимого из сохраненного `XmlReader` с помощью `WriteNode`|Возвращает сохраненное средство чтения `XmlReader`.|  
|Входящие из непотокового стека каналов|Буфер, который содержит данные основного текста и `XmlReader` над ними|Записывает содержимое из сохраненного `XmlReader` с помощью `WriteNode`|Возвращает сохраненный атрибут lang|  
  
 \* Эти элементы не реализуются непосредственно в `Message` подклассах, а в подклассах <xref:System.ServiceModel.Channels.BodyWriter> класса. Дополнительные сведения о веб-службе <xref:System.ServiceModel.Channels.BodyWriter>см. в разделе [Using the Message Class](using-the-message-class.md).  
  
## <a name="message-headers"></a>Заголовки сообщений  

 Сообщение может содержать заголовки. Логически заголовок состоит из набора сведений XML, связанного с именем, пространством имен и несколькими другими свойствами. Доступ к заголовкам сообщения осуществляется с помощью свойства `Headers` сообщения <xref:System.ServiceModel.Channels.Message>. Каждый заголовок представляется классом <xref:System.ServiceModel.Channels.MessageHeader> . Как правило, заголовки сообщения сопоставляются с заголовками сообщения SOAP при использовании стека каналов, настроенного на работу с сообщениями SOAP.  
  
 Размещение данных в заголовке сообщения и извлечение данных из заголовка аналогичны использованию тела сообщения. Процесс несколько упрощается из-за того, что в заголовках не поддерживается потоковая передача. Доступ к содержимому одного и того же заголовка можно осуществлять более одного раза, кроме того, это можно делать в произвольном порядке, каждый раз принудительно вызывая буферизацию заголовков. Для получения средства чтения XML по заголовку нет доступного механизма общего назначения, но существует `MessageHeader` подкласс, внутренний для WCF, который представляет доступный для чтения заголовок с такой возможностью. Этот тип заголовка `MessageHeader` создается стеком каналов, когда приходит сообщение с заголовками пользовательского приложения. Это позволяет инфраструктуре службы использовать для интерпретации этих заголовков механизм десериализации, такой как <xref:System.Runtime.Serialization.DataContractSerializer>.  
  
 Дополнительные сведения см. [в разделе Использование класса Message](using-the-message-class.md).  
  
## <a name="message-properties"></a>Свойства сообщения  

 Сообщение может содержать свойства. *Свойство* — это любой объект платформа .NET Framework, связанный с именем строки. Доступ к свойствам осуществляется через свойство `Properties` сообщения `Message`.  
  
 В отличие от тела и заголовков сообщения (которые обычно сопоставляются с текстом и заголовками сообщения SOAP соответственно) свойства сообщения, как правило, не отправляются и не принимаются вместе с этими сообщениями. Свойства сообщения существуют в основном в качестве механизма связи для передачи данных о сообщении между различными каналами в стеке каналов, а также между стеком каналов и моделью служб.  
  
 Например, канал транспорта HTTP, входящий в состав WCF, может создавать различные коды состояния HTTP, например "404 (не найдено)" и "500 (внутренняя ошибка сервера)", при отправке ответов клиентам. Перед отправкой ответного сообщения он проверяет, содержит ли `Properties` свойство объекта с `Message` именем "httpResponse", которое содержит объект типа <xref:System.ServiceModel.Channels.HttpResponseMessageProperty> . Если это свойство найдено, канал транспорта обращается к свойству <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> и использует указанный код состояния. Если свойство не найдено, используется код по умолчанию - «200 (ОК)».  
  
 Дополнительные сведения см. [в разделе Использование класса Message](using-the-message-class.md).  
  
### <a name="the-message-as-a-whole"></a>Сообщение как единое целое  

 До сих пор мы обсуждали методы доступа к различным частям сообщения по отдельности. Однако класс <xref:System.ServiceModel.Channels.Message> также предоставляет методы для работы с сообщением как единым целым. Например, метод `WriteMessage` записывает все сообщение в средство записи XML.  
  
 Для этого необходимо задать сопоставление между всем экземпляром `Message` и набором сведений XML. Такое сопоставление, фактически, существует: WCF использует стандарт SOAP для определения этого сопоставления. Когда экземпляр `Message` записывается как набор сведений XML, итоговый набор данных является допустимым конвертом SOAP, который содержит соответствующее сообщение. Следовательно, `WriteMessage` , как правило, выполняет следующие шаги:  
  
1. записывает открывающий тег элемента конверта SOAP,  
  
2. записывает открывающий тег элемента заголовка SOAP, записывает все заголовки и закрывает элемент заголовка,  
  
3. записывает открывающий тег элемента тела сообщения SOAP,  
  
4. вызывает `WriteBodyContents` или другой эквивалентный метод для записи тела сообщения,  
  
5. закрывает элементы тела и конверта.  
  
 Описанные выше шаги тесно связаны со стандартом SOAP. Ситуация осложняется наличием нескольких версий SOAP, так как, например, невозможно правильно записать элемент конверта SOAP, не имея точной информации об используемой версии SOAP. В некоторых случаях, кроме того, желательно полностью отключить это сложное сопоставление с протоколом SOAP.  
  
 Для этих целей в сообщении `Version` предусмотрено свойство `Message`. Это свойство можно настроить на указание версии SOAP, которая должна использоваться при записи сообщения, или установить на `None` , чтобы запретить любые сопоставления с протоколом SOAP. Если свойство `Version` установлено на `None`, методы, работающие с целым сообщением, функционируют как если бы сообщение состояло только из тела, например метод `WriteMessage` в этом случае просто вызывает `WriteBodyContents` , а не выполняет описанную выше последовательность действий. Предполагается, что для входящих сообщений `Version` будет определяться автоматически и, следовательно, задаваться верно.  
  
## <a name="the-channel-stack"></a>Стек каналов  
  
### <a name="channels"></a>Каналы  

 Как уже говорилось выше, стек каналов отвечает за преобразование исходящих экземпляров <xref:System.ServiceModel.Channels.Message> в какое-либо действие (например, отправку пакетов по сети) или преобразование какого-либо действия (например, получения сетевых пакетов) во входящие экземпляры `Message` .  
  
 Стек каналов представляет собой один или более каналов, упорядоченных определенным образом. Исходящий экземпляр `Message` передается первому каналу стека (также называемому *верхним каналом*), который передает экземпляр следующему каналу стека (каналу более низкого уровня) и т. д. Завершение сообщения происходит в последнем канале, именуемом *канал транспорта*. Входящие сообщения создаются в канале транспорта и передаются в стеке от каналов более низкого уровня к каналам более высокого уровня. С верхнего канала сообщение, как правило, передается в инфраструктуру службы. Хотя это стандартная процедура обработки сообщений приложения, некоторые каналы могут работать по несколько иной схеме, например они могут отправлять собственные инфраструктурные сообщения, а не передавать сообщения, полученные от каналов более высокого уровня.  
  
 Каналы могут по-разному оперировать сообщениями при прохождении последних через стек. Наиболее распространенной операцией является добавление заголовка к исходящему сообщению и чтение заголовков входящего сообщения. Например, канал может вычислить цифровую подпись в сообщении и добавить ее в качестве заголовка. Канал также может проверить заголовок входящих сообщений, содержащий цифровую подпись, и заблокировать сообщения, которые не имеют действительной подписи (т. е. запретить их передачу по стеку каналов). Каналы часто используются для установки и проверки свойств сообщения. Обычно текст сообщения не изменяется, хотя это разрешено, например, канал безопасности WCF может шифровать текст сообщения.  
  
### <a name="transport-channels-and-message-encoders"></a>Каналы транспорта и кодировщики сообщений  

 Самый нижний канал стека отвечает за фактическое преобразование исходящего сообщения <xref:System.ServiceModel.Channels.Message>, измененного другими каналами, в какое-либо действие. На принимающей стороне этот канал преобразует действие в сообщение `Message` , которое обрабатывается другими каналами.  
  
 Как уже говорилось ранее, действия могут быть самыми разнообразными: например, отправка или получение сетевых пакетов по различным протоколам, чтение или запись сообщений в базу данных, постановка сообщений в очередь сообщений или удаление сообщений из очереди. Все эти действия имеют одно общее: для них требуется преобразование между `Message` экземпляром WCF и реальной группой байтов, которые могут быть отправлены, получены, считаны, записаны, помещены в очередь или выведены из очереди. Процесс преобразования `Message` в группу байтов называется *кодированием*, а обратный процесс создания `Message` из группы байтов - *декодированием*.  
  
 Большинство каналов транспорта для кодирования и декодирования используют компоненты под названием *кодировщики сообщений* . Кодировщик сообщений - это подкласс класса <xref:System.ServiceModel.Channels.MessageEncoder> . `MessageEncoder` включает различные перегрузки метода `ReadMessage` и `WriteMessage` , позволяющие производить преобразование из `Message` в группу байтов и обратно.  
  
 На отправляющей стороне буферизующий канал транспорта передает объект `Message` , полученный от канала более высокого уровня, методу `WriteMessage`. Он возвращает массив байтов, который затем использует для выполнения действия (например, упаковки этих байтов в виде действительных TCP-пакетов и отправки их по назначению). Потоковый канал транспорта сначала создает поток `Stream` (например, через исходящее TCP-соединение), а затем передает поток `Stream` и сообщение `Message` , которые он должен отправить записывающей сообщение перегрузке соответствующего метода `WriteMessage` .  
  
 На получающей стороне буферизующий канал транспорта извлекает входящие байты (например, от входящих TCP-пакетов) в массив и вызывает метод `ReadMessage` , чтобы получить объект `Message` для передачи по стеку каналов. Потоковый канал транспорта создает объект `Stream` (например, сетевой поток по входящему TCP-подключению) и передает его `ReadMessage` , чтобы возвратить объект `Message` .  
  
 Разделение между каналами транспорта и кодировщиком сообщений не является обязательным; можно создать канал транспорта, который не использует кодировщик сообщений. Однако преимуществом подобного разделения является простота построения. Пока канал транспорта использует только основу <xref:System.ServiceModel.Channels.MessageEncoder> , он может работать с любым кодировщиком сообщений WCF или стороннего производителя. Аналогично, один и тот же кодировщик, как правило, можно использовать в любом канале транспорта.  
  
### <a name="message-encoder-operation"></a>Операции кодировщика сообщений  

 Для того чтобы описать стандартные операции, выполняемые кодировщиком сообщений, рекомендуется рассмотреть следующие четыре случая.  
  
|Операция|Комментировать|  
|---------------|-------------|  
|Кодирование (с буферизацией)|В режиме буферизации кодировщик, как правило, создает буфер с переменным размером, а затем создает над ним средство записи XML. После этого кодировщик вызывает метод <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> для кодируемого сообщения, который записывает заголовки и текст сообщения с помощью <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>(см. пояснение в предыдущем подразделе данного раздела, `Message` ). Содержимое буфера (представленное в виде массива байтов) затем возвращается каналу транспорта для дальнейшего использования.|  
|Кодирование (потоковое)|При работе в потоковом режиме операция также выполняется согласно данному выше описанию, при этом ситуация упрощается тем, что нет необходимости использовать буфер. Как правило, средство записи XML создается над потоком, а метод <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> вызывается для сообщения `Message` , чтобы записать его в это средство записи.|  
|Декодирование (с буферизацией)|При декодировании в режиме буферизации, как правило, создается специальный подкласс `Message` , который содержит буферизованные данные. Считываются заголовки сообщения, создается средство чтения XML и устанавливается в теле письма. Это средство чтения, которое будет возвращено с <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.|  
|Декодирование (потоковое)|При декодировании в потоковом режиме, как правило, создается специальный подкласс "Сообщения". Поток перемещается вперед ровно настолько, чтобы прочитать все заголовки и разместить их в теле сообщения. Затем над потоком создается средство чтения XML. Это средство чтения, которое будет возвращено с <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.|  
  
 Кодировщики могут выполнять и другие функции. Например, они могут объединять в пул средства чтения и записи XML. Не рационально создавать новое средство чтения или записи XML всякий раз, когда в них возникает необходимость. Поэтому кодировщики, как правило, поддерживают пул средств чтения и пул средств записи настраиваемого размера. В описании операции кодировщика, описанной выше, каждый раз, когда используется фраза "Создание модуля чтения и записи XML", обычно это означает "взять один из пула или создать его, если он недоступен". Кодировщик (и подклассы `Message` , создаваемые им при декодировании) содержит логику для возвращения средств чтения и записи в пулы, если эти средства более не нужны (например, при закрытии `Message` ).  
  
 WCF предоставляет три кодировщика сообщений, хотя можно создавать дополнительные пользовательские типы. Это текстовое и двоичное кодирование и механизм оптимизации передачи сообщений (MTOM). Эти типы подробно описаны в разделе [Choosing a Message Encoder](choosing-a-message-encoder.md).  
  
### <a name="the-istreamprovider-interface"></a>Интерфейс IStreamProvider  

 При записи исходящего сообщения с потоковым текстом в средство записи XML <xref:System.ServiceModel.Channels.Message> использует в реализации <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> последовательность вызовов, подобную описанной ниже:  
  
- Запись всех необходимых данных, предшествующих потоку (например, открывающий тег XML).  
  
- запись потока;  
  
- Запись данных, следующих за потоком (например, закрывающий тег XML).  
  
 Этот подход хорошо работает с кодировками, подобными текстовой кодировке XML. Однако некоторые кодировки не размещают информацию набора сведений XML (например, теги начальных и конечных XML-элементов) вместе с данными, которые содержатся внутри элементов. Например, при кодировании MTOM сообщение разделяется на несколько частей. Одна часть содержит набор сведений XML, в том числе, возможно, и ссылки на другие части фактического содержимого элемента. Набор сведений XML, как правило, сравнительно мал по сравнению с потоковым содержимым, поэтому имеет смысл его буферизировать, сохранить, а затем записать содержимое потоковым способом. Это означает, что к моменту записи закрывающего тега элемента поток должен быть не сохранен.  
  
 Для этого используется интерфейс <xref:System.Xml.IStreamProvider> . Этот интерфейс содержит метод <xref:System.Xml.IStreamProvider.GetStream> , который возвращает поток, подлежащий записи. Ниже описан правильный способ сохранения потокового тела сообщения в <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> .  
  
1. Запись всех необходимых данных, предшествующих потоку (например, открывающий тег XML).  
  
2. Вызов перегрузки `WriteValue` для <xref:System.Xml.XmlDictionaryWriter> , принимающего <xref:System.Xml.IStreamProvider>, с реализацией `IStreamProvider` , возвращающей подлежащий записи поток.  
  
3. Запись данных, следующих за потоком (например, закрывающий тег XML).  
  
 Используя этот подход, средство записи XML может выбирать, когда вызывать <xref:System.Xml.IStreamProvider.GetStream> и сохранять потоковые данные. Например, средства записи текстовых и двоичных данных XML немедленно вызывают его и записывают потоковое содержимое между открывающим и закрывающим тегами. Средство записи MTOM может вызвать <xref:System.Xml.IStreamProvider.GetStream> позже, когда будет готово к записи соответствующей части сообщения.  
  
## <a name="representing-data-in-the-service-framework"></a>Представление данных в инфраструктуре службы  

 Как указано в разделе "Базовая архитектура" этого раздела, платформа службы является частью WCF, которая, помимо прочего, отвечает за преобразование между удобной для пользователя моделью программирования для данных сообщений и фактических `Message` экземпляров. Как правило, Обмен сообщениями представлен в Service Framework как метод платформа .NET Framework, помеченный <xref:System.ServiceModel.OperationContractAttribute> атрибутом. Метод может брать несколько параметров и возвращать возвращаемое значение или выходные параметры (или и то, и другое). На стороне службы входные параметры представляют входящее сообщение, а возвращаемое значение и выходные параметры - исходящее сообщение. На стороне клиента происходит обратное представление. Подробные сведения о модели программирования для описания сообщений с помощью параметров и возвращаемого значения см. в разделе [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md). А в этом разделе приводится краткий обзор моделей.  
  
## <a name="programming-models"></a>Модели программирования  

 Платформа WCF Service Framework поддерживает пять различных моделей программирования для описания сообщений:  
  
### <a name="1-the-empty-message"></a>1. Пустое сообщение  

 Это простейший случай. Для описания пустого входящего сообщения не нужно использовать какие-либо входные параметры.  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 Для описания пустого исходящего сообщения нужно использовать возвращаемое значение типа void, выходные параметры при этом не используются.  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 Обратите внимание, что это описание отличается от контракта односторонних операций.  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 В примере `SetDesiredTemperature` описывается шаблон двустороннего обмена сообщениями. Сообщение возвращается от операции, но при этом оно пустое. От операции также можно возвратить ошибку. В примере "Set Lightbulb" описывается шаблон одностороннего обмена сообщениями, поэтому не требуется описание исходящего сообщения. В этом случае служба не может передать обратно клиенту какое-либо состояние.  
  
### <a name="2-using-the-message-class-directly"></a>2. Использование класса сообщений напрямую  

 Класс <xref:System.ServiceModel.Channels.Message> (или один из его подклассов) можно использовать напрямую в контракте операций. В этом случае инфраструктура службы только передает сообщение `Message` от операции стеку каналов и обратно без какой-либо дальнейшей обработки.  
  
 Существует два основных варианта непосредственного использования `Message` . Его можно использовать в продвинутых сценариях, если ни одна из других моделей программирования не является достаточно гибкой для описания данного сообщения. Например, для описания сообщения можно использовать файлы на диске, тогда свойства файла становятся заголовками сообщения, а его содержимое - текстом сообщения. В этом случае можно создать что-нибудь подобное описанному ниже.  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 Второй распространенный вариант использования `Message` в контракте операций применяется в случае, когда для службы не имеет значения содержимое конкретного сообщения, и служба рассматривает сообщение в качестве "черного ящика". Например, имеется служба, которая пересылает сообщения нескольким другим получателям. В этом случае контракт можно записать следующим образом.  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 Строка Action = "*" эффективно отключает диспетчеризации сообщений и гарантирует, что все сообщения, отправленные `IForwardingService` контракту, будут выполнять `ForwardMessage` операции. (Обычно диспетчер проверяет заголовок "Action" сообщения, чтобы определить, для какой операции он предназначен. Action = " \* " означает "все возможные значения заголовка действия".) Сочетание Action = " \* " и использование сообщения в качестве параметра называются "универсальным контрактом", так как он может получать все возможные сообщения. Чтобы иметь возможность отправить все возможные сообщения, используйте Message в качестве возвращаемого значения и задайте `ReplyAction` для значение " \* ". В этом случае инфраструктура службы не сможет добавить свой собственный заголовок действия, и вы сможете управлять этим заголовком с помощью возвращаемого вами объекта `Message` .  
  
### <a name="3-message-contracts"></a>3. Контракты сообщений  

 WCF предоставляет декларативную модель программирования для описания сообщений, называемых *контрактами сообщений*. Эта модель более подробно описана в разделе [Using Message Contracts](using-message-contracts.md). По сути, все сообщение представлено одним типом платформа .NET Framework, который использует атрибуты, такие как <xref:System.ServiceModel.MessageBodyMemberAttribute> и, <xref:System.ServiceModel.MessageHeaderAttribute> для описания того, какие части класса контракта сообщения должны сопоставляться с частью сообщения.  
  
 Контракты сообщений обеспечивают значительную степень управления над получаемыми экземплярами `Message` (хотя в данном случае степень управления все равно ниже, чем при непосредственном использовании класса `Message` ). Например, тела сообщений часто состоят из многочисленных элементов данных, каждый из которых представлен собственным XML-элементом. Эти элементы могут встречаться непосредственно в теле сообщения (режим *bare* ) или помещаться в *программу-оболочку* содержащегося в теле XML-элемента. Использование модели программирования контракта сообщений позволяет выбирать способ представления элементов (в режиме "bare" или в программе-оболочке) и управлять именем программы-оболочки и пространством имен.  
  
 В следующем примере кода контракта сообщений проиллюстрированы эти возможности.  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 Элементы, отмеченные для сериализации (с атрибутами <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>или любыми другими связанными атрибутами), должны быть сериализуемыми, иначе они не могут находиться в контракте сообщения. Дополнительные сведения см. в подразделе "сериализация" Далее в этом разделе.  
  
### <a name="4-parameters"></a>4. Параметры  

 Часто для описания операции с несколькими элементами данных разработчику не требуется тот высокий уровень управления, который обеспечивается контрактами сообщений. Например, при создании новых служб, как правило, не приходится принимать решение о способе представления элементов (в режиме "bare" или в программе-оболочке) и выбирать имя программы-оболочки. Зачастую для принятия таких решений необходимы глубокие знания о функционировании веб-служб и протокола SOAP.  
  
 WCF Service Framework может автоматически выбрать лучшее и наиболее взаимодействующее представление SOAP для отправки или получения нескольких связанных частей информации, не вызывая эти параметры для пользователя. Это возможно благодаря тому, что данные элементы данных описаны как параметры или возвращаемые значения контракта операций. Например, рассмотрим следующий контракт операций.  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 Инфраструктура службы автоматически принимает решение о размещении всех трех элементов данных (`customerID`, `item`и `quantity`) в теле сообщения и помещении их в программу-оболочку с именем `SubmitOrderRequest`.  
  
 Рекомендуется описывать информацию, которую необходимо отправить или получить, в виде простого списка параметров контракта операций, если, конечно, не имеется особых причин, вынуждающих перейти к использованию более сложного контракта сообщений или моделей программирования на основе `Message`.  
  
### <a name="5-stream"></a>5. Поток  

 Использование потока `Stream` или одного из его подклассов в контракте операций либо в качестве единственной части тела сообщения в контракте сообщений может считаться отдельной моделью программирования, которая отличается от описанных выше моделей. Только использование `Stream` подобным образом гарантирует возможность использования контракта в потоковом режиме; во всех остальных случаях необходимо самостоятельно создавать подкласс `Message` , совместимый с потоковым режимом. Дополнительные сведения см. в разделе [большие данные и потоковая передача](large-data-and-streaming.md).  
  
 При использовании `Stream` или одного из его подклассов таким образом сериализатор не вызывается. Для исходящих сообщений создается специальный потоковый подкласс `Message` , а поток записывается в интерфейсе <xref:System.Xml.IStreamProvider> описанным в данном разделе способом. Для входящих сообщений инфраструктура службы создает подкласс `Stream` над входящими сообщениями и предоставляет этот подкласс операции.  
  
## <a name="programming-model-restrictions"></a>Ограничения модели программирования  

 Вышеописанные модели программирования нельзя сочетать произвольно. Например, если операция принимает определенный тип контракта сообщений, этот контракт сообщений должен стать единственным входным параметром операции. Более того, после этого операция должна вернуть либо пустое сообщение (возвращаемый тип "void"), либо другой контракт сообщений. Ограничения моделей программирования описаны в разделах, посвященных каждой из этих моделей: [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md)и [Large Data and Streaming](large-data-and-streaming.md).  
  
## <a name="message-formatters"></a>Модули форматирования сообщений  

 Описанные выше модели программирования поддерживаются подключением компонентов под названием *модули форматирования сообщений* в инфраструктуру службы. Модули форматирования сообщений — это типы, которые реализуют интерфейс или и то, и <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> другое, для использования в клиентах и клиентах WCF служб соответственно.  
  
 Как правило, модули форматирования сообщений подключаются поведениями. Например, поведение <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> подключает модуль форматирования сообщений контракта данных. На стороне службы это достигается благодаря установке <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> на соответствующий модуль форматирования в методе <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> , а на стороне клиента - благодаря установке <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> на соответствующий модуль форматирования в методе <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> .  
  
 В таблице ниже приведены методы, которые могут реализовываться модулем форматирования сообщений.  
  
|Интерфейс|Метод|Действие|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|преобразует входящее сообщение `Message` в параметры операции|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|создает исходящее сообщение `Message` из возвращаемого значения/выходных параметров операции|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|создает исходящее сообщение `Message` из параметров операции|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|преобразует входящее сообщение `Message` в возвращаемое значение/выходные параметры|  
  
## <a name="serialization"></a>Сериализация  

 При использовании контрактов сообщений или параметров для описания содержимого сообщения необходимо использовать сериализацию для преобразования между типами платформа .NET Framework и представлением информационного набора XML. Сериализация используется в других местах в WCF, например, <xref:System.ServiceModel.Channels.Message> имеет универсальный <xref:System.ServiceModel.Channels.Message.GetBody%2A> метод, который можно использовать для чтения всего текста сообщения, десериализованного в объект.  
  
 WCF поддерживает две технологии сериализации из Box для сериализации и десериализации параметров и частей сообщений: <xref:System.Runtime.Serialization.DataContractSerializer> и `XmlSerializer` . Более того, можно создать настраиваемые сериализаторы. Однако другие части WCF (например, универсальный `GetBody` метод или сериализация ошибок SOAP) могут быть ограничены только использованием <xref:System.Runtime.Serialization.XmlObjectSerializer> подклассов ( <xref:System.Runtime.Serialization.DataContractSerializer> и <xref:System.Runtime.Serialization.NetDataContractSerializer> , но не <xref:System.Xml.Serialization.XmlSerializer> ) или даже могут быть жестко запрограммированы для использования только <xref:System.Runtime.Serialization.DataContractSerializer> .  
  
 `XmlSerializer`— Это механизм сериализации, используемый в веб-службах ASP.NET. Новый модуль сериализации `DataContractSerializer` , совместимый с новой моделью программирования на основе контрактов данных. `DataContractSerializer` выбирается по умолчанию, однако можно выбрать `XmlSerializer` для отдельных операций с помощью атрибута <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> .  
  
 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> и <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> - это поведения операции, ответственные за подключение модулей форматирования сообщений для `DataContractSerializer` и `XmlSerializer`соответственно. Фактически, поведение <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> может работать с любым сериализатором, наследуемым от <xref:System.Runtime.Serialization.XmlObjectSerializer>, включая <xref:System.Runtime.Serialization.NetDataContractSerializer> (подробное описание см. в разделе "Использование автономной сериализации"). Поведение вызывает одну из перегрузок виртуального метода `CreateSerializer` для получения сериализатора. Для подключения иного сериализатора необходимо создать новый подкласс <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> и переопределить обе перегрузки метода `CreateSerializer` .  
  
## <a name="see-also"></a>См. также

- [Задание передачи данных в контрактах служб](specifying-data-transfer-in-service-contracts.md)
