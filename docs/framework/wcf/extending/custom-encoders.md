---
description: 'Дополнительные сведения: пользовательские кодировщики'
title: Пользовательские кодировщики
ms.date: 03/30/2017
ms.assetid: fa0e1d7f-af36-4bf4-aac9-cd4eab95bc4f
ms.openlocfilehash: 12c706daf025b6ab63bd5c4e2cbb426a2ea83af1
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99735300"
---
# <a name="custom-encoders"></a>Пользовательские кодировщики

В данном разделе рассматривается процесс создания пользовательских кодировщиков.  
  
 В Windows Communication Foundation (WCF) используется *Привязка* для указания способа перемещения данных по сети между конечными точками. Привязка состоит из последовательности *элементов привязки*. Привязка включает необязательные элементы привязки протокола, такие как безопасность, обязательный элемент привязки *кодировщика сообщений* и обязательный элемент привязки транспорта. Кодировщик сообщений представлен элементом привязки кодирования сообщений. В WCF включены три кодировщика сообщений: двоичный, механизм оптимизации передачи сообщений (MTOM) и текст.  
  
 Элемент привязки кодирования сообщений сериализует исходящее сообщение <xref:System.ServiceModel.Channels.Message> и передает его транспорту или получает сериализованную форму сообщения от транспорта и передает ее на уровень протоколов, если он имеется, или в приложение, если он отсутствует.  
  
 Кодировщики сообщений преобразовывают экземпляры <xref:System.ServiceModel.Channels.Message> в представление для передачи и наоборот. Хотя в описании кодировщиков указано, что они находятся над транспортным уровнем в стеке каналов, они располагаются на транспортном уровне. Транспорты (например, HTTP) форматируют сообщение в соответствии с требованиями стандарта транспортов. Кодировщики (например, Text Xml) только кодируют сообщение.  
  
 При подключении к ранее существующему клиенту или серверу не всегда имеется возможность выбрать определенное кодирование сообщений. Однако службы WCF можно сделать доступными через несколько конечных точек, каждый из которых имеет другой кодировщик сообщений. Если один кодировщик не охватывает всю аудиторию для службы, следует рассмотреть возможность представления службы через несколько конечных точек. Это позволит клиентским приложениям выбрать наиболее подходящую конечную точку. Использование нескольких конечных точек позволяет сочетать преимущества разных кодировщиков сообщений с другими элементами привязки.  
  
## <a name="system-provided-encoders"></a>Кодировщики, предоставляемые системой  

 WCF предоставляет несколько предоставляемых системой привязок, предназначенных для самых распространенных сценариев приложений. Каждая из этих привязок содержит транспорт, кодировщик сообщений и другие параметры (например, безопасность). В этом разделе описывается расширение `Text` `Binary` `MTOM` кодировщиков сообщений, и, входящих в WCF, или создание собственного пользовательского кодировщика. Кодировщик текстовых сообщений поддерживает как кодирование на простом языке XML, так и кодирование SOAP. Режим кодирования на простом языке XML кодировщика текстовых сообщений называется кодировщиком POX ("plain old XML"), что позволяет отличить его от текстового кодирования SOAP.  
  
 Дополнительные сведения о сочетаниях элементов привязки, предоставляемых привязками, предоставляемыми системой, см. в соответствующем разделе раздела [Выбор транспорта](../feature-details/choosing-a-transport.md).  
  
## <a name="how-to-work-with-system-provided-encoders"></a>Принцип работы с кодировщиками, предоставляемыми системой  

 Кодирование добавляется в привязку с помощью класса, унаследованного от класса <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.  
  
 WCF предоставляет следующие типы элементов привязки, производных от <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> класса, которые могут предоставлять кодировку Text, binary и механизму оптимизации передачи сообщений (MTOM):  
  
- <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>. Кодировщик для сообщений XML с наиболее широкими возможностями взаимодействия, но при этом наименее неэффективный. Веб-служба или клиент веб-службы в общем могут понимать XML в текстовом виде. Однако передача больших блоков двоичных данных в виде текста неэффективна.  
  
- <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>. Представляет собой элемент привязки, указывающий кодирование символов и управление версиями сообщений для сообщений XML в двоичном формате. Это наиболее эффективный способ настройки кодировки, но наименее совместимый, так как он поддерживается только конечными точками WCF.  
  
- <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>. Представляет собой элемент привязки, указывающий кодирование символов и управление версиями сообщений для сообщений, для которых применяется подсистема оптимизации передачи сообщений MTOM. MTOM - это эффективный способ передачи двоичных данных в сообщениях WCF. Кодировщик MTOM пытается обеспечить баланс между эффективностью и взаимодействием. Кодирование MTOM передает большую часть XML-данных в текстовой форме, но оптимизирует большие блоки двоичных данных путем передачи их в исходном виде, без преобразования в текст.  
  
 Элемент привязки создает двоичную, MTOM или текстовую фабрику <xref:System.ServiceModel.Channels.MessageEncoderFactory>. Фабрика создает двоичный, MTOM или текстовый экземпляр <xref:System.ServiceModel.Channels.MessageEncoderFactory>. Обычно существует только один экземпляр. Однако при использовании сеансов для каждого сеанса могут предоставляться разные кодировщики. Двоичный кодировщик использует это для координации динамических словарей (см. раздел "Инфраструктура XML").  
  
 Методы <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> и <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> являются основой кодировщиков. Методы обеспечивают чтение сообщения из потока или формируют массив <xref:System.Byte>. Байтовые массивы используются, когда транспорт работает в режиме буферизации. Сообщения всегда записываются в потоки. Если транспорт должен поместить сообщение в буфер, он предоставляет поток, который выполняет буферизацию.  
  
 Остальные члены работают с дополнительным содержимым, типами носителей и <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>. Транспорт вызывает эти методы кодировщика, чтобы проверить, можно ли с их помощью декодировать входящее сообщение, или чтобы определить, является ли исходящее сообщение действительным для этого кодировщика.  
  
 Каждая из трех реализаций кодировщика добавляет свойства, относящиеся к определенному кодированию, и является полностью настраиваемой. Кодировщики также предоставляют квоты средства чтения, которые имеют защищенные параметры по умолчанию. Обсуждение квот см. в разделе "Инфраструктура XML".  
  
## <a name="features-of-system-provided-encoders"></a>Возможности кодировщиков, предоставляемых системой  

 Кодировщики, предоставляемые системой, имеют несколько возможностей.  
  
### <a name="pooling"></a>Pooling  

 В каждой реализации выполняется попытка объединения в пул, насколько это возможно. Снижение выделения памяти- это основной способ улучшения производительности управляемого кода. Для облегчения объединения в пул в реализациях используется класс `SynchronizedPool`. Файл C# содержит описание дополнительных оптимизаций, используемых в этом классе.  
  
 Экземпляры <xref:System.Xml.XmlDictionaryReader> и <xref:System.Xml.XmlDictionaryWriter> объединяются в пул и повторно инициализируются, чтобы предотвратить выделение памяти для новых экземпляров для каждого сообщения. В случае средств чтения, обратный вызов `OnClose` закрывает средство чтения при вызове метода `Close()`. Кодировщик также повторно использует некоторые объекты состояния сообщений, используемые при создании сообщений. Размер пулов настраивается с помощью свойств `MaxReadPoolSize` и `MaxWritePoolSize` для каждого из трех классов, унаследованных от класса <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.  
  
### <a name="binary-encoding"></a>Двоичное кодирование  

 Если при двоичном кодировании используются сеансы, получатель сообщения должен иметь возможность взаимодействия со строкой динамического словаря. Это осуществляется путем задания префикса сообщению со строками динамического словаря. Получатель отсекает строки, добавляет их в сеанс и обрабатывает сообщение. Для правильной передачи строк словаря необходимо, чтобы транспорт был помещен в буфер.  
  
 Строки добавляются в сообщение с помощью внутреннего метода `AddSessionInformationToMessage`. Он добавляет строки в виде UTF-8 вначале сообщения с префиксом их длины. Затем во весь заголовок словаря добавляет префикс длины данных. Обратная операция выполняется внутренним методом `ExtractSessionInformationFromMessage`.  
  
 Помимо обработки ключей динамического словаря, буферизированные сообщения, связанные с сеансом, принимаются уникальным способом. Вместо создания средства чтения над документом и его обработки в двоичном кодировании используется внутренний класс `MessagePatterns` для разбора двоичного потока. Идея состоит в том, что большинство сообщений имеют определенный набор заголовков, которые отображаются в определенном порядке при создании WCF. Система шаблонов разделяет сообщение на части на основании ожиданий. В случае успешного выполнения она инициализирует объект <xref:System.ServiceModel.Channels.MessageHeaders> без анализа XML. В противном случае она возвращается к стандартному методу.  
  
### <a name="mtom-encoding"></a>Кодирование MTOM  

 Класс <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> имеет дополнительное свойство конфигурации <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement.MaxBufferSize%2A>. Оно задает верхнюю границу объема данных, который можно помещать в буфер во время чтения сообщения. Может возникнуть необходимость в буферизации XML Information Set (Infoset) или других частей MIME, чтобы повторно собрать все части MIME в одно сообщение.  
  
 Для правильной работы с HTTP внутренний класс кодировщика сообщений MTOM предоставляет несколько интерфейсов API для метода `GetContentType` (который также является внутренним) и метода `WriteMessage`, который является открытым и может быть переопределен. Чтобы значения в заголовках HTTP соответствовали значениям в заголовках MIME, необходимо обеспечить более широкие возможности взаимодействия.  
  
 На внутреннем уровне кодировщик сообщений MTOM использует средства чтения текста WCF и аналогичен кодировщику текста. Основное отличие заключается в том, что он оптимизирует большой объем двоичных данных или большие двоичные объекты, не преобразовывая их в кодировку Base-64 до внедрения в байты сообщения. Вместо этого эти объекты остаются извлеченными, и на них существуют ссылки как на вложения MIME.  
  
## <a name="writing-your-own-encoder"></a>Запись собственного кодировщика  

 Чтобы реализовать собственный пользовательский кодировщик сообщений, предоставьте пользовательские реализации следующих абстрактных базовых классов.  
  
- <xref:System.ServiceModel.Channels.MessageEncoder>  
  
- <xref:System.ServiceModel.Channels.MessageEncoderFactory>  
  
- <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  
  
 Преобразование из хранимого в памяти представления сообщения в представление, которое можно записать в поток, инкапсулировано внутри класса <xref:System.ServiceModel.Channels.MessageEncoder>, который используется в качестве фабрики для средств чтения XML и средств записи XML, поддерживающих определенные типы кодирования XML.  
  
- Ниже представлены основные методы этого класса, которые необходимо переопределить.  
  
- <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A>, который принимает объект <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> и записывает его в объект <xref:System.IO.Stream>.  
  
- <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A>, который принимает объект <xref:System.IO.Stream> и максимальный размер заголовка и возвращает объект <xref:System.ServiceModel.Channels.Message>.  
  
 Код, записываемый в этих методах, выполняет преобразование между стандартным транспортным протоколом и настроенным кодированием.  
  
 Затем следует записать в код класс фабрики, создающий пользовательский кодировщик. Переопределите свойство <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A>, чтобы обеспечить возврат экземпляра пользовательского кодировщика <xref:System.ServiceModel.Channels.MessageEncoder>.  
  
 Затем подключите пользовательскую фабрику <xref:System.ServiceModel.Channels.MessageEncoderFactory> к стеку элементов привязки, используемому для настройки службы или клиента, переопределив метод <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A>, чтобы вернуть экземпляр этой фабрики.  
  
 В WCF предусмотрены два примера, иллюстрирующие этот процесс с помощью примера кода: [пользовательский кодировщик сообщений: пользовательский кодировщик текста](../samples/custom-message-encoder-custom-text-encoder.md) и [пользовательский кодировщик сообщений: кодировщик сжатия](../samples/custom-message-encoder-compression-encoder.md).  
  
## <a name="see-also"></a>См. также

- <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>
- <xref:System.ServiceModel.Channels.MessageEncoderFactory>
- <xref:System.ServiceModel.Channels.MessageEncoder>
- [Общие сведения об архитектуре передачи данных](../feature-details/data-transfer-architectural-overview.md)
- [Выбор кодировщика сообщений](../feature-details/choosing-a-message-encoder.md)
- [Выбор транспортов](../feature-details/choosing-a-transport.md)
