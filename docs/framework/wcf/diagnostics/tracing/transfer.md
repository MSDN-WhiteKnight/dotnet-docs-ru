---
description: Дополнительные сведения о переносе
title: Перенос
ms.date: 03/30/2017
ms.assetid: dfcfa36c-d3bb-44b4-aa15-1c922c6f73e6
ms.openlocfilehash: ce88a71d87c7dd09f321ee58f603f7c4672a6df9
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99758064"
---
# <a name="transfer"></a>Перенос

В этом разделе описывается перемещение в модели трассировки действий Windows Communication Foundation (WCF).  
  
## <a name="transfer-definition"></a>Определение перенаправления  

 Перенаправления между действиями передают причинно-следственную связь между событиями в связанных действиях внутри конечных точек. Два действия связываются перенаправлениями при потоке управления от одного из этих действий к другому, например когда вызов метода пересекает границы действия. В WCF, когда в службе поступают байты, действие Listen on передается в действие Receive Bytes, где создается объект Message. Список комплексных сценариев трассировки и их соответствующих действий и структуры трассировки см. в разделе [Сценарии сквозной трассировки](end-to-end-tracing-scenarios.md).  
  
 Для выдачи трассировки перенаправлений задайте параметр `ActivityTracing` в источнике трассировки, как показано в предыдущем примере кода.  
  
```xml  
<source name="System.ServiceModel" switchValue="Verbose,ActivityTracing">  
```  
  
## <a name="using-transfer-to-correlate-activities-within-endpoints"></a>Использование перенаправления для корреляции действий внутри конечных точек  

 Действия и перенаправления позволяют пользователю с определенной вероятностью найти первопричину ошибки. Например, если при перенаправлении от действия M на действие N и обратно (в компонентах M и N соответственно) сразу же после перенаправления обратно на M происходит сбой, можно сделать вывод, что это скорее всего связано с передачей действием N данных обратно действию M.  
  
 Трассировка перенаправления выдается от действия M на действие N при передаче управления от M к N. Например, N выполняет некоторую обработку для M в связи с тем, что вызов метода пересекает границы действий. Действие N может уже существовать или быть создано. Действие N порождается действием M, когда N представляет собой новое действие, выполняющее некоторую обработку для M.  
  
 За перенаправлением от M на N не обязательно следует перенаправление обратно от N на M. Это связано с тем, что M может породить некоторую обработку в N и не следит за тем, когда N завершит эту обработку. Фактически действие M может быть прекращено до того, как N завершит свою задачу. Это происходит в действии Open ServiceHost (M), которое порождает действия прослушивателя (N) и затем завершается. Перенаправление обратно от N на M означает, что действие N завершило обработку, относящуюся к действию M.  
  
 Действие N может продолжать выполнять другую обработку, не относящуюся к действию M, например существующее действие структуры проверки подлинности (N) продолжит получать запросы на вход (M) от других действий входа.  
  
 Между действиями M и N необязательно должно существовать отношение вложенности. Это может произойти по двум причинам. Первая — когда действие M не осуществляет мониторинг обработки, выполняемой действием N, даже хотя действие M инициировало действие N. Вторая — когда действия N уже существует.  
  
## <a name="example-of-transfers"></a>Пример перенаправления  

 Ниже приведено два примера перенаправления.  
  
- При создании узла службы конструктор получает управление от вызывающего кода, или вызывающий код выполняет перенаправление на конструктор. По завершении выполнения конструктор возвращает управление вызывающему коду, или конструктор выполняет перенаправление обратно на вызывающий код. Это случай отношения вложенности.  
  
- Когда прослушиватель начинает обрабатывать данные транспорта, он создает новый поток и передает действию Receive Bytes соответствующий контекст для обработки, т. е. передает управление и данные. По завершении обработки запроса этим потоком действие Receive Bytes ничего не передает обратно прослушивателю. В этом случае имеет место перенаправление на новое действие потока, однако перенаправления от действия потока не происходит. Два действия связаны, но не являются вложенными.  
  
## <a name="activity-transfer-sequence"></a>Последовательность перенаправления между действиями  

 Корректная последовательность перенаправления между действиями включает следующие шаги.  
  
1. Начало нового действия (заключается в выборе нового идентификатора gAId).  
  
2. Выдача трассировки перенаправления на этот новый идентификатор gAId от текущего идентификатора действия.  
  
3. Задание нового идентификатора в локальной памяти потока.  
  
4. Выдача трассировки Start, обозначающей начало нового действия.  
  
5. Возврат к исходному действию заключается в следующем:  
  
6. выдача трассировки перенаправления к исходному идентификатору gAId;  
  
7. выдача трассировки Stop, обозначающей конец нового действия;  
  
8. присвоение локальной памяти потока старого идентификатора gAId.  
  
 В следующем примере кода показано, как это сделать. В этом примере предполагается, что при перенаправлении на новое действие совершается блокирующий вызов, и приводятся трассировки приостановки/возобновления.  
  
```csharp
// 0. Create a trace source  
TraceSource ts = new TraceSource("myTS");  

// 1. remember existing ("ambient") activity for clean up  
Guid oldGuid = Trace.CorrelationManager.ActivityId;  
// this will be our new activity  
Guid newGuid = Guid.NewGuid();

// 2. call transfer, indicating that we are switching to the new AID  
ts.TraceTransfer(667, "Transferring.", newGuid);  

// 3. Suspend the current activity.  
ts.TraceEvent(TraceEventType.Suspend, 667, "Suspend: Activity " + i-1);  

// 4. set the new AID in TLS  
Trace.CorrelationManager.ActivityId = newGuid;  

// 5. Emit the start trace  
ts.TraceEvent(TraceEventType.Start, 667, "Boundary: Activity " + i);  

// trace something  
ts.TraceEvent(TraceEventType.Information, 667, "Hello from activity " + i);  

// Perform Work  
// some work.  
// Return  
ts.TraceEvent(TraceEventType.Information, 667, "Work complete on activity " + i);

// 6. Emit the transfer returning to the original activity  
ts.TraceTransfer(667, "Transferring Back.", oldGuid);  

// 7. Emit the End trace  
ts.TraceEvent(TraceEventType.Stop, 667, "Boundary: Activity " + i);  

// 8. Change the tls variable to the original AID  
Trace.CorrelationManager.ActivityId = oldGuid;

// 9. Resume the old activity  
ts.TraceEvent(TraceEventType.Resume, 667, "Resume: Activity " + i-1);  
```  
  
## <a name="see-also"></a>См. также

- [Настройка трассировки](configuring-tracing.md)
- [Использование программы Service Trace Viewer для просмотра скоррелированных трассировок и устранения неполадок](using-service-trace-viewer-for-viewing-correlated-traces-and-troubleshooting.md)
- [Сценарии сквозной трассировки](end-to-end-tracing-scenarios.md)
- [Программа Service Trace Viewer (SvcTraceViewer.exe)](../../service-trace-viewer-tool-svctraceviewer-exe.md)
