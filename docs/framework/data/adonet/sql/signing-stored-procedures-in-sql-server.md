---
description: 'Дополнительные сведения: Подписывание хранимых процедур в SQL Server'
title: Подписывание хранимых процедур в SQL Server
ms.date: 01/05/2018
ms.assetid: eeed752c-0084-48e5-9dca-381353007a0d
ms.openlocfilehash: 1189f3ac24c8499cd8fb3ff9e6b6263a71fcc3a0
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99767509"
---
# <a name="signing-stored-procedures-in-sql-server"></a>Подписывание хранимых процедур в SQL Server

Цифровая сигнатура представляет собой хэш-код данных, зашифрованную при помощи закрытого ключа лица, ставящего свою сигнатуру. Закрытый ключ обеспечивает уникальность цифровой сигнатуры его владельцу. Можно подписывать хранимые процедуры, функции (за исключением встроенных функций, возвращающих табличное значение), триггеров и сборок.

Хранимую процедуру можно подписать сертификатом или асимметричным ключом. Эта возможность предназначена для сценариев, в которых разрешения не могут наследоваться по цепочке владения или если цепочка владения разорвана, например в динамическом SQL. Затем можно создать пользователя, сопоставленного с сертификатом, предоставив ему разрешения пользователя на доступ к объектам, к которым должна обращаться хранимая процедура.

Можно также создать имя входа, сопоставленное с тем же сертификатом, а затем предоставить этому имени входа необходимые разрешения уровня сервера или добавить имя входа в одну или несколько предопределенных ролей сервера. Это предназначено для того, чтобы не включать `TRUSTWORTHY` параметр базы данных для сценариев, в которых требуются разрешения более высокого уровня.

При выполнении хранимой процедуры SQL Server объединяет разрешения пользователя сертификата и (или) имя входа в систему вызывающей стороны. В отличие от `EXECUTE AS` предложения, он не изменяет контекст выполнения процедуры. Встроенные функции, которые возвращают имя входа и имена пользователей, возвращают имя вызывающей стороны, а не имя пользователя сертификата.

## <a name="creating-certificates"></a>Создание сертификатов

При подписывании хранимой процедуры с помощью сертификата или асимметричного ключа дайджест данных, состоящий из зашифрованного хэш-кода хранимой процедуры, а также пользователя, выполняющего функции, создается с помощью закрытого ключа. Во время выполнения сводка данных расшифровывается открытым ключом и сравнивается с хэш-кодом хранимой процедуры. Изменение пользователя, выполняющего проверку подлинности, делает недействительным хэш-значение, чтобы цифровая подпись больше не совпадала. Изменение хранимой процедуры полностью приводит к полному сбросу сигнатуры, что не позволяет пользователю, у которого нет доступа к закрытому ключу, изменять код хранимой процедуры. В любом случае необходимо повторно подписать процедуру каждый раз при изменении кода или при выполнении пользователем.

При подписывании модуля необходимо выполнить два шага:

1. Создание сертификата с использованием инструкции Transact-SQL `CREATE CERTIFICATE [certificateName]`. Эта инструкция имеет несколько параметров для настройки даты начала и даты окончания, а также пароля. Дата окончания срока действия по умолчанию — один год.

1. Подписание процедуры при помощи сертификата с использованием инструкции Transact-SQL `ADD SIGNATURE TO [procedureName] BY CERTIFICATE [certificateName]`.

После подписания модуля необходимо создать один или несколько участников для хранения дополнительных разрешений, которые должны быть связаны с сертификатом.

Если модулю требуются дополнительные разрешения уровня базы данных:

1. Создание пользователя базы данных, связанного с этим сертификатом, с использованием инструкции Transact-SQL `CREATE USER [userName] FROM CERTIFICATE [certificateName]`. Этот пользователь существует только в базе данных и не связан с именем входа, если только имя входа не было создано из этого же сертификата.

1. Предоставьте пользователю сертификата необходимые разрешения уровня базы данных.

Если модулю требуются дополнительные разрешения уровня сервера:

1. Скопируйте сертификат в `master` базу данных.

1. Создайте имя входа, связанное с этим сертификатом, с помощью инструкции Transact-SQL `CREATE LOGIN [userName] FROM CERTIFICATE [certificateName]` .

1. Предоставьте сертификату имя входа необходимые разрешения уровня сервера.

> [!NOTE]
> Сертификат не может предоставлять разрешения пользователю, у которого разрешения были отменены инструкцией DENY. DENY имеет преимущество над GRANT, предотвращая тем самым наследование вызывающей стороной разрешений, предоставленных пользователю сертификата.

## <a name="external-resources"></a>Внешние ресурсы

Для получения дополнительных сведений см. следующие ресурсы.

|Ресурс|Описание|
|--------------|-----------------|
|[Подписывание модулей](/previous-versions/sql/sql-server-2008/ms345102(v=sql.100))|Описывает Подписывание модулей, предоставляя пример сценария и ссылки на соответствующие статьи Transact-SQL.|
|[Подписывание хранимых процедур с помощью сертификата](/sql/relational-databases/tutorial-signing-stored-procedures-with-a-certificate)|Предоставляет учебник для подписания хранимой процедуры с помощью сертификата.|

## <a name="see-also"></a>См. также

- [Защита приложений ADO.NET](../securing-ado-net-applications.md)
- [Общие сведения о безопасности SQL Server](overview-of-sql-server-security.md)
- [Сценарии безопасности приложений в SQL Server](application-security-scenarios-in-sql-server.md)
- [Управление разрешениями с использованием хранимых процедур в SQL Server](managing-permissions-with-stored-procedures-in-sql-server.md)
- [Написание безопасного динамического кода SQL в SQL Server](writing-secure-dynamic-sql-in-sql-server.md)
- [Настройка разрешений с олицетворением в SQL Server](customizing-permissions-with-impersonation-in-sql-server.md)
- [Изменение данных с помощью хранимых процедур](../modifying-data-with-stored-procedures.md)
- [Общие сведения об ADO.NET](../ado-net-overview.md)
