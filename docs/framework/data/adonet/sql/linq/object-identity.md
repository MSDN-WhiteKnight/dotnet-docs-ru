---
description: 'Дополнительные сведения: удостоверение объекта'
title: Идентификация объектов
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c788f2f9-65cc-4455-9907-e8388a268e00
ms.openlocfilehash: 1e525250e37e697e33ee53ea59b973882633ec15
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99695519"
---
# <a name="object-identity"></a>Идентификация объектов

Во время выполнения объекты получают уникальные идентификаторы. Две переменные, которые ссылаются на один объект, в действительности ссылаются на один экземпляр этого объекта. По этой причине изменения, произведенные посредством одной переменной, немедленно отображаются через вторую.  
  
 Строки в таблице реляционной базы данных не имеют уникальных идентификаторов. Поэтому каждой строке присвоен уникальный первичный ключ, который не совпадает с ключами других строк. Однако этот факт применим только к содержимому таблицы базы данных.  
  
 В действительности данные зачастую извлекаются из базы данных и отправляются на другой уровень, на котором с ними работает приложение. Именно такая модель поддерживается технологией [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]. Когда данные извлекаются из базы данных в виде строк, пользователь не может сделать никаких предположений относительного того, что две строки, представляющие идентичные данные, в действительности соответствуют одному экземпляру строки. Если дважды выполнить запрос на получение одного определенного клиента, будут извлечены две строки данных. Каждая строка содержит идентичные сведения.  
  
 В случае объектов процесс осуществляется совершенно иначе. Можно ожидать, что, несколько раз отправляя классу <xref:System.Data.Linq.DataContext> запрос на получений одной и той же информации, в действительности будет получен один и тот же экземпляр объекта. Это поведение реализуется по той причине, что объекты имеют особое значение для приложения и полученные данные ведут себя как объекты. Объекты создаются как иерархии или графы. Пользователь может быть уверен, что объекты будут извлечены именно в этом качестве. Он не получит множество реплицированных экземпляров только потому, что отправил несколько запросов на одни и те же сведения.  
  
 В [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] идентификациями объектов управляет класс <xref:System.Data.Linq.DataContext>. При получении новой строки из базы данных строка регистрируется в таблице идентификаций по своему первичному ключу и создается новый объект. При извлечении той же строки приложение отправляется исходный экземпляр объекта. Таким образом, класс <xref:System.Data.Linq.DataContext> преобразует понятие идентификации в контексте базы данных (то есть первичные ключи) в понятие идентификации в контексте языка программирования (то есть экземпляры). Объект представляется приложению только в состоянии, в котором он находился при первом получении. Если новые данные оказываются другими, они удаляются. Дополнительные сведения см. в разделе [Получение объектов из кэша удостоверений](retrieving-objects-from-the-identity-cache.md).  
  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] использует этот подход для управления целостностью локальных объектов для поддержки оптимистического обновления. Поскольку все изменения, происходящие после первого создания объекта, выполняются приложением, действия приложения строго определены. Если во время работы приложения изменения производятся из-за пределов его области действия, эти изменения определяются в момент вызова метода `SubmitChanges()`.  
  
> [!NOTE]
> Если запрашиваемый объект легко определить как уже извлеченный, то запрос не выполняется. Таблица идентификаций действует как кэш всех ранее извлеченных объектов.  
  
## <a name="examples"></a>Примеры  
  
### <a name="object-caching-example-1"></a>Пример кэширования объекта 1  

 В данном примере, если дважды выполнить один и тот же запрос, каждый раз будет получена ссылка на один и тот же объект в памяти.  
  
 [!code-csharp[DLinqObjectIdentity#1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqObjectIdentity/cs/Program.cs#1)]
 [!code-vb[DLinqObjectIdentity#1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqObjectIdentity/vb/Module1.vb#1)]  
  
### <a name="object-caching-example-2"></a>Пример кэширования объекта 2  

 В данном примере, если дважды выполнить разные запросы, которые возвращают одну и ту же строку базы данных, каждый раз будет получена ссылка на один и тот же объект в памяти.  
  
 [!code-csharp[DLinqObjectIdentity#2](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqObjectIdentity/cs/Program.cs#2)]
 [!code-vb[DLinqObjectIdentity#2](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqObjectIdentity/vb/Module1.vb#2)]  
  
## <a name="see-also"></a>См. также

- [Основные сведения](background-information.md)
