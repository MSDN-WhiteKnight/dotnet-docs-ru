---
description: 'Дополнительные сведения: отложенная и немедленная загрузка'
title: Отложенная и немедленная загрузка
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: d1d7247f-a3b7-460b-b342-5c1a2365aa1a
ms.openlocfilehash: 8c2237bd726ca79c7c168040e2a701f51ec3d238
ms.sourcegitcommit: 10e719780594efc781b15295e499c66f316068b8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2021
ms.locfileid: "100464759"
---
# <a name="deferred-versus-immediate-loading"></a>Отложенная и немедленная загрузка

При запросе объекта фактически извлекается только запрошенный объект. *Связанные* объекты не извлекаться автоматически одновременно. (Дополнительные сведения см. в разделе [запросы по связям](querying-across-relationships.md).) Невозможно увидеть, что связанные объекты еще не загружены, так как попытка доступа к ним приводит к получению запроса, который их извлекает.  
  
 Например, может потребоваться запросить определенный набор заказов, а затем отправить уведомление по электронной почте определенным клиентам. В этом случае не требуется сразу извлекать все данные о клиентах вместе с каждым заказом. Можно использовать отложенную загрузку для получения дополнительной информации только тогда, когда она действительно необходима. Рассмотрим следующий пример.  
  
 [!code-csharp[DLinqQueryConcepts#1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQueryConcepts/cs/Program.cs#1)]
 [!code-vb[DLinqQueryConcepts#1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQueryConcepts/vb/Module1.vb#1)]  
  
 Иногда бывает полезным реализовать и противоположный подход. Предположим, имеется приложение, которому требуется одновременно просматривать данные о клиентах и заказах. В этом случае необходимы оба набора данных. Поскольку приложению требуются сведения о заказах для каждого клиента в момент получения результатов, нецелесообразно отправлять отдельные запросы на получение заказов для каждого клиента. Более эффективно извлекать данные о заказах одновременно с данными о клиентах.  
  
 [!code-csharp[DLinqQueryConcepts#2](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQueryConcepts/cs/Program.cs#2)]
 [!code-vb[DLinqQueryConcepts#2](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQueryConcepts/vb/Module1.vb#2)]  
  
 Можно также объединить клиентов и заказы в одном запросе путем создания перекрестного произведения и извлечения всех связанных битов данных в виде одной большой проекции. Однако эти результаты не являются сущностями (Дополнительные сведения см. [в разделе Объектная модель LINQ to SQL](the-linq-to-sql-object-model.md)). Сущности представляют собой объекты, которые обладают идентификациями и которые можно изменить. Результаты, напротив, являются проекциями, и их нельзя ни изменить, ни сохранить. Более того, при таком подходе извлекается большое количество избыточных данных, поскольку в плоских выходных данных, полученных в результате объединения, каждый клиент повторяется в каждом заказе.  
  
 Действительно эффективным стал бы способ параллельного извлечения набора связанных объектов. Этот набор является отделенным разделом графа, поэтому пользователь извлекает ровно тот объем данных, который ему необходим. Для этой цели [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] предоставляет <xref:System.Data.Linq.DataLoadOptions> немедленную загрузку региона объектной модели. Ниже перечислены используемые методы.  
  
- Метод <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> для немедленной загрузки данные, связанных с основными целевыми объектами.  
  
- Метод <xref:System.Data.Linq.DataLoadOptions.AssociateWith%2A> для фильтрации объектов, извлеченных для определенной связи.  
  
## <a name="see-also"></a>См. также раздел

- [Основные принципы запросов](query-concepts.md)
