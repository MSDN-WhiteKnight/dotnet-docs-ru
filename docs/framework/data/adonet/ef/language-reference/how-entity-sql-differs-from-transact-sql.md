---
description: Дополнительные сведения о том, как Entity SQL отличается от языка Transact-SQL.
title: Отличия Entity SQL от Transact-SQL
ms.date: 03/30/2017
ms.assetid: 9c9ee36d-f294-4c8b-a196-f0114c94f559
ms.openlocfilehash: 349dd64cc0e548ab0dc8d0e66e8bb14b58912d09
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99696871"
---
# <a name="how-entity-sql-differs-from-transact-sql"></a>Отличие Entity SQL от Transact-SQL

В этой статье описываются различия между Entity SQL и Transact-SQL.  
  
## <a name="inheritance-and-relationships-support"></a>Поддержка наследования и связей  

 Entity SQL работает непосредственно с концептуальными схемами сущностей и поддерживает такие функции концептуальной модели, как наследование и связи.  
  
 При работе с наследованием часто полезно выбрать экземпляры подтипа из коллекции экземпляров супертипа. Оператор [OFTYPE](oftype-entity-sql.md) в Entity SQL (аналогично `oftype` в последовательности C#) предоставляет эту возможность.  
  
## <a name="support-for-collections"></a>Поддержка коллекций  

 Entity SQL считает коллекции сущностями первого класса. Пример:  
  
- Выражения коллекций допускаются в предложении `from`.  
  
- Вложенные запросы `in` и `exists` были обобщены, чтобы разрешить любые коллекции.  
  
     Вложенный запрос - один из видов коллекций. `e1 in e2` и `exists(e)` являются конструкциями Entity SQL для выполнения этих операций.  
  
- Операторы работы с наборами, такие как `union`, `intersect` и `except`, теперь работают с коллекциями.  
  
- Операции соединения с коллекциями.  
  
## <a name="support-for-expressions"></a>Поддержка выражений  

 Transact-SQL содержит вложенные запросы (таблицы) и выражения (строки и столбцы).  
  
 Для поддержки коллекций и вложенных коллекций Entity SQL делает все выражение. Entity SQL является более композицией, чем Transact-SQL — каждое выражение можно использовать в любом месте. Результатом выражения запроса всегда является коллекция проецируемых типов, которая может быть использована везде, где разрешено выражение коллекции. Дополнительные сведения о выражениях Transact-SQL, которые не поддерживаются в Entity SQL, см. в разделе [Неподдерживаемые выражения](unsupported-expressions-entity-sql.md).  
  
 Ниже приведены все допустимые Entity SQL запросы.  
  
```sql  
1+2 *3  
"abc"  
row(1 as a, 2 as b)  
{ 1, 3, 5}
e1 union all e2  
set(e1)  
```  
  
## <a name="uniform-treatment-of-subqueries"></a>Единая обработка вложенных запросов  

 Учитывая его акцент на таблицах, Transact-SQL выполняет контекстную интерпретацию вложенных запросов. Например, вложенный запрос в `from` предложении считается мультинабором (таблицей). Тот же вложенный запрос в предложении `select` считается скалярным вложенным запросом. Аналогичным образом вложенный запрос, используемый в левой части `in` оператора, считается скалярным вложенным запросом, тогда как правая часть должна быть вложенным запросом мультинабора.  
  
 Entity SQL устраняет эти различия. Выражение имеет единую интерпретацию, которая не зависит от контекста, в котором оно использовано. Entity SQL считает, что все вложенные запросы являются вложенными запросами мультинабора. Если из вложенного запроса требуется скалярное значение, Entity SQL предоставляет `anyelement` оператор, который работает с коллекцией (в данном случае вложенный запрос), и извлекает одноэлементное значение из коллекции.  
  
### <a name="avoiding-implicit-coercions-for-subqueries"></a>Устранение неявных приведений для вложенных запросов  

 Побочный эффект единообразной обработки вложенных запросов - неявное преобразование вложенных запросов к скалярным значениям. В частности, в языке Transact-SQL мультинабор строк (с одним полем) неявно преобразуется в скалярное значение, тип данных которого является значением поля.  
  
 Entity SQL не поддерживает это неявное приведение. Entity SQL предоставляет `ANYELEMENT` оператор для извлечения одноэлементного значения из коллекции и `select value` предложение во избежание создания оболочки строк во время выражения запроса.  
  
## <a name="select-value-avoiding-the-implicit-row-wrapper"></a>Выбранное значение: устранение неявной оболочки строк  

 Предложение SELECT в вложенном запросе Transact-SQL неявно создает оболочку строк вокруг элементов в предложении. Это означает, что нельзя создавать коллекции скалярных величин или объектов. Transact-SQL позволяет неявное приведение между `rowtype` с одним полем и одноэлементным значением одного и того же типа данных.  
  
 Entity SQL предоставляет `select value` предложение для пропуска неявной конструкции строки. В предложении `select value` можно указать только один элемент. При использовании такого предложения оболочка строк не создается вокруг элементов в `select` предложении, а коллекция требуемой формы может быть создана, например `select value a` .  
  
 Entity SQL также предоставляет конструктор строк для создания произвольных строк. `select` принимает один или несколько элементов в проекции и приводит к записи данных с полями:  
  
 `select a, b, c`  
  
## <a name="left-correlation-and-aliasing"></a>Левая корреляция и задание псевдонимов  

 В языке Transact-SQL выражения в заданной области (одно предложение вроде `select` или `from` ) не могут ссылаться на выражения, определенные ранее в той же области. Некоторые диалекты SQL (включая Transact-SQL) поддерживают ограниченные формы в `from` предложении.  
  
 Entity SQL обобщает левые корреляции в `from` предложении и обрабатывает их единообразно. Выражения в предложении `from` могут содержать ссылки на более ранние определения (определения слева) в том же предложении без дополнительных синтаксических конструкций.  
  
 Entity SQL также накладывает дополнительные ограничения на запросы, включающие `group by` предложения. Выражения в `select` предложении и `having` предложении таких запросов могут ссылаться только на `group by` ключи через их псевдонимы. Следующая конструкция допустима в Transact-SQL, но не в Entity SQL:  
  
```sql  
SELECT t.x + t.y FROM T AS t group BY t.x + t.y
```  
  
 Для этого в Entity SQL:  
  
```sql  
SELET k FROM T AS t GROUP BY (t.x + t.y) AS k
```  
  
## <a name="referencing-columns-properties-of-tables-collections"></a>Ссылочные столбцы (свойства) таблиц (коллекций)  

 Все ссылки на столбцы в Entity SQL должны уточняться псевдонимом таблицы. Следующая конструкция (при условии, что `a` является допустимым столбцом таблицы `T` ) допустима в TRANSACT-SQL, но не в Entity SQL.  
  
```sql  
SELECT a FROM T
```  
  
 Форма Entity SQL  
  
```sql  
SELECT t.a AS A FROM T AS t
```  
  
 Псевдонимы таблицы в предложении `from` необязательны. Имя таблицы используется как неявный псевдоним. Entity SQL также поддерживает следующие формы:  
  
```sql  
SELET Tab.a FROM Tab
```  
  
## <a name="navigation-through-objects"></a>Перемещение по объектам  

 В Transact-SQL используется нотация "." для ссылок на столбцы (строки) таблицы. Entity SQL расширяет эту нотацию (заимствованную из языков программирования) для поддержки навигации по свойствам объекта.  
  
 Например, если `p` является выражением типа Person, ниже приведен синтаксис Entity SQL для ссылки на город адреса этого человека.  
  
```sql  
p.Address.City
```  
  
## <a name="no-support-for-"></a>Нет поддержки для \*  

 Transact-SQL поддерживает неполный \* синтаксис в качестве псевдонима для всей строки и полный \* синтаксис (t. \* ) в качестве ярлыка для полей этой таблицы. Кроме того, Transact-SQL позволяет выполнять специальные \* статистические функции Count (), которые включают значения NULL.  
  
 Entity SQL не поддерживает конструкцию *. Запросы Transact-SQL к форме `select * from T` и `select T1.* from T1, T2...` могут быть выражены в Entity SQL как `select value t from T as t` и `select value t1 from T1 as t1, T2 as t2...` соответственно. Эти конструкции также обеспечивают наследование (заменяемость значений), в то время как варианты `select *` ограничены свойствами верхнего уровня объявленного типа.  
  
 Entity SQL не поддерживает `count(*)` статистическую обработку. Взамен рекомендуется использовать `count(0)`.  
  
## <a name="changes-to-group-by"></a>Изменения на предложение Group By  

 Entity SQL поддерживает псевдонимы `group by` ключей. Выражения в предложении `select` и предложении `having` таких запросов должны ссылаться на ключи `group by` через псевдонимы. Например, следующий синтаксис Entity SQL:  
  
```sql  
SELECT k1, count(t.a), sum(t.a)
FROM T AS t
GROUP BY t.b + t.c AS k1
```  
  
 ... эквивалентен следующему языку Transact-SQL:  
  
```sql  
SELECT b + c, count(*), sum(a)
FROM T
GROUP BY b + c
```  
  
## <a name="collection-based-aggregates"></a>Статистические функции на основе коллекций  

 Entity SQL поддерживает два вида агрегатов.  
  
 Статистические функции на основе коллекций работают с коллекциями и возвращают результат статистической обработки. Они могут применяться в любом месте в запросе и не требуют предложения `group by`. Пример:  
  
```sql  
SELECT t.a AS a, count({1,2,3}) AS b FROM T AS t
```  
  
 Entity SQL также поддерживает статистические выражения в стиле SQL. Пример:  
  
```sql  
SELECT a, sum(t.b) FROM T AS t GROUP BY t.a AS a
```  
  
## <a name="order-by-clause-usage"></a>Использование предложения ORDER BY  

Transact-SQL позволяет `ORDER BY` указывать предложения только в самом верхнем `SELECT .. FROM .. WHERE` блоке. В Entity SQL можно использовать вложенное `ORDER BY` выражение, которое можно поместить в любом месте запроса, но упорядочение во вложенном запросе не сохраняется.  
  
```sql  
-- The following query will order the results by the last name  
SELECT C1.FirstName, C1.LastName  
        FROM AdventureWorks.Contact AS C1
        ORDER BY C1.LastName  
```  
  
```sql  
-- In the following query ordering of the nested query is ignored.  
SELECT C2.FirstName, C2.LastName  
    FROM (SELECT C1.FirstName, C1.LastName  
        FROM AdventureWorks.Contact as C1  
        ORDER BY C1.LastName) as C2  
```  
  
## <a name="identifiers"></a>Идентификаторы  

 В Transact-SQL сравнение идентификаторов основано на параметрах сортировки текущей базы данных. В Entity SQL идентификаторы всегда не учитывают регистр и диакритические знаки (т. е. Entity SQL различаются символы с диакритическими знаками и без них, например, "a" не равно "ấ"). Entity SQL воспринимает версии букв, которые выглядят одинаково, но находятся в разных кодовых страницах с разными символами. Дополнительные сведения см. в разделе [input character set](input-character-set-entity-sql.md).  
  
## <a name="transact-sql-functionality-not-available-in-entity-sql"></a>Функциональность Transact-SQL, недоступная в Entity SQL  

 Следующие функциональные возможности Transact-SQL недоступны в Entity SQL.  
  
 DML  
 В настоящее время Entity SQL не поддерживает инструкции DML (INSERT, Update, DELETE).  
  
 DDL  
 Entity SQL не обеспечивает поддержку DDL в текущей версии.  
  
 Командное программирование  
 Entity SQL не обеспечивает поддержку императивного программирования, в отличие от Transact-SQL. Используйте вместо этого языки программирования.  
  
 Функции группирования  
 Entity SQL еще не предоставляет поддержку группирования функций (например, CUBE, ROLLUP и GROUPING_SET).  
  
 Аналитические функции  
 Entity SQL не предоставляет поддержку аналитических функций.  
  
 Встроенные функции, операторы  
 Entity SQL поддерживает подмножество встроенных функций и операторов Transact-SQL. Вероятно, эти операторы и функции будут реализованы ведущими поставщиками хранилищ. Entity SQL использует зависящие от хранилища функции, объявленные в манифесте поставщика. Кроме того, Entity Framework позволяет объявлять встроенные и определяемые пользователем существующие функции хранилища для использования Entity SQL.  
  
 Указания  
 Entity SQL не предоставляет механизмов для указания запросов.  
  
 Пакетирование результатов запроса  
 Entity SQL не поддерживает пакетную обработку результатов запросов. Например, ниже приведен допустимый Transact-SQL (отправка в виде пакета):  
  
```sql  
SELECT * FROM products;
SELECT * FROM catagories;
```  
  
 Однако эквивалентные Entity SQL не поддерживаются:  
  
```sql  
SELECT value p FROM Products AS p;
SELECT value c FROM Categories AS c;
```  
  
 Entity SQL поддерживает только одну инструкцию запроса с результатами для каждой команды.  
  
## <a name="see-also"></a>См. также

- [Общие сведения об Entity SQL](entity-sql-overview.md)
- [Неподдерживаемые выражения](unsupported-expressions-entity-sql.md)
