---
description: 'Дополнительные сведения: известные проблемы в SqlClient для Entity Framework'
title: Известные проблемы SqlClient для Entity Framework
ms.date: 03/30/2017
ms.assetid: 48fe4912-4d0f-46b6-be96-3a42c54780f6
ms.openlocfilehash: c1a82657f1b43cddb858692d055df3bf2dca47ec
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99697339"
---
# <a name="known-issues-in-sqlclient-for-entity-framework"></a>Известные проблемы SqlClient для Entity Framework

В данном разделе описаны известные проблемы, связанные с поставщиком данных .NET Framework для SQL Server (SqlClient).  
  
## <a name="trailing-spaces-in-string-functions"></a>Конечные пробелы в строковых функциях  

 SQL Server игнорирует конечные пробелы в строковых значениях. Таким образом, передача конечных пробелов в строку может привести к непредсказуемым результатам и даже сбоям.  
  
 Если в строке должны находиться конечные пробелы, следует рассмотреть возможность добавления символа пробела в конец, чтобы SQL Server не обрезать строку. Если конечные пробелы не требуются, их следует усекать до их последующей передачи по конвейеру запросов.  
  
## <a name="right-function"></a>RIGHT, функция  

 Если в `null`, 0`RIGHT(nvarchar(max)` или `)`, 0`RIGHT(varchar(max)` в качестве первого аргумента передается значение, отличное от `)`, а в качестве второго аргумента передается значение, равное 0, то вместо строки `NULL` будет возвращено значение типа `empty`.  
  
## <a name="cross-and-outer-apply-operators"></a>Операторы CROSS APPLY и OUTER APPLY  

 Операторы пересечения и НАРУЖного применения появились в SQL Server 2005. В некоторых случаях конвейер запросов может сформировать инструкцию Transact-SQL, содержащую операторы CROSS APPLY и OUTER APPLY. Поскольку некоторые серверные поставщики, включая версии SQL Server более ранние, чем SQL Server 2005, не поддерживают эти операторы, такие запросы не могут выполняться на этих внутренних поставщиках.  
  
 Далее показаны некоторые стандартные сценарии, которые могут привести к появлению операторов CROSS APPLY и OUTER APPLY в выходном запросе.  
  
- Связанный вложенный запрос с разбиением на страницы.  
  
- `AnyElement` над коррелированным вложенным запросом или коллекцией, сформированной навигацией.  
  
- LINQ-запросы, использующие методы группирования, принимающие элемент selector.  
  
- Запрос, в котором явно указан оператор CROSS APPLY или OUTER APPLY.  
  
- Запрос, имеющий конструкцию DEREF над конструкцией REF.  
  
## <a name="skip-operator"></a>Оператор SKIP  

 Если используется SQL Server 2000, использование инструкции SKIP с предложением ORDER BY в неключевых столбцах может привести к возврату неверных результатов. Если неключевой столбец содержит повторяющиеся данные, то может быть пропущено больше указанного числа строк. Это происходит из-за преобразования SKIP для SQL Server 2000. Например, в следующем запросе более пяти строк может быть пропущено, если `E.NonKeyColumn` содержит дублирующиеся значения:  
  
```sql  
SELECT [E] FROM Container.EntitySet AS [E] ORDER BY [E].[NonKeyColumn] DESC SKIP 5L  
```  
  
## <a name="targeting-the-correct-sql-server-version"></a>Нацеливание на правильную версию SQL Server  

 Entity Framework предназначен для запроса Transact-SQL на основе версии SQL Server, указанной в `ProviderManifestToken` атрибуте элемента Schema в файле модели хранения (. SSDL). Данная версия может отличаться от фактической версии SQL Server, с которой в данный момент осуществлено соединение. Например, если используется SQL Server 2005, но `ProviderManifestToken` атрибут имеет значение 2008, то созданный запрос Transact-SQL может не выполняться на сервере. Например, запрос, который использует новые типы даты и времени, представленные в SQL Server 2008, не будет выполняться в предыдущих версиях SQL Server. Если используется SQL Server 2005, но `ProviderManifestToken` для атрибута задано значение 2000, то созданный запрос Transact-SQL может быть менее оптимизирован или может возникнуть исключение, сообщающее, что запрос не поддерживается. Дополнительные сведения см. в разделе «Операторы CROSS и OUTER APPLY», приведенном выше в данной теме.  
  
 Некоторые варианты поведения базы данных зависят от уровня совместимости, установленного на базе данных. Если `ProviderManifestToken` атрибут имеет значение 2005, а версия SQL Server — 2005, но уровень совместимости базы данных имеет значение "80" (SQL Server 2000), то созданный Transact-SQL будет нацелен на SQL Server 2005, но может не выполняться должным образом из-за настройки уровня совместимости. Например, если имя столбца в списке ORDER BY совпадает с именем столбца в селекторе, то можно потерять данные об упорядочивании.  
  
## <a name="nested-queries-in-projection"></a>Вложенные запросы в проекции  

 Вложенные запросы в предложении проекции могут быть переведены в запросы декартовых произведений на сервере. На некоторых внутренних серверах, в том числе SQL Server, это может привести к тому, что таблица TempDB будет иметь довольно большой размер. Это может снизить производительность сервера.  
  
 Далее приведен пример вложенного запроса в предложении проекции:  
  
```sql  
SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2 FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1 FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
```  
  
## <a name="server-generated-guid-identity-values"></a>Формируемые сервером значения идентификаторов GUID  

 Entity Framework поддерживает генерируемые сервером значения идентификаторов типа GUID, но поставщик должен поддерживать возврат сформированного сервером значения идентификатора после вставки строки. Начиная с SQL Server 2005, можно вернуть созданный сервером тип GUID в базе данных SQL Server с помощью [предложения OUTPUT](/sql/t-sql/queries/output-clause-transact-sql).
  
## <a name="see-also"></a>См. также

- [SqlClient для Entity Framework](sqlclient-for-the-entity-framework.md)
- [LINQ to Entities: рекомендации и известные проблемы](./language-reference/known-issues-and-considerations-in-linq-to-entities.md)
