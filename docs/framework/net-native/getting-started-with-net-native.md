---
description: 'Дополнительные сведения: начало работы с .NET Native'
title: Начало работы с машинным кодом .NET
ms.date: 03/30/2017
ms.assetid: fc9e04e8-2d05-4870-8cd6-5bd276814afc
ms.openlocfilehash: 6079e21764ebc39515eb9b9f217057d916da8942
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99747807"
---
# <a name="getting-started-with-net-native"></a>Начало работы с машинным кодом .NET

При разработке нового приложения для Windows 10 или при миграции существующего приложения Магазина Windows можно использовать один и тот же набор процедур. Чтобы создать .NET Native приложение, выполните следующие действия.

1. [Разработайте приложение универсальной платформы Windows (UWP), предназначенное для Windows 10](#Step1), и протестируйте его отладочные сборки, чтобы убедиться в его правильной работе.

2. [обработайте дополнительные использования отражения и сериализации](#Step2).

3. [Разверните и протестируйте выпускаемые сборки приложения](#Step3).

4. [Вручную разрешите отсутствующие метаданные](#Step4) и повторяйте [шаг 3](#Step3) до тех пор, пока все вопросы не будут разрешены.

> [!NOTE]
> Если вы переносите существующее приложение Магазина Windows на .NET Native, обязательно ознакомьтесь со статьей [миграция приложения из Магазина Windows в .NET Native](migrating-your-windows-store-app-to-net-native.md).

<a name="Step1"></a>

## <a name="step-1-develop-and-test-debug-builds-of-your-uwp-app"></a>Шаг 1. Разработка и тестирование отладочных сборок приложения UWP

При разработке нового приложения или миграции существующего выполняется тот же процесс, что и для любого приложения Windows.

1. Создайте проект UWP в Visual Studio с помощью шаблона универсального приложения Windows для Visual C# или Visual Basic. По умолчанию все приложения UWP предназначены для CoreCLR, и их выпускаемые сборки компилируются с помощью цепочки инструментов машинного кода .NET.

2. Обратите внимание, что существуют некоторые известные проблемы совместимости между проектами приложений UWP, скомпилированными с помощью цепочки инструментов машинного кода .NET и без нее. Обратитесь к [руководство по миграции](migrating-your-windows-store-app-to-net-native.md) для получения дополнительных сведений.

Теперь вы можете написать код C# или Visual Basic в .NET Native контактной зоне, которая выполняется в локальной системе (или в симуляторе).

> [!IMPORTANT]
> При разработке приложения, обратите внимание на любое использование сериализации или отражения в коде.

По умолчанию отладочные сборки компилируются JIT-компилятором, чтобы обеспечить быстрое развертывание F5, а сборки выпуска компилируются с помощью технологии предварительной компиляции .NET Native. Это означает, что вам следует создать и протестировать отладочные сборки приложения, чтобы проверить правильность их работы, перед тем как компилировать их с помощью цепочки инструментов машинного кода .NET.

<a name="Step2"></a>

## <a name="step-2-handle-additional-reflection-and-serialization-usage"></a>Шаг 2. Обработка дополнительных операций использования отражения и сериализации

Файл директив среды выполнения по умолчанию Default.RD.XML автоматически добавляется в проект при его создании. При разработке на языке C# он находится в папке **Properties** вашего проекта. При разработке на языке Visual Basic он находится в папке **My Project** вашего проекта.

> [!NOTE]
> Общие сведения о процессе компиляции машинного кода .NET, обосновывающие необходимость файла директив среды выполнения, см. в разделе [Машинный код .NET и компиляция](net-native-and-compilation.md).

Файл директив среды выполнения служит для определения метаданных, которые понадобятся вашему приложению во время выполнения. В некоторых случаях версии этого файла по умолчанию может быть достаточно. Однако для кода, в котором используется сериализация или отражение, могут потребоваться дополнительные записи в файле директив среды выполнения.

**Сериализация**

Существует две категории сериализаторов и обе могут потребовать дополнительных записей в файле директив среды выполнения:

- сериализаторы, работающие без использования отражения. сериализаторы из библиотеки классов .NET Framework, например, <xref:System.Runtime.Serialization.DataContractSerializer>, <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>и классы <xref:System.Xml.Serialization.XmlSerializer> не используют отражение. Тем не менее, они требуют генерировать код на основе объекта для сериализации или десериализации.  Дополнительные сведения см. в разделе "Сериализаторы Microsoft" в [Serialization and Metadata](serialization-and-metadata.md).

- Сериализаторы сторонних поставщиков. Сторонние библиотеки сериализации, наиболее распространенный из которых является сериализатором Newtonsoft JSON, обычно основаны на отражении и занимают записи в \* файле.rd.xml для поддержки сериализации и десериализации объектов. Дополнительные сведения см. в разделе "Сериализаторы сторонних поставщиков" в [Serialization and Metadata](serialization-and-metadata.md).

**Методы, основанные на отражении**

В некоторых случаях использование отражения в коде не очевидно. Некоторые общие интерфейсы API или шаблоны программирования не считаются частью API-интерфейса отражения, но используют отражение для успешного выполнения. К ним относятся следующие методы создания экземпляров типов и методы создания методов:

- метод <xref:System.Type.MakeGenericType%2A?displayProperty=nameWithType> ;

- методы <xref:System.Array.CreateInstance%2A?displayProperty=nameWithType> и <xref:System.Type.MakeArrayType%2A?displayProperty=nameWithType>

- метод <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> ;

Дополнительные сведения см. в разделе [APIs That Rely on Reflection](apis-that-rely-on-reflection.md).

> [!NOTE]
> Имена типов в файлах директив среды выполнения должны быть полными. Например, файл должен определять "System.String" вместо "String".

<a name="Step3"></a>

## <a name="step-3-deploy-and-test-the-release-builds-of-your-app"></a>Шаг 3. Развертывание и тестирование выпускаемых сборок приложения

После обновления файла директив среды выполнения можно перестроить и развернуть выпускаемые сборки приложения. .NET Native двоичные файлы помещаются в подкаталог ILC. out каталога, указанного в текстовом поле **выходной путь построения** диалогового окна **Свойства** проекта, вкладка **Компиляция** . Двоичные файлы, которые не находятся в этой папке, не были скомпилированы с помощью .NET Native. Тщательно протестируйте свое приложение и проверьте все сценарии, включая сценарии сбоя, на каждой целевой платформе.

Если приложение работает плохо (особенно в случае создания исключений [MissingMetadataException](missingmetadataexception-class-net-native.md) или [MissingInteropDataException](missinginteropdataexception-class-net-native.md) во время выполнения), следуйте инструкциям в следующем разделе: [Шаг 4. Устранение вручную проблем с отсутствующими метаданными](#Step4). Включение исключений первого шанса может помочь в обнаружении этих ошибок.

После тестирования и отладки отладочных сборок приложения и уверенности в устранении исключений [MissingMetadataException](missingmetadataexception-class-net-native.md) и [MissingInteropDataException](missinginteropdataexception-class-net-native.md) следует протестировать приложение в качестве оптимизированного .NET Native приложения. Чтобы сделать это, измените настройку активного проекта с **Debug** (Отладка) на **Release**(Выпуск).

<a name="Step4"></a>

## <a name="step-4-manually-resolve-missing-metadata"></a>Шаг 4. Устранение проблем с отсутствующими метаданными вручную

Наиболее распространенный сбой при .NET Native, который не встречается на рабочем столе, — это исключение времени выполнения [MissingMetadataException](missingmetadataexception-class-net-native.md), [MissingInteropDataException](missinginteropdataexception-class-net-native.md)или [MissingRuntimeArtifactException](missingruntimeartifactexception-class-net-native.md) . В некоторых случаях отсутствие метаданных может проявляться в непредсказуемое поведение или даже сбоях приложений. В этом разделе рассматриваются отладка и устранения этих исключений путем добавления директив в файл директив среды выполнения. Сведения о директивах среды выполнения см. в разделе [Справочник по конфигурационному файлу директив среды выполнения (rd.xml)](runtime-directives-rd-xml-configuration-file-reference.md). После добавления директив среды выполнения необходимо снова [развернуть и протестировать ваше приложение](#Step3) и полностью устранить все новые исключения [MissingMetadataException](missingmetadataexception-class-net-native.md), [MissingInteropDataException](missinginteropdataexception-class-net-native.md)и  [MissingRuntimeArtifactException](missingruntimeartifactexception-class-net-native.md) .

> [!TIP]
> Укажите директивы среды выполнения на высоком уровне, чтобы ваше приложение было устойчиво к изменениям кода.  Рекомендуется добавить директивы среды выполнения на уровне пространства имен и типов, а не на уровне членов. Обратите внимание, что может потребоваться компромисс между устойчивостью и большими по размеру двоичными файлами с более длительным временем компиляции.

При устранении исключений, связанных с отсутствующими метаданными, обратите внимание на следующие моменты:

- Что пыталось выполнить приложение перед возникновением исключения?

  - Например, была ли это привязка данных, сериализация и десериализация данных или прямое использование API-интерфейса отражения?

- Это изолированный случай или вы считаете, что эта же проблема возникнет с другими типами?

  - Например, исключение [MissingMetadataException](missingmetadataexception-class-net-native.md) возникает при сериализации типов в объектной модели приложения.  Если известны другие типы, которые будут сериализованы, можно одновременно добавить директивы среды выполнения для этих типов (или для их содержащих пространств имен, в зависимости от того, насколько хорошо организован код).

- Можете ли вы переписать код, чтобы он не использовал отражение?

  - Например, использует ли код ключевое слово `dynamic` , если известно, какой должен быть тип?

  - Вызывает ли код метод, зависящий от отражения, когда доступен несколько лучший вариант?

> [!NOTE]
> Дополнительные сведения об обработке проблем, возникающих из-за различий в отражении и доступности метаданных в классических приложениях и .NET Native, см. в разделе [интерфейсы API, основанные на отражении](apis-that-rely-on-reflection.md).

Конкретные примеры обработки исключений и других проблем, возникающих при тестировании приложения, см. в:

- [Пример. Обработка исключений при привязке данных](example-handling-exceptions-when-binding-data.md)

- [Пример. Устранение неполадок динамического программирования](example-troubleshooting-dynamic-programming.md)

- [Исключения среды выполнения в собственных приложениях .NET](runtime-exceptions-in-net-native-apps.md)

## <a name="see-also"></a>См. также

- [Ссылка на файл конфигурации директив среды выполнения (rd.xml)](runtime-directives-rd-xml-configuration-file-reference.md)
- [Установка и конфигурация машинного кода .NET](/previous-versions/dn600164(v=vs.110))
- [Машинный код .NET и компиляция](net-native-and-compilation.md)
- [Отражение и машинный код .NET](reflection-and-net-native.md)
- [API-интерфейсы, основанные на отражении](apis-that-rely-on-reflection.md)
- [Сериализация и метаданные](serialization-and-metadata.md)
- [Миграция приложения для магазина Windows в машинный код .NET](migrating-your-windows-store-app-to-net-native.md)
