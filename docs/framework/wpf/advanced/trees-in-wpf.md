---
title: Деревья в WPF
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: f9b507c874dfe0ab3feca19e7fcf79df5af93e10
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2019
ms.locfileid: "59197689"
---
# <a name="trees-in-wpf"></a>Деревья в WPF
Во многих технологиях элементы и компоненты организованы в форме древовидной структуры, и разработчики могут напрямую управлять узлами объекта в дереве, чтобы повлиять на визуализацию или поведение приложения. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] также использует несколько метафор древовидных структур, чтобы определить отношения между программными элементами. Для большей части WPF разработчики могут создать приложение в коде или определить части приложения в XAML и при этом концептуально думать о метафоре дерева объектов, но для этого им потребуется вызвать определенный интерфейс API или использовать конкретную разметку, а не интерфейс API управления деревом некоторых общих объектов, какой можно использовать в XML DOM. WPF предоставляет два вспомогательных класса, которые обеспечивают представление метафоры дерева <xref:System.Windows.LogicalTreeHelper> и <xref:System.Windows.Media.VisualTreeHelper>. Термины "логическое дерево" и "визуальное дерево" также используются в документации WPF, поскольку эти же деревья помогают понять поведение определенных ключевых функций WPF. В этом разделе определены понятия визуального дерева и логического дерева, обсуждается, как эти деревья связаны с общим понятием дерева объектов, и представлены классы <xref:System.Windows.LogicalTreeHelper> и <xref:System.Windows.Media.VisualTreeHelper>s.  

<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a>Деревья в WPF  
 Самой полной древовидной структурой в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] является дерево объектов. При определении страницы приложения в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] и последующей загрузке [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] древовидная структура создается на основе отношений вложенности элементов в разметке. При определении приложения или части приложения в коде древовидная структура создается в зависимости от того, как присваиваются значения свойствам, которые реализуют модель содержимого для данного объекта. В [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] существует два способа концептуализации и передачи в открытый интерфейс API полного дерева объектов: в виде логического дерева и в виде визуального дерева. Различия между логическими деревьями и визуальными деревьями не всегда важны, но иногда они могут вызвать проблемы с некоторыми подсистемами [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и повлиять на изменения, внесенные в разметку или код.  
  
 Несмотря на то, что управление логическим деревом или визуальным деревом не всегда происходит напрямую, понимание концепций взаимодействия деревьев позволяет понять WPF как технологию. Рассмотрение WPF как некоторой метафоры дерева также важно для понимания того, как в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] осуществляется наследование свойств и маршрутизация событий.  
  
> [!NOTE]
>  Поскольку дерево объектов — это более широкое понятие, чем фактический интерфейс API, еще одним способом представить себе концепцию является граф объекта. На практике отношения между объектами можно наблюдать во время выполнения, когда метафора дерева разделяется. Тем не менее, особенно в пользовательском интерфейсе, определенном XAML, метафора дерева достаточно релевантна, и в большей части документации WPF используется термин "дерево объекта" при ссылке на это общее понятие.  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a>Логическое дерево  
 В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] содержимое добавляется в элементы пользовательского интерфейса путем задания свойств объектов, которые поддерживают эти элементы. Например, добавить элементы к <xref:System.Windows.Controls.ListBox> управления, управляя ее <xref:System.Windows.Controls.ItemsControl.Items%2A> свойство. Таким образом, вы размещаете элементы в <xref:System.Windows.Controls.ItemCollection> то есть <xref:System.Windows.Controls.ItemsControl.Items%2A> значение свойства. Аналогичным образом, для добавления объектов <xref:System.Windows.Controls.DockPanel>, работать с его <xref:System.Windows.Controls.Panel.Children%2A> значение свойства. Здесь происходит добавление объектов <xref:System.Windows.Controls.UIElementCollection>. Пример кода см. в разделе [как: Динамическое добавление элемента](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  
  
 В [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]при помещении элементов списка в <xref:System.Windows.Controls.ListBox> или элементы управления, или других элементов пользовательского интерфейса в <xref:System.Windows.Controls.DockPanel>, можно также использовать <xref:System.Windows.Controls.ItemsControl.Items%2A> и <xref:System.Windows.Controls.Panel.Children%2A> свойства, явно или неявно, как показано в следующем примере.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Если бы этот XAML обрабатывался как XML в объектной модели документов, и если бы были включены теги, закомментированные как неявные (были бы допустимы), полученное дерево XML DOM включало бы элементы для `<ListBox.Items>` и другие неявные элементы. Но XAML не выполняет такую обработку при чтении разметки и записи в объекты, полученный граф объекта не включает `ListBox.Items` в буквальном смысле. Однако он имеет <xref:System.Windows.Controls.ListBox> свойство с именем `Items` , содержащий <xref:System.Windows.Controls.ItemCollection>и что <xref:System.Windows.Controls.ItemCollection> инициализируется, но если <xref:System.Windows.Controls.ListBox> обработки XAML. Затем каждый дочерний элемент объекта, существующий как содержимое для <xref:System.Windows.Controls.ListBox> добавляется <xref:System.Windows.Controls.ItemCollection> вызовами средство синтаксического анализа `ItemCollection.Add`. Этот пример обработки XAML в дереве объектов на первый взгляд похож на пример, в котором созданное дерево объектов, по сути, является логическим деревом.  
  
 Однако логическое дерево не является полным графом объекта, существующим в пользовательском интерфейсе приложения во время выполнения, даже когда неявные элементы синтаксиса XAML факторизованы. Основная причина этого — визуальные элементы и шаблоны. Например, рассмотрим <xref:System.Windows.Controls.Button>. Логическое дерево сообщает об <xref:System.Windows.Controls.Button> объекта и его строке `Content`. Но в дереве объектов времени выполнения имеется больше сведений об этой кнопке. В частности, кнопка отображается только на экране способом, связано с определенным <xref:System.Windows.Controls.Button> был применен шаблон элемента управления. Визуальных элементах, полученных из примененного шаблона (таких как определенный шаблоном <xref:System.Windows.Controls.Border> темно-серого участка вокруг визуальной кнопки), не указываются в логическом дереве даже при просмотре логического дерева во время выполнения (например, обработки события ввода из видимого пользовательского интерфейса и последующего чтения логического дерева). Чтобы найти визуальные элементы шаблона, необходимо проверить визуальное дерево.  
  
 Дополнительные сведения о сопоставлении синтаксиса [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] с созданным графом объекта и неявным синтаксисом в XAML см. в разделе [Подробное описание синтаксиса XAML](xaml-syntax-in-detail.md) или [Общие сведения о языке XAML (WPF)](xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a>Назначение логического дерева  
 Логическое дерево существует для того, чтобы модели содержимого имели возможность пройти по своим доступным дочерним объектам, а также для их расширяемости. Кроме того, логическое дерево предоставляет оболочку для некоторых уведомлений, например при загрузке всех объектов логического дерева. По существу, логическое дерево является подобием графа объекта времени выполнения на уровне оболочки, исключающего визуальные элементы, но подходит для большинства операций запросов для собственной композиции приложения времени выполнения.  
  
 Кроме того, обе ссылки на статические и динамические ресурсы разрешаются путем поиска перемещается вверх по логическому дереву для <xref:System.Windows.FrameworkElement.Resources%2A> коллекций на исходном запрашивающем объекте, а затем продолжить логическому дереву и проверки <xref:System.Windows.FrameworkElement> (или <xref:System.Windows.FrameworkContentElement>) для другого `Resources` значение, содержащее <xref:System.Windows.ResourceDictionary>, возможно, содержит такой ключ. Логическое дерево используется для просмотра ресурсов при наличии логического дерева и визуального дерева. Дополнительные сведения о словарях ресурсов и поиске см. в разделе [Общие сведения о ресурсах](xaml-resources.md).  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a>Композиция логического дерева  
 Логическое дерево определяется на уровне среды WPF, это означает, что базовый элемент WPF, который наиболее подходит для операций логического дерева находится <xref:System.Windows.FrameworkElement> или <xref:System.Windows.FrameworkContentElement>. Тем не менее, как вы видите Если фактически используется <xref:System.Windows.LogicalTreeHelper> API, логическое дерево иногда содержит узлы, которые не являются ни <xref:System.Windows.FrameworkElement> или <xref:System.Windows.FrameworkContentElement>. Например, логическое дерево сообщает <xref:System.Windows.Controls.TextBlock.Text%2A> значение <xref:System.Windows.Controls.TextBlock>, которое представляет собой строку.  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a>Переопределение логического дерева  
 Авторы дополнительных элементов управления могут переопределить логическое дерево, переопределив несколько [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], которые определяют то, как основная модель объекта или содержимого добавляет или удаляет объекты логического дерева. Пример переопределения логического дерева содержится в разделе [Переопределение логического дерева](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a>Наследование значения свойства  
 Наследование значения свойств действует через гибридное дерево. Фактические метаданные, содержащий <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> уровня среды WPF имеет свойство, позволяющее наследование свойств <xref:System.Windows.FrameworkPropertyMetadata> класса. Таким образом, как родительский объект, содержащий исходное значение, так и дочерний объект, наследующий это значение должны быть <xref:System.Windows.FrameworkElement> или <xref:System.Windows.FrameworkContentElement>, и оба должны быть частью некоторого логического дерева. Однако для существующих свойств WPF, поддерживающих наследование свойств, наследование значений свойств способно принять промежуточный объект, которого нет в логическом дереве. Как правило, это распространяется на элементы шаблона, использующие все унаследованные значения свойств, заданные как в экземпляре, который является шаблоном, так и на более высоких уровнях композиции уровня страницы и, следовательно, выше в логическом дереве. Чтобы наследование значений свойств осуществлялось согласованно в таких пределах, наследуемое свойство должно быть зарегистрировано как вложенное свойство, кроме того, необходимо следовать этому шаблону, если требуется определить пользовательское свойство зависимостей с поведением наследования свойств. Точное дерево, используемое для наследования свойств, не может быть полностью предсказано вспомогательным служебным методом класса даже во время выполнения. Дополнительные сведения см. в разделе [Наследование значения свойства](property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a>Визуальное дерево  
 В дополнение к концепции логического дерева в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] также существует концепция визуального дерева. Визуальное дерево описывает структуру визуальных объектов, представленные как <xref:System.Windows.Media.Visual> базового класса. При написании шаблона для элемента управления следует определить или переопределить визуальное дерево, применяемое для данного элемента управления. Визуальное дерево также представляет интерес для разработчиков, заинтересованных в контроле рисования на нижнем уровне по соображениям производительности и оптимизации. Слабым местом визуального дерева как части программирования стандартных приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] является то, что маршруты событий для перенаправленного события в большинстве случаев проходят по визуальному дереву, а не по логическому. Эта тонкость поведения перенаправленного события может быть не очевидна, если вы не являетесь автором элемента управления. Маршрутизация событий по визуальному дереву позволяет элементам управления, которые реализуют композицию на визуальном уровне, обрабатывать события или создавать установщики событий.  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a>Деревья, элементы содержимого и узлы содержимого  
 Элементы содержимого (классы, производные от <xref:System.Windows.ContentElement>) не являются частью визуального дерева; они не наследуются от <xref:System.Windows.Media.Visual> и не имеют визуального представления. Чтобы полностью отобразиться в пользовательском Интерфейсе, <xref:System.Windows.ContentElement> должен быть размещен в хранилище содержимого, которое является одновременно <xref:System.Windows.Media.Visual> и участником логического дерева. Обычно таким объектом является <xref:System.Windows.FrameworkElement>. Можно представить сайт содержимого в качестве "обозревателя" содержимого, который выбирает способ отображения содержимого в пределах области экрана, управляемой сайтом. При размещении содержимого оно может стать участником некоторых процессов дерева, которые обычно связаны с визуальным деревом. Как правило <xref:System.Windows.FrameworkElement> класс узла содержит код реализации, который добавляет все размещенные <xref:System.Windows.ContentElement> к маршруту события через подузлы логического дерева содержимого, даже если размещенное содержимое не является частью действительного визуального дерева. Это необходимо, чтобы <xref:System.Windows.ContentElement> можно источника перенаправленное событие, которое маршрутизирует к любому элементу, кроме самого себя.  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a>Прохождение по дереву  
 <xref:System.Windows.LogicalTreeHelper> Класс предоставляет <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, и <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> методы для логическому дереву. В большинстве случаев не следует проходить по логическому дереву существующих элементов управления, так как эти элементы управления почти всегда предоставляют свои логические дочерние элементы в качестве выделенного свойства коллекции, которое поддерживает доступ к коллекции, например `Add`, индексатор и т. д. Обход дерева является главным образом сценарий, который используется авторами элемента управления, которые решили не наследовать от предполагаемых шаблонов элемента управления, например <xref:System.Windows.Controls.ItemsControl> или <xref:System.Windows.Controls.Panel> где свойства коллекции уже определены, и которые планируют предоставляют свои собственные коллекции Поддержка свойств.  
  
 Визуальное дерево также поддерживает вспомогательный класс для прохождения визуального дерева — <xref:System.Windows.Media.VisualTreeHelper>. Визуальное дерево не так удобно предоставляется через свойства элемента управления, поэтому <xref:System.Windows.Media.VisualTreeHelper> класс является рекомендуемым способом прохода визуального дерева, если это необходимо для программного скрипта. Дополнительные сведения см. в разделе [Общие сведения об отрисовке графики в WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
>  Иногда необходимо проверять визуальное дерево применяемого шаблона. Необходимо соблюдать осторожность при использовании этого метода. Даже при проходе по визуальному дереву для элемента управления, в котором необходимо задать шаблон, потребитель элемента управления всегда можно изменить шаблон, задав <xref:System.Windows.Controls.Control.Template%2A> свойства в экземплярах и даже конечный пользователь может повлиять на применяемый шаблон путем изменения системной темы.  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a>Маршруты для маршрутизируемых событий как "дерево"  
 Как уже отмечалось ранее, маршрут любого заданного перенаправленного события проходит по одному предопределенному пути дерева, представляющего собой гибрид представлений визуального и логического деревьев. Маршрут события может проходить как по восходящей, так и по нисходящий в пределах дерева в зависимости от того, имеет ли перенаправленное событие нисходящую или восходящую маршрутизацию. Концепция маршрута события не имеет непосредственного вспомогательного класса, который может быть использован для "прохода" маршрута события независимо от вызова фактически перенаправленного события. Класс, представляющий маршрут, <xref:System.Windows.EventRoute>, но методы этого класса обычно являются только для внутреннего использования.  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a>Словари и деревья ресурсов  
 Поиск по словарю ресурсов для всех `Resources`, определенных на странице, обычно проходит по логическому дереву. Объекты, которые не входят в логическое дерево, могут ссылаться на ресурсы с ключом, но последовательность поиска ресурса начинается с той точки, где объект подключен к логическому дереву. В WPF только узлы логического дерева могут иметь `Resources` свойство, содержащее <xref:System.Windows.ResourceDictionary>, поэтому не имеет смысла при обходе визуального дерева, который ищет ресурсы с ключом из <xref:System.Windows.ResourceDictionary>.  
  
 В то же время поиск ресурсов также можно расширить за пределы логического дерева. Для разметки приложения поиск ресурсов можно затем продолжить в словарях ресурсов на уровне приложений, поддержке тем и значениях системы, на которые ссылаются как на статические свойства или ключи. Сами темы также могут ссылаться на системные значения вне логического дерева тем, если ссылки на ресурсы являются динамическими. Дополнительные сведения о словарях ресурсов и логике поиска см. в разделе [Ресурсы XAML](xaml-resources.md).  
  
## <a name="see-also"></a>См. также

- [Общие сведения о входных данных](input-overview.md)
- [Общие сведения об отрисовке графики в WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Общие сведения о перенаправленных событиях](routed-events-overview.md)
- [Инициализация для элементов типа Object вне дерева объектов](initialization-for-object-elements-not-in-an-object-tree.md)
- [Архитектура WPF](wpf-architecture.md)
