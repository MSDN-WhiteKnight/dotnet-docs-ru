---
title: Безопасность свойства зависимости
ms.date: 03/30/2017
helpviewer_keywords:
- wrappers [WPF], access
- wrappers [WPF], security
- dependency properties [WPF], security
- security [WPF], wrappers
- validation [WPF], dependency properties
- dependency properties [WPF], access
- security [WPF], dependency properties
ms.assetid: d10150ec-90c5-4571-8d35-84bafa2429a4
ms.openlocfilehash: 85806ee9fb01cd2ca07697230c46a8847fdf8c6a
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2019
ms.locfileid: "59077476"
---
# <a name="dependency-property-security"></a>Безопасность свойства зависимости
Свойства зависимости, как правило, считаются открытыми. Суть системы свойств [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] такова, что дать гарантии безопасности о значении свойства зависимости невозможно.  

<a name="AccessSecurity"></a>   
## <a name="access-and-security-of-wrappers-and-dependency-properties"></a>Доступ к программам-оболочкам и свойствам зависимости и их безопасность  
 Как правило, свойства зависимости реализуются вместе со свойствами [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] программы-оболочки, которые упрощают получение или настройку свойства от экземпляра. Но программы-оболочки — на самом деле, лишь удобные способы реализации базового <xref:System.Windows.DependencyObject.GetValue%2A> и <xref:System.Windows.DependencyObject.SetValue%2A> статические вызовы, которые используются при взаимодействии со свойствами зависимости. Другими словами, свойства предоставляются как свойства [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], поддерживаемые свойством зависимости, а не закрытым полем. Механизмы безопасности, применяемые к программам-оболочкам, не поддерживают параллели между поведением системы свойств и доступом базового свойства зависимости. Помещение требования безопасности на оболочку помешает только использованию удобного метода, но не блокирует вызовы <xref:System.Windows.DependencyObject.GetValue%2A> или <xref:System.Windows.DependencyObject.SetValue%2A>. Аналогично: размещение защищенного или закрытого уровня доступа в программе-разработчике не обеспечивает эффективную защиту.  
  
 При написании собственных свойств зависимости необходимо объявить программы-оболочки и <xref:System.Windows.DependencyProperty> поле идентификатора как открытые элементы, чтобы вызывающие объекты не получали противоречивую информацию об истинном уровне доступа этого свойства (из-за его хранилища, реализовано как свойство зависимостей).  
  
 Для настраиваемого свойства зависимости, можно зарегистрировать свойство как свойство зависимостей только для чтения, и это обеспечивают эффективные способы предотвратить устанавливаемое любым пользователем, не содержит ссылку на свойство <xref:System.Windows.DependencyPropertyKey> для этого свойства. Дополнительные сведения см. в разделе [Свойства зависимостей "только для чтения"](read-only-dependency-properties.md).  
  
> [!NOTE]
>  Объявление <xref:System.Windows.DependencyProperty> закрытого поля идентификатора не запрещено и он может быть использован для уменьшения немедленно предоставляемого пространства имен пользовательского класса, но такое свойство не считается «private», в том же смысле, как [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] язык определения определяют этот уровень доступа, по причинам, описанным в следующем разделе.  
  
<a name="PropertySystemExposure"></a>   
## <a name="property-system-exposure-of-dependency-properties"></a>Предоставление системы свойств свойствам зависимости  
 Он обычно не имеет смысла, и это ложная для объявления <xref:System.Windows.DependencyProperty> как любого уровня доступа, отличный от открытого. Такая настройка уровня доступа просто лишит возможности получить ссылку на экземпляр из объявляющего класса. Но существует несколько аспектов системы свойств, который будет возвращать <xref:System.Windows.DependencyProperty> как средства для идентификации конкретного свойства, как он существует на экземпляре класса или экземпляре производного класса, и этот идентификатор является по-прежнему можно использовать в <xref:System.Windows.DependencyObject.SetValue%2A> даже вызвать Если исходный статический идентификатор объявляется неоткрытым. Кроме того <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> виртуальные методы получают сведения о любом существующем свойстве зависимости, которое изменило значение. Кроме того <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> метод возвращает идентификаторы для любого свойства в экземплярах с локально заданное значение.  
  
### <a name="validation-and-security"></a>Проверка и безопасность  
 Применение требований <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> и ожидается сбой проверки при сбое требования для предотвращения задаваемое свойство не является достаточно безопасным механизмом. Реализацию недействительности заданного значения регламентирует <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> может подавляться вредоносные вызывающие объекты, если эти вызывающие объекты работают внутри домена приложения.  
  
## <a name="see-also"></a>См. также

- [Пользовательские свойства зависимостей](custom-dependency-properties.md)
