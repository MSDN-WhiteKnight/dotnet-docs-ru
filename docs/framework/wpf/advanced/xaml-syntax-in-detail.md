---
title: Подробное описание синтаксиса XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: bf4118c6e811f409715b7b6684851b8b3e8bbb25
ms.sourcegitcommit: 558d78d2a68acd4c95ef23231c8b4e4c7bac3902
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59298894"
---
# <a name="xaml-syntax-in-detail"></a>Подробное описание синтаксиса XAML
В этом разделе определяются термины, которые используются для описания элементов синтаксиса XAML. Эти термины часто используются в оставшейся части этой документации, в документации по WPF, в частности, так и для других платформ, использующих XAML или основные понятия XAML, включаемые поддержки языка XAML на уровне System.Xaml. Этот раздел расширяет базовую терминологию, представленную в разделе [Обзор XAML (WPF)](xaml-overview-wpf.md).  

<a name="the_xaml_language_specification"></a>   
## <a name="the-xaml-language-specification"></a>В спецификации языка XAML  
 Синтаксическая терминология XAML, заданные здесь также определяется или на которые существуют ссылки в спецификации языка XAML. XAML — это язык на основе XML и ниже или расширяет структурным правилам XML. Некоторые термины общий или основан на терминологии, используемой при описании языка XML или объектную модель документа XML.  
  
 Дополнительные сведения о спецификации языка XAML, скачайте [ \[MS-XAML\] ](https://go.microsoft.com/fwlink/?LinkId=114525) из центра загрузки Майкрософт.  
  
<a name="xaml_and_clr"></a>   
## <a name="xaml-and-clr"></a>XAML и среда CLR  
 XAML — это язык разметки. [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], Как следует из названия, обеспечивает выполнение среды выполнения. XAML по себе не является одним из распространенных языков, которые напрямую используется средой выполнения CLR. Вместо этого можно считать из XAML поддержкой свою собственную систему типов. Конкретной системе синтаксического анализа XAML, который используется платформой WPF основана на среде CLR и системы типов среды CLR. Типы XAML сопоставляются с типами среды CLR для создания представления времени выполнения при синтаксическом анализе XAML для WPF. По этой причине в оставшейся части обсуждения синтаксиса в этом документе будут включены ссылки на системе типов CLR, несмотря на то, что эквивалентный синтаксис обсуждения в спецификации языка XAML — нет. (На уровне спецификации языка XAML, типы XAML могут быть сопоставлены для любой другой системе типов, которого не нужно быть среды CLR, но это потребует создания и использования разных средства синтаксического анализа XAML.)  
  
#### <a name="members-of-types-and-class-inheritance"></a>Члены типов и наследование классов  
 Свойства и события, что они отображаются как члены XAML [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] , часто наследуются от базовых типов. Например, рассмотрим следующий пример: `<Button Background="Blue" .../>`. <xref:System.Windows.Controls.Control.Background%2A> Является свойство не сразу же объявленного на <xref:System.Windows.Controls.Button> класса, если вы посмотрите на определение класса, результаты отражения или документации по. Вместо этого <xref:System.Windows.Controls.Control.Background%2A> наследуется от базового <xref:System.Windows.Controls.Control> класса.  
  
 Поведение наследования класса [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] элементы XAML, это существенно отличается от схемы-интерпретации XML-разметку. Наследование классов может стать сложной задачей, особенно в том случае, если промежуточные базовые классы являются абстрактными, или при использовании интерфейсов. Это одна из причин, набор элементов XAML и их допустимых атрибутов получается сложный для представления точно и полностью с помощью типов схемы, которые обычно используются для [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] программирования, таких как формат DTD или XSD. Другая причина заключается в возможности расширения и функции сопоставления типов языка XAML сам препятствуют полноте представления допустимых типов и членов.  
  
<a name="object_element_syntax"></a>   
## <a name="object-element-syntax"></a>Синтаксис объектных элементов  
 *Синтаксис элемента объекта* приведен синтаксис разметки XAML, который создает экземпляр класса среды CLR или структуры путем объявления элемента XML. Этот синтаксис похож на синтаксис элемента других языков разметки, такие как HTML. Синтаксис объектных элементов начинается с левой угловой скобки (\<), а затем немедленно имя типа класса или структуры, создание экземпляров. Ноль или более пробелов можно следовать имя типа и ноль или более атрибутов также могут объявляться с одним или несколькими пробелами, отделяя каждое имя атрибута элемента объекта = пару «значение». Наконец одно из следующих должен иметь значение true:  
  
-   Элемент и тег должны быть закрыты с косой черты (/), после чего сразу правой угловой скобки (>).  
  
-   Открывающий тег должен выполнять правой угловой скобки (>). Другие элементы объектов, свойств элементов или внутренний текст, можно выполнить в открывающий тег. Точно какое содержимое может содержаться здесь обычно ограничивается объектной модели элемента. Эквивалентный закрывающий тег для элемента объекта необходимо также существуют в правильной вложенности и балансировать нагрузку с других открывающей и закрывающей парой тегов.  
  
 XAML в соответствии с реализацией .NET содержит набор правил, которые сопоставляют элементы объекта с типами, атрибуты свойств или событий и пространства имен XAML среды CLR и сборки. WPF и .NET Framework, элементы объекта XAML сопоставляются с [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] типов, как определено в ссылочных сборках, а атрибуты сопоставляются члены этих типов. При ссылке на тип среды CLR в XAML, у вас есть доступ к наследуемые члены этого типа также.  
  
 Например, ниже приведен синтаксис объектных элементов, который создает новый экземпляр класса <xref:System.Windows.Controls.Button> класса, а также задает <xref:System.Windows.FrameworkElement.Name%2A> атрибут и значение для этого атрибута:  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 Ниже приведен синтаксис объектных элементов, которая также включает синтаксиса свойства содержимого XAML. Внутренний текст, содержащийся в будет использоваться для задания <xref:System.Windows.Controls.TextBox> свойства содержимого XAML, <xref:System.Windows.Controls.TextBox.Text%2A>.  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a>Модели содержимого  
 Класс может поддерживать использование в качестве элемента объекта XAML с точки зрения синтаксиса, но этот элемент будет работать должным образом в приложении или на странице только при ее размещении в ожидаемое положение в целом содержимого дерева модели или элемент. Например <xref:System.Windows.Controls.MenuItem> следует обычно размещаться только как дочерний <xref:System.Windows.Controls.Primitives.MenuBase> производного класса, такие как <xref:System.Windows.Controls.Menu>. Содержимое модели для определенных элементов описаны как часть "Примечания" на страницах класса для элементов управления и других [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] классы, которые можно использовать в качестве элементов XAML.  
  
<a name="properties_of_object_elements"></a>   
## <a name="properties-of-object-elements"></a>Свойств объектных элементов  
 Свойства в XAML задаются с помощью разнообразных возможных синтаксисов. Какой синтаксис может использоваться для конкретного свойства будет зависеть от базовых характеристик системы тип свойства, которое устанавливается.  
  
 Задавая значения свойств, добавляемый функции и характеристики объектов, которые существуют в графе объекта, время выполнения. Начальное состояние объекта, созданного из элемента объекта основан на поведение конструктора по умолчанию. Как правило приложение будет использовать отличные от полностью экземпляр по умолчанию для любого объекта.  
  
<a name="attribute_syntax_properties"></a>   
## <a name="attribute-syntax-properties"></a>Синтаксис атрибутов (свойства)  
 Синтаксис атрибутов — это синтаксис разметки XAML, который задает значение для свойства путем объявления атрибута в элементе существующего объекта. Имя атрибута должно соответствовать имени элемента среды CLR, свойства класса, поддерживающего соответствующий элемент объекта. Имя атрибута следует оператор присваивания (=). Значение атрибута должно быть строкой, заключенной в кавычки.  
  
> [!NOTE]
>  Разные кавычки можно использовать для размещения литеральный символ кавычки в атрибут. Для экземпляра одинарные кавычки можно использовать как средство для объявления строка, содержащая символ двойной кавычки внутри него. Используются одинарные или двойные кавычки, следует ли использовать пары открывающих и закрывающих строки значения атрибута. Доступны также escape-последовательности и другие методы для обойти ограничения, накладываемые любой отдельный синтаксис XAML. См. в разделе [сущности знаков XML и XAML](../../xaml-services/xml-character-entities-and-xaml.md).  
  
 Чтобы задать с помощью синтаксиса атрибутов, свойство должен быть открытым и доступным для записи. Значение свойства в системе резервных типов должен быть типом значения или должен быть ссылочный тип, который можно создать экземпляр или ссылается на обработчик XAML, обратившись к соответствующему резервного типа.  
  
 Для событий WPF XAML событие, которое указывается как имя атрибута должен быть открытым и иметь открытый делегат.  
  
 Свойства или события, необходимо быть членом класса или структуры, экземпляр которого создается, содержащего элемента объекта.  
  
### <a name="processing-of-attribute-values"></a>Обработка значений атрибутов  
 Строковое значение, содержащееся в открывающие и закрывающие кавычки, обрабатывается обработчиком XAML. Режим обработки по умолчанию для свойств, определяется тип базового свойства среды CLR.  
  
 Значение атрибута заполняется одним из следующих значений, используя этот порядок обработки:  
  
1. Если обработчик XAML обнаруживает фигурную скобку или объектный элемент, производный от <xref:System.Windows.Markup.MarkupExtension>, то расширение разметки, на которую указывает ссылка, вычисляется раньше, вместо того, чтобы обработка значения как строка и объект, возвращаемый в расширение разметки используется в качестве значение. Во многих случаях объект, возвращенный расширение разметки будет ссылаться на существующий объект или выражение, вычисление которого откладывается до времени выполнения и не является объектом с вновь созданным экземпляром.  
  
2. Если свойство объявлено с атрибутами <xref:System.ComponentModel.TypeConverter>, или тип значения этого свойства объявлен с атрибутами <xref:System.ComponentModel.TypeConverter>, строковое значение атрибута отправляется в преобразователь типа в качестве входных данных преобразования, и преобразователь вернет новый экземпляр объекта.  
  
3. Если не <xref:System.ComponentModel.TypeConverter>, выполняется попытка прямого преобразования в тип свойства. Последним уровнем является прямое преобразование значение собственного средства синтаксического анализа между типы-примитивы языка XAML, или проверка имен именованных констант в перечислении (средство синтаксического анализа. затем обращается к совпадающие значения).  
  
#### <a name="enumeration-attribute-values"></a>Перечисление значений атрибутов  
 Перечисления в XAML действительности обрабатываются средства синтаксического анализа XAML, а члены перечисления должны быть заданы путем указания имени строки в одной из именованных констант перечисления.  
  
 Для значений перечисления nonflag собственное поведение является обработки строки значения атрибута и разрешить его в одно из значений перечисления. Перечисление не указан в формате *перечисления*. *Значение*, как это делается в коде. Вместо этого указать только *значение*, и *перечисления* определяется по типу свойства. При указании атрибута в *перечисления*. *Значение* формы, он будет разрешаться правильно.  
  
 Для флагового перечисления на основе поведения <xref:System.Enum.Parse%2A?displayProperty=nameWithType> метод. Можно указать несколько значений для флагового перечисления, все значения разделены запятыми. Тем не менее нельзя объединять значения перечисления, которые не являются flagwise. Например, нельзя использовать синтаксис с запятой для начала создания <xref:System.Windows.Trigger> , выступающий в несколько условий перечисления nonflag:  
  
```  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 В WPF редки флагового перечисления, которые поддерживают атрибуты, которые можно задать в XAML. Тем не менее, одно перечисление является <xref:System.Windows.Media.StyleSimulations>. Может например, используется синтаксис с разделителями запятыми флагового атрибутов для примера, приведенного в разделе «Примечания» для изменения <xref:System.Windows.Documents.Glyphs> класса; `StyleSimulations = "BoldSimulation"` может стать `StyleSimulations = "BoldSimulation,ItalicSimulation"`. <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> является другим свойством, где можно указать несколько значений перечисления. Тем не менее, это свойство может быть особый случай, так как <xref:System.Windows.Input.ModifierKeys> перечисление поддерживает собственный тип преобразователя. Преобразователь типов для модификаторов использует знак плюс (+) в качестве разделителя, а не запятая (,). Это преобразование поддерживает традиционный синтаксис представления сочетания клавиш в программировании Microsoft Windows, например «Ctrl + Alt».  
  
### <a name="properties-and-event-member-name-references"></a>Свойства и ссылки на имя члена события  
 При указании атрибута можно ссылаться на любое свойство или событие, которое существует в качестве члена типа среды CLR, когда экземпляр для содержащего элемента объекта.  
  
 Или можно ссылаться на вложенное свойство или событие, независимо от содержащего элемента объекта. (Вложенные свойства обсуждаются в следующем разделе).  
  
 Также можно задать имя любого события из любого объекта, доступного через пространство имен по умолчанию с помощью *typeName*. *событие* частично проверенное имя; этот синтаксис поддерживает присоединение обработчиков для перенаправленных событий, где обработчик предназначен для обработки перенаправления событий из дочерних элементов, но родительский элемент не имеет это событие в своей таблице элементов. Этот синтаксис похож на синтаксис вложенного события, но события не является true присоединенное событие. Вместо этого вы ссылаетесь на событие с полным именем. Дополнительные сведения см. в разделе [Routed Events Overview](routed-events-overview.md).  
  
 В некоторых случаях имена свойств иногда предоставляются в качестве значения атрибута, а не имя атрибута. Имя этого свойства может также включать квалификаторы, такие как свойство, указанное в виде *Тип_владельца*. *dependencyPropertyName*. Этот сценарий характерен при написании стили или шаблоны в XAML. Правила обработки имен свойств, предоставленных в качестве значения атрибута отличаются и управляются по типу свойства, задаваемого или поведением, определенного WPF подсистем. Дополнительные сведения см. в разделе [Стилизация и использование шаблонов](../controls/styling-and-templating.md).  
  
 Другой вариант использования для имен свойств — Если значение атрибута описывает отношение свойство свойства. Эта функция используется для привязки данных и раскадровки целей и обеспечивается <xref:System.Windows.PropertyPath> класс и его преобразователя. Более полное описание семантики поиска, см. в разделе [синтаксис PropertyPath XAML](propertypath-xaml-syntax.md).  
  
<a name="property_element_syntax"></a>   
## <a name="property-element-syntax"></a>Синтаксис элемента свойства  
 *Синтаксис элемента свойства* является синтаксисом, который отличается от правил для элементов в базовом синтаксисе XML. В формате XML значение атрибута является де-факто является строкой, с единственным возможным вариантом используется формат кодировки строки. В XAML можно назначить другие элементы объекта в качестве значения свойства. Эта возможность обеспечивается синтаксиса элемента свойства. Вместо свойства, указанного как атрибут в теге элемента, свойство задается с помощью элемента открывающий тег в *сочетание elementTypeName*. *propertyName* формы, значение свойства, указанного в, а затем закрывается элемент свойства.  
  
 В частности, этот синтаксис начинается с левой угловой скобки (\<), а затем немедленно имя типа класса или структуры, содержащийся в синтаксис элемента свойства. Это сопровождается сразу следует точка (.), затем по имени свойства, затем правой угловой скобки (>). Как и в случае с синтаксисом атрибута, это свойство должно существовать в объявленный открытые члены указанного типа. Значение, присваиваемое свойству, содержащийся в элементе свойства. Как правило значение задается как один или несколько элементов объекта, поскольку указание объектов как значений — это сценарий, синтаксис элемента свойства предназначен адрес. Наконец, эквивалентный закрывающий тег, указав те же *сочетание elementTypeName*. *propertyName* сочетание должно быть указано в правильном вложении и балансе с другими тегами элемента.  
  
 Например, ниже приведен синтаксис элемента свойства для <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойство <xref:System.Windows.Controls.Button>.  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 Значение в элементе свойства также может быть задано как внутренний текст, в случаях, когда тип свойства, который указывается как примитивный тип значения, такие как <xref:System.String>, или перечисление, где указано имя. Эти два способа использования довольно редки, так как каждый из этих случаев также может использовать более простой синтаксис атрибута. Один из сценариев для заполнения элемента свойства со строкой — для свойств, которые не являются свойства содержимого XAML, но по-прежнему используются для представления текста пользовательского интерфейса и определенный символ пробела элементы, такие как символ перевода строки, необходимых в тексте пользовательского интерфейса. Синтаксис атрибута не может сохранять символ перевода строки, но синтаксис элемента свойства может, до тех пор, пока активен существенные пробелы (Дополнительные сведения см. в разделе [обработки в XAML пробелов](../../xaml-services/whitespace-processing-in-xaml.md)). Еще один сценарий, чтобы [x: Uid Directive](../../xaml-services/x-uid-directive.md) могут применяться к элементу свойство, отметив тем самым значение как значение, которое должно быть локализовано в WPF выходных данных BAML или с помощью других методов.  
  
 Элемент свойства не представлен в логическом дереве WPF. Элемент свойства — это лишь отдельный синтаксис для установки свойства, а не является элементом, который имеет экземпляр или резервный объект. (Дополнительные сведения о логическом дереве, см. в разделе [деревья в WPF](trees-in-wpf.md).)  
  
 Для свойств, поддерживающих синтаксис элемента и атрибута и свойство двумя типами синтаксиса обычно имеют один и тот же результат, несмотря на то, что тонкостей, таких как обработка пробельных символов может немного отличаться от синтаксиса.  
  
<a name="collection_syntax"></a>   
## <a name="collection-syntax"></a>Синтаксис коллекции  
 Спецификация XAML требует реализаций обработчиков XAML для идентификации свойств, где тип значения является коллекция. Общая реализация обработчика XAML в .NET основан на управляемом коде и средой CLR, и он определяет типы коллекций с помощью одного из следующих:  
  
-   Введите реализует <xref:System.Collections.IList>.  
  
-   Введите реализует <xref:System.Collections.IDictionary>.  
  
-   Тип является производным от <xref:System.Array> (Дополнительные сведения о массивах в XAML см. в разделе [расширение разметки x: Array](../../xaml-services/x-array-markup-extension.md).)  
  
 Если тип свойства является коллекцией, затем выведенный тип коллекции не требуется указывать в разметке в качестве объектного элемента. Вместо этого элементы, которые должны стать элементами коллекции, указываются как дочерние элементы элемента свойства. Каждый такой элемент вычисляется для объекта во время загрузки и добавить в коллекцию, вызвав метод `Add` метод неявной коллекции. Например <xref:System.Windows.Style.Triggers%2A> свойство <xref:System.Windows.Style> принимает специализированный тип коллекции <xref:System.Windows.TriggerCollection>, который реализует <xref:System.Collections.IList>. Это не обязательно создавать <xref:System.Windows.TriggerCollection> объектного элемента в разметке. Вместо этого укажите один или несколько <xref:System.Windows.Trigger> элементы как элементы в `Style.Triggers` элемента свойства, где <xref:System.Windows.Trigger> (или производного класса) — это тип, ожидаемый тип элемента для строго типизированным и неявное <xref:System.Windows.TriggerCollection>.  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 Свойство может быть типом коллекции и свойства содержимого XAML для этого типа и производных типов, как описано в следующем разделе этой статьи.  
  
 Элемент неявной коллекции создает элемент в представлении логического дерева, несмотря на то, что он не отображается в разметке как элемент. Обычно конструктор родительского типа выполняет создание экземпляра для коллекции, который является одним из его свойств и изначально пустая коллекция становится частью дерева объектов.  
  
> [!NOTE]
>  Универсальные интерфейсы списка и словаря (<xref:System.Collections.Generic.IList%601> и <xref:System.Collections.Generic.IDictionary%602>) не поддерживаются для обнаружения коллекции. Тем не менее, можно использовать <xref:System.Collections.Generic.List%601> класса в качестве базового класса, так как он реализует <xref:System.Collections.IList> напрямую, или <xref:System.Collections.Generic.Dictionary%602> как базовый класс, так как он реализует <xref:System.Collections.IDictionary> напрямую.  
  
 На страницах Справочник по .NET для типов коллекции этот синтаксис с намеренным заменяют объектного элемента для коллекции иногда отмечен в разделах синтаксиса XAML как неявного синтаксиса коллекции.  
  
 За исключением корневого элемента, каждый элемент объекта в файле XAML, который является вложенной как дочерний элемент другого элемента, подходит ли элемент, который является один или оба из следующих случаев: член неявного свойства коллекции своего родительского элемента , либо элемент, который задает значение свойства содержимого XAML для родительского элемента (XAML-содержимого, свойств, которые будут рассматриваться в следующем разделе). Другими словами связь родительских и дочерних элементов в разметке страницы действительно является один объект в корне, и каждый элемент объекта ниже корня является одним экземпляром, который предоставляет значение свойства родительского объекта, или один из элементов в пределах столбца lection, который также является значение свойства типа "коллекция" родительского элемента. Эта концепция единой корневой с XML и часто закрепляется в поведении API-интерфейсы, такие как Загрузка XAML <xref:System.Windows.Markup.XamlReader.Load%2A>.  
  
 Ниже приведен синтаксис с элементом объекта для коллекции (<xref:System.Windows.Media.GradientStopCollection>) задан явным образом.  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 Обратите внимание на то, что не всегда можно явно объявить коллекции. Например, попытка объявить <xref:System.Windows.TriggerCollection> явным образом в ранее показанном <xref:System.Windows.Style.Triggers%2A> пример завершится ошибкой. Явного объявления коллекции необходимо, что класс коллекции должен поддерживать конструктор по умолчанию, и <xref:System.Windows.TriggerCollection> не имеет конструктора по умолчанию.  
  
<a name="xaml_content_properties"></a>   
## <a name="xaml-content-properties"></a>Свойства содержимого XAML  
 Синтаксис содержимого XAML является синтаксисом, который действует только на классы, которые задают <xref:System.Windows.Markup.ContentPropertyAttribute> как часть объявления их класса. <xref:System.Windows.Markup.ContentPropertyAttribute> Ссылается на имя свойства, которое является свойством содержимого для данного типа элементов (включая производные классы). При обработке процессором XAML, все дочерние элементы или внутренний текст, найденные между открывающим и закрывающим тегами элемента объекта назначается в качестве значения свойства содержимого XAML для этого объекта. Вы можете задать явные элементы свойства для свойства содержимого, но такое использование обычно не показано в разделах синтаксиса XAML в справочнике по .NET. Явные/verbose метод имеет случайное значение для ясности в разметке или стиль разметки, но обычно целью свойства содержимого является упрощение разметки, чтобы элементы, интуитивно связанные как родители потомки могут быть вложенными напрямую. Теги элемента свойства для других свойств в элементе не заданы как «содержимое» в строгом определение языка XAML; они обрабатываются в порядке обработки средство синтаксического анализа XAML и не считаются «содержимое».  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a>Значения свойств содержимого XAML должны быть непрерывными  
 Значение свойства содержимого XAML должно быть задано полностью до или после любых других элементов свойств данного объектного элемента. Это верно, является ли значение свойства содержимого XAML указывается как строка или как один или несколько объектов. Например следующая разметка не выполняет анализ:  
  
```  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 Это неверно, так как этот синтаксис после внесения явные с использованием синтаксиса элемента свойства для свойства содержимого, то свойство content будет задано дважды:  
  
```xml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 Аналогично неверным примером является, если свойство содержимого представляет собой коллекцию, и дочерние элементы смешиваются с свойств элементов:  
  
```xml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>   
## <a name="content-properties-and-collection-syntax-combined"></a>Объединение свойства содержимого и синтаксиса коллекции  
 Чтобы принять более, чем элементов объекта в качестве содержимого, тип свойства содержимого обязательно должен быть типом коллекции. Как и в синтаксис элемента свойства для типов коллекций, обработчик XAML должен идентифицировать типы, которые являются типами коллекций. Если элемент имеет свойство содержимого XAML и тип свойства содержимого XAML является коллекцией, неявный тип коллекции не нужно указывать в разметке в качестве объектного элемента и свойства содержимого XAML необходимо указать как el свойство правления. Таким образом, видимая модель содержимого в разметке теперь могут иметь более одного дочернего элемента, назначенных в качестве содержимого. Ниже приведен синтаксис содержимого <xref:System.Windows.Controls.Panel> производного класса. Все <xref:System.Windows.Controls.Panel> производные классы установить свойство содержимого XAML, чтобы быть <xref:System.Windows.Controls.Panel.Children%2A>, что требует значение типа <xref:System.Windows.Controls.UIElementCollection>.  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 Обратите внимание, что ни элемент свойства для <xref:System.Windows.Controls.Panel.Children%2A> ни элемент для <xref:System.Windows.Controls.UIElementCollection> необходим в разметке. Это средство разработки XAML, чтобы рекурсивно содержащиеся элементы, определяющие [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] являются более интуитивно понятным образом представлены в виде дерева вложенных элементов с немедленного родительских и дочерних элементов элемента, не содержит промежуточных тегов элементов свойства или Коллекция объектов. На самом деле <xref:System.Windows.Controls.UIElementCollection> нельзя задавать явным образом в разметку как объектный элемент, намеренно. Так как является предназначен для использования только в качестве неявной коллекции, <xref:System.Windows.Controls.UIElementCollection> не предоставляет открытый конструктор по умолчанию и таким образом, не может быть создан в качестве объектного элемента.  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a>Совместное использование свойств элементов и элементов объекта в объект со свойством содержимого  
 В спецификации XAML объявляет, что обработчик XAML может применить объектные элементы, которые используются для заполнения свойства содержимого XAML в элементе объекта должны быть непрерывными что не могут смешиваться. Это ограничение, запрещающее смешивание элементов свойств и содержимого, обеспечивается [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] процессоры XAML.  
  
 Дочерний элемент объекта может иметь как первый немедленно разметка внутри элемента объекта. Затем можно ввести свойств элементов. Или можно указать один или несколько свойств элементов содержимого, а затем дополнительные элементы свойств. Но после элемента свойства следует за содержимым, нельзя добавлять последующее содержимое, можно добавить только свойств элементов.  
  
 Это содержимое и свойства элемента заказа требование не применяется к внутренний текст, используемый в качестве содержимого. Тем не менее это по-прежнему хорошего стиля разметки для сохранения внутреннего текста смежными, так как значащий пробел будет трудно обнаружить визуально в разметке, если элементы свойств смешиваются с внутренним текстом.  
  
<a name="xaml_namespaces"></a>   
## <a name="xaml-namespaces"></a>Пространства имен языка XAML  
 Ни один из предыдущих примеров синтаксиса указано пространство имен XAML, отличном от пространства имен XAML по умолчанию. В обычных [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] приложений, пространство имен XAML по умолчанию установлено значение [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] пространства имен. Можно указывать пространства имен XAML, отличном от пространства имен XAML по умолчанию и по-прежнему использовать аналогичный синтаксис. Но затем, в любом где именуется класс, который недоступен в пространстве имен XAML по умолчанию, имя этого класса должны начинаться с префикса пространства имен XAML как сопоставляются с соответствующим пространством имен CLR. Например `<custom:Example/>` является синтаксис объектных элементов для создания экземпляра `Example` класса, где пространство имен CLR, содержащее этот класс (и, возможно, данные внешней сборке, содержащей резервные типы) был ранее сопоставлен `custom` префикс.  
  
 Дополнительные сведения о пространствах имен XAML см. в разделе [пространства имен XAML и сопоставление пространств имен для WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a>Расширения разметки  
 XAML определяет программирования сущность, которая позволяет выйти за рамки обычной обработки процессором XAML строковых атрибутов или элементов объектов и откладывает обработку на вспомогательный класс расширения разметки. Символ, который определяет расширение разметки для обработчика XAML, при использовании синтаксиса атрибутов, открывающая фигурная скобка ({}), следуют любой символ, отличный от закрывающую фигурную скобку (}). Первая строка, следующая открывающая фигурная скобка должна ссылаться на класс, который предоставляет определенное расширение поведения, где ссылки можно пропустить подстроку «Extension», если эта подстрока является частью истинного имени класса. После этого может использоваться один пробел, и затем каждый последующий знак используется в качестве входных данных реализации расширения, вплоть до появления закрывающую фигурную скобку.  
  
 В реализации XAML в .NET используется <xref:System.Windows.Markup.MarkupExtension> абстрактного класса в качестве основы для всех расширений разметки, поддерживаемых [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] , а также других платформ или технологий. Расширения разметки, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] специально реализует часто предназначены для создания ссылок на другие существующие объекты или для предоставления отложенных ссылок на объекты, на которые будет вычисляться во время выполнения. Например, простая привязка данных WPF выполняется путем указания `{Binding}` расширения разметки вместо значения, которое обычно принимает определенное свойство. Большинство расширений разметки WPF включает синтаксис атрибута для свойств, где синтаксис атрибута бы в противном случае невозможно. Например <xref:System.Windows.Style> объект — довольно сложный тип, содержащий ряд вложенных объектов и свойств. Стили в WPF обычно определяются как ресурс в <xref:System.Windows.ResourceDictionary>и затем указываются с помощью одного из двух расширений разметки WPF, запрашивающих ресурс. Расширение разметки откладывает вычисление значения свойства для поиска ресурсов и обеспечивает предоставление значения <xref:System.Windows.FrameworkElement.Style%2A> свойство, тип <xref:System.Windows.Style>в атрибут синтаксис, как показано в следующем примере:  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 Здесь `StaticResource` идентифицирует <xref:System.Windows.StaticResourceExtension> класс, предоставляющий реализации расширения разметки. Следующая строка `MyStyle` используется в качестве входных данных для не по умолчанию <xref:System.Windows.StaticResourceExtension> конструктор, где параметр, принимаемый из строки расширения объявляет запрашиваемый <xref:System.Windows.ResourceKey>. `MyStyle` должен быть [x: Key](../../xaml-services/x-key-directive.md) значение <xref:System.Windows.Style> , определенный как ресурс. [Расширение разметки StaticResource](staticresource-markup-extension.md) использования запросов использования ресурсов для предоставления <xref:System.Windows.Style> значение свойства через логику поиска статических ресурсов во время загрузки.  
  
 Подробнее о расширениях разметки см. в разделе [Расширения разметки и XAML WPF](markup-extensions-and-wpf-xaml.md). Ссылка расширения разметки и другие XAML, программирование функций, включенных в общей реализации .NET XAML, см. в разделе [пространства имен XAML (x:) Возможности языка](../../xaml-services/xaml-namespace-x-language-features.md). WPF-расширениях разметки см. в разделе [расширения XAML WPF](wpf-xaml-extensions.md).  
  
<a name="attached_properties"></a>   
## <a name="attached-properties"></a>Вложенные свойства  
 Присоединенные свойства являются понятием программирования, представленным в XAML, при котором свойства можно во владении и определением определенного типа, но установлен в качестве атрибутов или свойств элементов для любого элемента. Основной сценарий что присоединенные свойства предназначены для является разрешение дочерним элементам в структуре разметки для передачи сведений в родительском элементе без необходимости сложного распределения объектной модели для всех элементов. И наоборот можно использовать вложенные свойства родительскими элементами для передачи сведений дочерних элементов. Дополнительные сведения о назначении вложенных свойств и создании собственных присоединенных свойств см. в разделе [зависимостей](attached-properties-overview.md).  
  
 Вложенные свойства используют синтаксис, который внешне напоминает синтаксис элемента свойства, в котором также указывается *typeName*. *propertyName* сочетания. Однако имеется два важных отличия.  
  
-   Можно использовать *typeName*. *propertyName* сочетания даже при задании присоединенное свойство через синтаксис атрибутов. Присоединенные свойства являются единственным вариантом, если уточнение имени свойства является обязательным в синтаксис атрибутов.  
  
-   Можно также использовать синтаксис элемента свойства для присоединенных свойств. Однако для обычного синтаксиса элемента свойства *typeName* указать, является элементом объекта, содержащим элемент свойства. Если вы ссылаетесь на вложенное свойство, то *typeName* — это класс, который определяет присоединенное свойство, не содержащий его элемент объекта.  
  
<a name="attached_events"></a>   
## <a name="attached-events"></a>Вложенные события  
 Прикрепленные события – это другой понятие программирования, представленное в XAML, где события могут быть определены с помощью определенных типов, но могут быть присоединены обработчики для любого объектного элемента. В реализации WOF часто тип, который определяет присоединенное событие является статическим типом, определяющим службу, и иногда эти присоединенные события предоставляются с помощью псевдонимов перенаправленных событий в типах, которые предоставляют службу. Обработчики для присоединенных событий указываются с помощью синтаксиса атрибутов. Как с помощью присоединенных событий, синтаксис атрибута расширен для присоединенных событий Разрешить *typeName*. *eventName* использования, где *typeName* — это класс, предоставляющий `Add` и `Remove` методы доступа обработчика событий для присоединенного события инфраструктуры, и *eventName* является именем события.  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>   
## <a name="anatomy-of-a-xaml-root-element"></a>Составляющие корневого элемента XAML  
 В следующей таблице показаны типичные XAML корневого элемента, отображающее определенные атрибуты корневого элемента:  
  
|||  
|-|-|  
|`<Page`|Открытие объектного элемента корневого элемента|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|Значение по умолчанию ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) пространства имен XAML|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|Пространство имен XAML языка XAML|  
|`x:Class="ExampleNamespace.ExampleCode"`|Объявление разделяемого класса, который подключается к любой кода разметки, определенные для разделяемого класса|  
|`>`|Конец для корневого элемента объекта. Объект еще не закрыт, потому что элемент содержит дочерние элементы|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>   
## <a name="optional-and-nonrecommended-xaml-usages"></a>Данные об использовании необязательно и нежелательные XAML  
 В следующих разделах использований XAML, которые технически поддерживаются процессорами XAML, однако создают уровень детализации или другие эстетически проблемы, мешающие осталось удобное для восприятия, при разработке приложений, которые содержат XAML источников файлов XAML.  
  
### <a name="optional-property-element-usages"></a>Необязательное использование элемента свойства  
 Необязательное использование элемента свойства относится явное объявление свойств содержимого элементов, обработчик XAML рассматривает как неявные. Например, при объявлении содержимое <xref:System.Windows.Controls.Menu>, вы можете явно объявить <xref:System.Windows.Controls.ItemsControl.Items%2A> коллекцию <xref:System.Windows.Controls.Menu> как `<Menu.Items>` тега элемента свойства и поместить каждый <xref:System.Windows.Controls.MenuItem> в `<Menu.Items>`, а чем использование неявных поведение обработчика XAML, все дочерние элементы <xref:System.Windows.Controls.Menu> должно быть <xref:System.Windows.Controls.MenuItem> и помещаются в <xref:System.Windows.Controls.ItemsControl.Items%2A> коллекции. Иногда необязательное использование помогает визуально уточнить структуру объектов, представленных в разметке. Или иногда использовании явные свойства элемента можно избежать разметки, технически функциональной, но визуально вызывает путаницу, таких как вложенные расширения разметки в значении атрибута.  
  
### <a name="full-typenamemembername-qualified-attributes"></a>Полный typeName.memberName указанием атрибуты  
 *TypeName*. *имя пользователя* форме атрибут фактически работает более универсально, чем просто перенаправленного события. В остальных случаях эта форма является избыточной, но следует избегать, для поддержания стиля разметки и удобства чтения. В следующем примере каждое из трех ссылок на <xref:System.Windows.Controls.Control.Background%2A> атрибут полностью эквивалентны:  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 `Button.Background` работает, поскольку полный поиск этого свойства в <xref:System.Windows.Controls.Button> успешно (<xref:System.Windows.Controls.Control.Background%2A> унаследованного от элемента управления) и <xref:System.Windows.Controls.Button> объектного элемента класса или базового класса. `Control.Background` работает, потому что <xref:System.Windows.Controls.Control> класс фактически определяет <xref:System.Windows.Controls.Control.Background%2A> и <xref:System.Windows.Controls.Control> является <xref:System.Windows.Controls.Button> базового класса.  
  
 Тем не менее следующие *typeName*. *имя пользователя* пример формы, не работает и таким образом маркерами комментария:  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <xref:System.Windows.Controls.Label> другой класс, производный из <xref:System.Windows.Controls.Control>, и если вы указали `Label.Background` в <xref:System.Windows.Controls.Label> объектного элемента, это использование могло бы работать. Тем не менее так как <xref:System.Windows.Controls.Label> не класса или базового класса <xref:System.Windows.Controls.Button>, заданное поведение обработчика XAML является последующее `Label.Background` как присоединенное свойство. `Label.Background` не является доступным вложенным свойством, и такое использование не удается.  
  
### <a name="basetypenamemembername-property-elements"></a>baseTypeName.memberName свойств элементов  
 В аналогичный способ как *typeName*. *имя пользователя* форма работает для синтаксиса атрибутов *Имя_базового_типа*. *имя пользователя* работает для синтаксиса элемента свойства. Например следующий синтаксис работает:  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 Здесь элемент свойства задан как `Control.Background` несмотря на то, что содержится в элементе свойства `Button`.  
  
 Но так же, как *typeName*. *имя пользователя* формы для атрибутов, *Имя_базового_типа*. *имя пользователя* находится в плохом стиле в разметке, и ее следует избегать.  
  
## <a name="see-also"></a>См. также

- [Обзор XAML (WPF)](xaml-overview-wpf.md)
- [Пространство имен XAML (x:) Возможности языка](../../xaml-services/xaml-namespace-x-language-features.md)
- [Расширения XAML WPF](wpf-xaml-extensions.md)
- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [TypeConverters и XAML](typeconverters-and-xaml.md)
- [Код XAML и пользовательские классы для WPF](xaml-and-custom-classes-for-wpf.md)
