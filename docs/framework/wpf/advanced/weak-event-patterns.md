---
title: Шаблоны слабых событий
ms.date: 03/30/2017
helpviewer_keywords:
- weak event pattern implementation [WPF]
- event handlers [WPF], weak event pattern
- IWeakEventListener interface [WPF]
ms.assetid: e7c62920-4812-4811-94d8-050a65c856f6
ms.openlocfilehash: e0cd6837de626fa6bcd560811c6a70f7f6604daa
ms.sourcegitcommit: 558d78d2a68acd4c95ef23231c8b4e4c7bac3902
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59316171"
---
# <a name="weak-event-patterns"></a>Шаблоны слабых событий
В приложениях возможно, что обработчики, присоединенные к источникам событий, не будут уничтожены в соответствии с объектом прослушиватель, который присоединил обработчик к источнику. Это может привести к утечке памяти. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] представляет шаблон, который может использоваться для решения этой проблемы путем предоставления выделенного класса диспетчера для конкретных событий и реализации интерфейса прослушивателей для данного события. Этот шаблон разработки называется *шаблоне слабых событий*.  
  
## <a name="why-implement-the-weak-event-pattern"></a>Почему реализация шаблона слабых событий?  
 Прослушивание событий может привести к утечке памяти. Обычным методом для прослушивания событий — использовать синтаксис конкретного языка, который присоединяет обработчик к событию на источнике. Например, в C#, что синтаксис является: `source.SomeEvent += new SomeEventHandler(MyEventHandler)`.  
  
 Этот метод создает строгую ссылку из источника события для прослушивателя событий. Обычно присоединение обработчика события для прослушивателя вызывает прослушиватель для времени жизни объекта, зависит от времени существования объекта источника (если не будет явно удален обработчик событий). Но в некоторых случаях вы можете время жизни объекта прослушивателя управляются другими факторами, например, принадлежит ли он в настоящее время к визуальному дереву приложения, а не по времени существования источника. Каждый раз, когда время жизни объекта источника выходит за пределы время жизни объекта-прослушивателя, обычный шаблон события приводит к утечке памяти: прослушиватель хранится дольше, чем планировалось.  
  
 Шаблон слабых событий предназначен для решения проблемы утечки памяти. Шаблон слабых событий можно использовать всякий раз, когда прослушиватель должен зарегистрироваться для получения события, но прослушиватель не знает, явно отмены регистрации. Шаблон слабых событий можно также использоваться всякий раз, когда время жизни объекта-источника превышает время существования полезных объект прослушивателя. (В этом случае *полезные* определяется пользователем.) Шаблон слабых событий позволяет прослушивателя, чтобы зарегистрироваться и получить событие, не затрагивая характеристики времени жизни объекта прослушивателя любым способом. По сути неявная ссылка из источника не определяет, является ли прослушиватель под сбор мусора. Ссылка является слабой ссылки, таким образом система именования шаблона слабых событий и в сопутствующих [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]. Прослушиватель может быть собран как мусор или в противном случае уничтожения, а источник может продолжить без сохранения только что уничтоженный обработчика ссылок на объект.  
  
## <a name="who-should-implement-the-weak-event-pattern"></a>Кто должен реализовывать шаблон слабых событий?  
 Реализация шаблона слабых событий представляет интерес в первую очередь для разработчиков элементов управления. Как разработчик элемента управления — во многом за поведение и включения элемента управления и его влияние на приложения, в которых она вставляется. Это включает и поведения времени существования объекта элемента управления, в частности, обработка описанной проблемы утечки памяти.  
  
 Некоторые сценарии изначально подходят для применения этого шаблона слабых событий. Одним из таких сценариев является привязка данных. В привязке данных, довольно часто для исходного объекта, была полностью независима от объект-прослушиватель, который является целевым объектом привязки. Многие аспекты [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] привязки данных уже имеют шаблон слабых событий, примененный в порядок реализации событий.  
  
## <a name="how-to-implement-the-weak-event-pattern"></a>Реализация шаблона слабых событий  
 Реализация шаблона слабых событий тремя способами. В следующей таблице перечислены три подхода и приводятся рекомендации по при их использованию.  
  
|Подход|Когда следует реализовать|  
|--------------|-----------------------|  
|Использовать существующий класс manager слабых событий|Если вы хотите подписаться на событие имеет соответствующий <xref:System.Windows.WeakEventManager>, с помощью существующего диспетчера слабых событий. Список диспетчеров слабых событий, которые входят в состав WPF, см. в разделе иерархии наследования в <xref:System.Windows.WeakEventManager> класса. Так, как диспетчеры включены слабых событий ограничены, возможно, необходимо будет выбрать один из других подходов.|  
|Использовать класс manager универсального слабых событий|Используйте универсальный <xref:System.Windows.WeakEventManager%602> существующей <xref:System.Windows.WeakEventManager> не доступен, требуется, чтобы легко реализовать, и вы не занимается увеличивает производительность работы. Универсальный <xref:System.Windows.WeakEventManager%602> является менее эффективным, чем диспетчер слабых событий существующих или пользовательских. Например универсальный класс выполняет дополнительные отражение для обнаружения событий, имени события. Кроме того, код для регистрации событий с помощью универсального <xref:System.Windows.WeakEventManager%602> является более подробным по сравнению с помощью существующего или пользовательских <xref:System.Windows.WeakEventManager>.|  
|Создайте класс manager пользовательских слабых событий|Создание пользовательского <xref:System.Windows.WeakEventManager> существующей <xref:System.Windows.WeakEventManager> недоступен и нужно, чтобы повышения эффективности работы. С помощью пользовательского <xref:System.Windows.WeakEventManager> подписаться на событие будет более эффективной, но вы затраты на создавать больше кода в начале.|  
|С помощью диспетчера сторонних слабых событий|NuGet имеет [несколько диспетчеров слабых событий](https://www.nuget.org/packages?q=weak+event+manager&prerel=false) и многие платформы WPF также поддерживать шаблон (например, см. в разделе [документации призмы подписка слабо связанных событий](https://github.com/PrismLibrary/Prism-Documentation/blob/master/docs/wpf/Communication.md#subscribing-to-events)).|

 В следующих разделах рассматривается реализация шаблона слабых событий.  Для целей данного обсуждения Чтобы подписаться на событие имеет следующие характеристики.  
  
-   Имя события находится `SomeEvent`.  
  
-   Событие `EventSource` класс.  
  
-   Обработчик событий имеет тип: `SomeEventEventHandler` (или `EventHandler<SomeEventEventArgs>`).  
  
-   Событие передает параметр типа `SomeEventEventArgs` обработчикам событий.  
  
### <a name="using-an-existing-weak-event-manager-class"></a>С помощью существующего класса слабого диспетчера событий  
  
1. Найдите событие слабые manager.  
  
     Список диспетчеров слабых событий, которые входят в состав WPF, см. в разделе иерархии наследования в <xref:System.Windows.WeakEventManager> класса.  
  
2. Использование нового диспетчера слабых событий вместо обычной привязке события.  
  
     Например, если ваш код использует следующий шаблон для подписки на событие:  
  
    ```  
    source.SomeEvent += new SomeEventEventHandler(OnSomeEvent);  
    ```  
  
     Измените его на следующий шаблон:  
  
    ```  
    SomeEventWeakEventManager.AddHandler(source, OnSomeEvent);  
    ```  
  
     Аналогично Если ваш код использует следующий шаблон для отмены подписки на событие:  
  
    ```  
    source.SomeEvent -= new SomeEventEventHandler(OnSome);  
    ```  
  
     Измените его на следующий шаблон:  
  
    ```  
    SomeEventWeakEventManager.RemoveHandler(source, OnSomeEvent);  
    ```  
  
### <a name="using-the-generic-weak-event-manager-class"></a>Использование универсального класса слабого диспетчера событий  
  
1. Использование универсального <xref:System.Windows.WeakEventManager%602> класса вместо обычной привязке события.  
  
     При использовании <xref:System.Windows.WeakEventManager%602> Чтобы зарегистрировать прослушивателей событий, необходимо указать источник события и <xref:System.EventArgs> тип как параметры типа для класса и вызове <xref:System.Windows.WeakEventManager%602.AddHandler%2A> как показано в следующем коде:  
  
    ```  
    WeakEventManager<EventSource, SomeEventEventArgs>.AddHandler(source, "SomeEvent", source_SomeEvent);  
    ```  
  
### <a name="creating-a-custom-weak-event-manager-class"></a>Создание пользовательского класса слабого диспетчера событий  
  
1. Скопируйте следующий шаблон класса в проект.  
  
     Этот класс наследует от <xref:System.Windows.WeakEventManager> класса.  
  
     [!code-csharp[WeakEvents#WeakEventManagerTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/WeakEvents/CSharp/WeakEventManagerTemplate.cs#weakeventmanagertemplate)]  
  
2. Замените `SomeEventWeakEventManager` с собственным именем.  
  
3. Замените имена трех, описанные ранее, с соответствующими именами для события. (`SomeEvent`, `EventSource`, и `SomeEventEventArgs`)  
  
4. Настроить видимость (открытый / внутренней / закрытый) для класса manager слабых событий в ту же видимость, что событие, которыми она управляет.  
  
5. Использование нового диспетчера слабых событий вместо обычной привязке события.  
  
     Например, если ваш код использует следующий шаблон для подписки на событие:  
  
    ```  
    source.SomeEvent += new SomeEventEventHandler(OnSomeEvent);  
    ```  
  
     Измените его на следующий шаблон:  
  
    ```  
    SomeEventWeakEventManager.AddHandler(source, OnSomeEvent);  
    ```  
  
     Аналогично Если ваш код использует следующий шаблон для отмены подписки на события:  
  
    ```  
    source.SomeEvent -= new SomeEventEventHandler(OnSome);  
    ```  
  
     Измените его на следующий шаблон:  
  
    ```  
    SomeEventWeakEventManager.RemoveHandler(source, OnSomeEvent);  
    ```  
  
## <a name="see-also"></a>См. также

- <xref:System.Windows.WeakEventManager>
- <xref:System.Windows.IWeakEventListener>
- [Общие сведения о перенаправленных событиях](routed-events-overview.md)
- [Общие сведения о привязке данных](../data/data-binding-overview.md)
