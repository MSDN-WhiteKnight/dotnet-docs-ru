---
title: Пошаговое руководство. Кэширование данных приложения WPF
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- walkthroughs [WPF], caching
- caching [.NET Framework]
- caching [WPF]
ms.assetid: dac2c9ce-042b-4d23-91eb-28f584415cef
ms.openlocfilehash: 1d00c222dabf446c7c102307c3b904d3f1ff4bca
ms.sourcegitcommit: 558d78d2a68acd4c95ef23231c8b4e4c7bac3902
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59314402"
---
# <a name="walkthrough-caching-application-data-in-a-wpf-application"></a>Пошаговое руководство. Кэширование данных приложения WPF
Кэширование позволяет хранить данные в памяти для быстрого доступа. При повторном доступе к данным приложения могут получать их из кэша вместо извлечения из исходного источника. Это может повысить производительность и масштабируемость. Кроме того, кэширование обеспечивает доступность данных при временной недоступности источника данных.

 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] Предоставляет классы, которые позволяют использовать кэширование в [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] приложений. Эти классы находятся в папке <xref:System.Runtime.Caching> пространства имен.

> [!NOTE]
>  <xref:System.Runtime.Caching> Пространство имен впервые появилось в [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)]. Это пространство имен обеспечивает кэширование доступен для всех [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] приложений. В предыдущих версиях [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] кэширование было доступно только в пространстве имен <xref:System.Web> и поэтому требовало зависимости от классов ASP.NET.

 В этом пошаговом руководстве показано, как использовать функции кэширования, которая доступна в [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] как часть [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] приложения. В этом пошаговом руководстве кэшировать содержимое текстового файла.

 В данном пошаговом руководстве представлены следующие задачи:

-   Создание проекта приложения WPF.

-   Добавление ссылки на [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)].

-   Инициализация кэша.

-   Добавление записи кэша, который содержит содержимое текстового файла.

-   Предоставление используется политика вытеснения для записи кэша.

-   Отслеживание пути кэшированный файл и уведомление о экземпляра кэша изменения отслеживаемого элемента.

## <a name="prerequisites"></a>Предварительные требования
 Для выполнения данного пошагового руководства требуется:

-   Microsoft Visual Studio 2010.

-   Текстовый файл, который содержит небольшой объем текста. (Содержимое файла текст будет отображаться в окне сообщения.) Код, показанный в этом пошаговом руководстве предполагается, что вы работаете в следующем файле:

     `c:\cache\cacheText.txt`

     Тем не менее можно использовать любой текстовый файл и внести небольшие изменения в код в этом пошаговом руководстве.

## <a name="creating-a-wpf-application-project"></a>Создание проекта приложения WPF
 Начнем с создания проекта приложения WPF.

#### <a name="to-create-a-wpf-application"></a>Создание приложения WPF

1. Запустите Visual Studio.

2. В **файл** меню, щелкните **New**, а затем нажмите кнопку **новый проект**.

     Откроется диалоговое окно **Новый проект**.

3. В разделе **установленные шаблоны**, выберите язык программирования, который вы хотите использовать (**Visual Basic** или **Visual C#**).

4. В **новый проект** выберите **приложение WPF**.

    > [!NOTE]
    >  Если вы не видите **приложение WPF** шаблона, убедитесь, что вы используете версию [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] поддерживает WPF. В **новый проект** выберите [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] из списка.

5. В **имя** текстовое поле, введите имя для проекта. Например, можно ввести **WPFCaching**.

6. Установите флажок **Создать каталог для решения**.

7. Нажмите кнопку **ОК**.

     Откроется конструктор WPF в **разработки** просмотра и отображает файл MainWindow.xaml. Visual Studio создает **Мой проект** папка, файл Application.xaml и файл MainWindow.xaml.

## <a name="targeting-the-net-framework-and-adding-a-reference-to-the-caching-assemblies"></a>Нацеливание на платформу .NET Framework и Добавление ссылки на сборки кэширования
 По умолчанию приложения WPF предназначены [!INCLUDE[net_client_v40_long](../../../../includes/net-client-v40-long-md.md)]. Чтобы использовать <xref:System.Runtime.Caching> пространства имен в приложении WPF, приложение должно использовать платформу [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] (не [!INCLUDE[net_client_v40_long](../../../../includes/net-client-v40-long-md.md)]) и необходимо включить ссылку на пространство имен.

 Таким образом, следующим шагом является изменение целевой платформы .NET Framework и добавьте ссылку на <xref:System.Runtime.Caching> пространства имен.

> [!NOTE]
>  Процедура изменения целевой платформы .NET Framework отличается в проекте Visual Basic и в проекте Visual C#.

#### <a name="to-change-the-target-net-framework-in-visual-basic"></a>Изменение целевой платформы .NET Framework в Visual Basic

1. В **обозревателя решений**, щелкните правой кнопкой мыши имя проекта и нажмите кнопку **свойства**.

     Откроется окно свойств для приложения.

2. Откройте вкладку **Компиляция**.

3. В нижней части окна, щелкните **Дополнительные параметры компиляции...** .

     **Дополнительные параметры компилятора** диалоговое окно.

4. В **целевой платформы (все конфигурации)** выберите [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)]. (Не выбирайте [!INCLUDE[net_client_v40_long](../../../../includes/net-client-v40-long-md.md)].)

5. Нажмите кнопку **ОК**.

     Откроется диалоговое окно **Изменение целевой рабочей среды**.

6. В **Изменение целевой платформы** диалоговом окне щелкните **Да**.

     Проект будет закрыт и вновь открыт.

7. Добавьте ссылку на сборку кэширования, выполнив следующие действия:

    1.  В **обозревателе решений**, щелкните правой кнопкой мыши имя проекта и нажмите кнопку **добавить ссылку**.

    2.  Выберите **.NET** выберите `System.Runtime.Caching`, а затем нажмите кнопку **ОК**.

#### <a name="to-change-the-target-net-framework-in-a-visual-c-project"></a>Изменение целевой платформы .NET Framework в проекте Visual C#

1. В **обозревателе решений**, щелкните правой кнопкой мыши имя проекта и нажмите кнопку **свойства**.

     Откроется окно свойств для приложения.

2. Перейдите на вкладку **Приложение** .

3. В **требуемой версии .NET framework** выберите [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)]. (Не выбирайте **клиентский профиль .NET Framework 4**.)

4. Добавьте ссылку на сборку кэширования, выполнив следующие действия:

    1.  Щелкните правой кнопкой мыши **ссылки** папку и нажмите кнопку **добавить ссылку**.

    2.  Выберите **.NET** выберите `System.Runtime.Caching`, а затем нажмите кнопку **ОК**.

## <a name="adding-a-button-to-the-wpf-window"></a>Добавление кнопки в окне WPF
 Затем добавьте элемент управления button и создайте обработчик событий для кнопки `Click` событий. Позже будет добавлен код, поэтому при нажатии кнопки, кэшируются и отображается содержимое текстового файла.

#### <a name="to-add-a-button-control"></a>Чтобы добавить элемент управления button

1. В **обозревателе решений**, дважды щелкните файл MainWindow.xaml, чтобы открыть его.

2. Из **элементов**в разделе **стандартных элементов управления WPF**, перетащите `Button` управления `MainWindow` окна.

3. В **свойства** окне `Content` свойство `Button` управления **получить кэш**.

## <a name="initializing-the-cache-and-caching-an-entry"></a>Инициализация кэша и кэширование записи
 Далее добавим код для выполнения следующих задач:

-   Создайте экземпляр класса кэша — то есть будет создавать новый <xref:System.Runtime.Caching.MemoryCache> объекта.

-   Укажите, что кэш использует <xref:System.Runtime.Caching.HostFileChangeMonitor> объектов для отслеживания изменений в текстовом файле.

-   Чтение текстового файла и кэшировать его содержимое в качестве записи кэша.

-   Отображение содержимого кэшированного текстового файла.

#### <a name="to-create-the-cache-object"></a>Чтобы создать объект кэша

1. Дважды щелкните кнопку, которую вы только что добавили для создания обработчика событий в файле MainWindow.xaml.cs или MainWindow.Xaml.vb.

2. В верхней части файла (перед объявлением класса), добавьте следующий код `Imports` (Visual Basic) или `using` операторы (C#):

    ```csharp
    using System.Runtime.Caching;
    using System.IO;
    ```

    ```vb
    Imports System.Runtime.Caching
    Imports System.IO
    ```

3. В обработчике событий добавьте следующий код для создания экземпляра объекта кэша:

    ```csharp
    ObjectCache cache = MemoryCache.Default;
    ```

    ```vb
    Dim cache As ObjectCache = MemoryCache.Default
    ```

     <xref:System.Runtime.Caching.ObjectCache> Класс является встроенный класс, который предоставляет кэш в памяти объект.

4. Добавьте следующий код для чтения содержимого записи кэша с именем `filecontents`:

    ```vb
    Dim fileContents As String = TryCast(cache("filecontents"), String)
    ```

    ```csharp
    string fileContents = cache["filecontents"] as string;
    ```

5. Добавьте следующий код для проверки, является ли запись кэша с именем `filecontents` существует:

    ```vb
    If fileContents Is Nothing Then

    End If
    ```

    ```csharp
    if (fileContents == null)
    {

    }
    ```

     Если указанная запись кэша не существует, необходимо прочитать текстовый файл и добавить его в качестве записи кэша в кэш.

6. В `if/then` block, добавьте следующий код для создания нового <xref:System.Runtime.Caching.CacheItemPolicy> , указывающий, что срок действия записи кэша истекает через 10 секунд.

    ```vb
    Dim policy As New CacheItemPolicy()
    policy.AbsoluteExpiration = DateTimeOffset.Now.AddSeconds(10.0)
    ```

    ```csharp
    CacheItemPolicy policy = new CacheItemPolicy();
    policy.AbsoluteExpiration = DateTimeOffset.Now.AddSeconds(10.0);
    ```

     Если нет сведений о удаления или истечения срока действия, по умолчанию используется <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration>, означающее записей кэша, которые никогда не истекать только по абсолютным временем. Вместо этого записей кэша истекает только в том случае, если имеется достаточный объем памяти. Рекомендуется следует всегда явно задавать абсолютный или скользящий срок действия.

7. Внутри `if/then` блокировать и после кода, добавленного на предыдущем шаге, добавьте следующий код, чтобы создать коллекцию для пути к файлам, которые необходимо отслеживать, а также, добавляемый в коллекцию путь файла текста:

    ```vb
    Dim filePaths As New List(Of String)()
    filePaths.Add("c:\cache\cacheText.txt")
    ```

    ```csharp
    List<string> filePaths = new List<string>();
    filePaths.Add("c:\\cache\\cacheText.txt");
    ```

    > [!NOTE]
    >  Если текстовый файл, вы хотите использовать не `c:\cache\cacheText.txt`, укажите путь, где вы хотите использовать текстовый файл.

8. После кода, добавленного на предыдущем шаге, добавьте следующий код, чтобы добавить новый <xref:System.Runtime.Caching.HostFileChangeMonitor> отслеживает объект в коллекцию изменение для записи кэша:

    ```vb
    policy.ChangeMonitors.Add(New HostFileChangeMonitor(filePaths))
    ```

    ```csharp
    policy.ChangeMonitors.Add(new HostFileChangeMonitor(filePaths));
    ```

     <xref:System.Runtime.Caching.HostFileChangeMonitor> Объект отслеживает путь файла текста и уведомляет кэш в том случае, если происходят изменения. В этом примере запись кэша истекает при изменении содержимого файла.

9. После кода, добавленного на предыдущем шаге добавьте следующий код для считывания содержимого текстового файла:

    ```vb
    fileContents = File.ReadAllText("c:\cache\cacheText.txt") & vbCrLf & DateTime.Now.ToString()
    ```

    ```csharp
    fileContents = File.ReadAllText("c:\\cache\\cacheText.txt") + "\n" + DateTime.Now;
    ```

     Отметка даты и времени добавляется таким образом, можно видеть, по истечении срока действия записи кэша.

10. После кода, добавленного на предыдущем шаге, добавьте следующий код, чтобы вставить содержимое файла в объект кэша в качестве <xref:System.Runtime.Caching.CacheItem> экземпляр:

    ```vb
    cache.Set("filecontents", fileContents, policy)
    ```

    ```csharp
    cache.Set("filecontents", fileContents, policy);
    ```

     Укажите сведения о способе записи кэша, передав <xref:System.Runtime.Caching.CacheItemPolicy> объект, созданный ранее в качестве параметра.

11. После `if/then` block, добавьте следующий код для отображения содержимого кэшированного файла в окне сообщения:

    ```vb
    MessageBox.Show(fileContents)
    ```

    ```csharp
    MessageBox.Show(fileContents);
    ```

12. В **построения** меню, щелкните **построения WPFCaching** для сборки проекта.

## <a name="testing-caching-in-the-wpf-application"></a>Проверка кэширования в приложении WPF
 Теперь можно протестировать приложение.

#### <a name="to-test-caching-in-the-wpf-application"></a>Проверка кэширования в приложении WPF

1. Нажмите CTRL+F5, чтобы запустить приложение.

     `MainWindow` Откроется диалоговое окно.

2. Нажмите кнопку **получить кэш**.

     Кэшированное содержимое из текстового файла отображается в окне сообщения. Обратите внимание, что отметка времени на файл.

3. Закройте окно сообщения и нажмите кнопку **получить кэш** еще раз.

     Метка времени не изменяется. Это означает, что отображается кэшированное содержимое.

4. Подождите 10 секунд или более, а затем нажмите кнопку **получить кэш** еще раз.

     Это время отображается новой метки времени. Это означает, что политики сообщите кэша истек и что отображается новое кэшированное содержимое.

5. В текстовом редакторе откройте текстовый файл, который вы создали. Еще не следует вносить любые изменения.

6. Закройте окно сообщения и нажмите кнопку **получить кэш** еще раз.

     Обратите внимание, что отметка времени еще раз.

7. Внести изменения в текстовый файл и сохраните файл.

8. Закройте окно сообщения и нажмите кнопку **получить кэш** еще раз.

     Это окно сообщения содержит обновленное содержимое из текстового файла и новой метки времени. Это означает, что монитор изменений файла узла удалил запись кэша сразу после внесения изменений файл, несмотря на то, что не истек абсолютный период.

    > [!NOTE]
    >  Можно увеличить время вытеснения, в 20 секунд или более, чтобы предоставить больше времени для внесения изменений в файле.

## <a name="code-example"></a>Пример кода
 После завершения этого пошагового руководства, код для созданного проекта будет выглядеть следующим образом.

 [!code-csharp[CachingWPFApplications#1](~/samples/snippets/csharp/VS_Snippets_Wpf/CachingWPFApplications/CSharp/MainWindow.xaml.cs#1)]
 [!code-vb[CachingWPFApplications#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CachingWPFApplications/VisualBasic/MainWindow.xaml.vb#1)]

## <a name="see-also"></a>См. также

- <xref:System.Runtime.Caching.MemoryCache>
- <xref:System.Runtime.Caching.ObjectCache>
- <xref:System.Runtime.Caching>
- [Кэширование в приложениях платформы .NET Framework](../../performance/caching-in-net-framework-applications.md)
