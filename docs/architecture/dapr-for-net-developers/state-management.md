---
title: Стандартный блок управления состоянием ДАПР
description: Описание стандартного блока управления состоянием, его функций, преимуществ и способов его применения.
author: amolenk
ms.date: 02/07/2021
ms.reviewer: robvet
ms.openlocfilehash: 05daf18ece1da377f3d5d6a91c4839f196f14f80
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2021
ms.locfileid: "102401835"
---
# <a name="the-dapr-state-management-building-block"></a>Стандартный блок управления состоянием ДАПР

Распределенные приложения состоят из независимых служб. Хотя каждая служба не имеет отслеживания состояния, некоторые службы должны относить состояние для выполнения бизнес-операций. Рассмотрим службу корзины покупок для сайта электронной коммерции. Если служба не может контролировать состояние, клиент может выпустить содержимое корзины покупок, открывая веб-сайт, что приведет к потере продаж и неудовлетворенному обслуживанию клиентов. В этих сценариях состояние должно сохраняться в распределенном хранилище состояний. [Стандартный блок управления состоянием ДАПР](https://docs.dapr.io/developing-applications/building-blocks/state-management/) упрощает отслеживание состояния и предлагает расширенные функции в различных хранилищах данных.

Чтобы испытать Стандартный блок управления состоянием, ознакомьтесь с [примером приложения счетчика в главе 3](getting-started.md).

## <a name="what-it-solves"></a>Решение

Отслеживание состояния в распределенном приложении может быть непростой задачей. Пример:

- Приложению могут потребоваться различные типы хранилищ данных.
- Для доступа к данным и их обновления могут потребоваться различные уровни согласованности.
- Несколько пользователей могут обновлять данные одновременно, что требует разрешения конфликтов.
- Службы должны повторить все кратковременные [временные ошибки](/aspnet/aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/transient-fault-handling) , возникающие при взаимодействии с хранилищем данных.

Стандартный блок управления состоянием ДАПР решает эти проблемы. Он упрощает отслеживание состояния без зависимостей или курс обучения по сторонним пакетам SDK хранилища.

> [!IMPORTANT]
> ДАПР State Management предлагает API " [ключ — значение](/azure/architecture/guide/technology-choices/data-store-overview#keyvalue-stores) ". Эта функция не поддерживает хранилище реляционных данных или диаграмм.

## <a name="how-it-works"></a>Принцип работы

Приложение взаимодействует с ДАПР расширения для хранения и извлечения данных о ключе и значении. Внутри расширения API использует настраиваемый компонент хранилища состояний для сохранения данных. Разработчики могут выбирать из растущего набора [поддерживаемых хранилищ состояний](https://docs.dapr.io/operations/components/setup-state-store/supported-state-stores/) , включающих Azure Cosmos DB, SQL Server и Cassandra.

API можно вызывать с помощью HTTP или gRPC. Используйте следующий URL-адрес для вызова API HTTP:

```http
http://localhost:<dapr-port>/v1.0/state/<store-name>/
```

- `<dapr-port>`— HTTP-порт, прослушиваемый ДАПР.
- `<store-name>`: имя используемого компонента хранилища состояний.

На рис. 5-1 показано, как служба корзины покупок с ДАПР сохраняет пару "ключ-значение" с помощью компонента хранилища состояний ДАПР с именем `statestore` .

![Схема хранения пары "ключ-значение" в хранилище состояний ДАПР.](media/state-management/state-management-flow.png)

**Рис. 5-1**. Сохранение пары "ключ-значение" в хранилище состояний ДАПР.

Обратите внимание на шаги, описанные на предыдущем рисунке.

1. Служба корзины вызывает API управления состоянием на ДАПР расширения. Текст запроса заключает в себя массив JSON, который может содержать несколько пар "ключ-значение".
1. ДАПР расширения определяет хранилище состояний на основе файла конфигурации компонента. В данном случае это хранилище состояний кэша Redis.
1. Расширения сохраняет данные в кэш Redis.

Получение сохраненных данных является аналогичным вызовом API. В приведенном ниже примере для получения данных с помощью вызова API ДАПР расширения используется команда с *фигурой* .

```console
curl http://localhost:3500/v1.0/state/statestore/basket1
```

Команда возвращает сохраненное состояние в тексте ответа:

```json
{
  "items": [
    {
      "itemId": "DaprHoodie",
      "quantity": 1
    }
  ],
  "customerId": 1
}
```

В следующих разделах объясняется, как использовать расширенные возможности стандартного блока управления состоянием.

### <a name="consistency"></a>Согласованность

[Cap Теорема](https://en.wikipedia.org/wiki/CAP_theorem) — это набор принципов, применяемых к распределенным системам, в которых хранится состояние. На рис. 5-2 показаны три свойства теоремаа CAP.

![ОГРАНИЧЕНИЕ теорема.](media/state-management/cap-theorem.png)

**Рис. 5-2**. ОГРАНИЧЕНИЕ теорема.

Теорема указывает, что распределенные системы данных предлагают компромисс между согласованностью, доступностью и отклонением секций. И все хранилища данных могут *гарантировать только два из трех свойств*:

- *Согласованность* (**C**). Каждый узел в кластере отвечает последним данным, даже если система должна блокировать запрос до тех пор, пока все реплики не будут обновлены. Если вы запрашиваете "последовательную систему" для обновляемого элемента, вы не получите ответ, пока все реплики не будут успешно обновлены. Однако вы всегда получаете самые актуальные данные.

- *Доступность* (**а**). Каждый узел возвращает немедленный ответ, даже если этот ответ не является самыми последними данными. Если вы запрашиваете доступную систему для обновляемого элемента, вы получите наилучший ответ, который может предоставить служба.

- *Допуск секции* (**P**). Гарантирует, что система продолжит работать, даже если реплицированный узел данных завершается сбоем или теряет связь с другими реплицируемыми узлами данных.

Распределенные приложения должны поддерживать свойство **P** . Так как службы обмениваются данными друг с другом с помощью сетевых вызовов, произойдет перерыв в работе сети (**P**). Учитывая это, распределенные приложения должны быть либо **ТД** , либо **CP**.

Приложения **AP** выбирают доступность при согласованности. ДАПР поддерживает этот вариант и имеет **окончательную стратегию согласованности** . Рассмотрим базовое хранилище данных, например Azure CosmosDB, которое хранит избыточные данные на нескольких репликах. При окончательной согласованности хранилище состояний записывает обновление в одну реплику и завершает запрос записи с клиентом. По истечении этого времени хранилище будет асинхронно обновлять свои реплики. Запросы на чтение могут возвращать данные из любой реплики, включая реплики, которые еще не получили Последнее обновление.

Приложения **CP** выбирают согласованность по доступности. ДАПР поддерживает этот вариант со стратегией **строгой согласованности** . В этом случае хранилище состояний будет синхронно обновлять *все* (или, в некоторых случаях, *кворум* ) обязательные реплики *перед* завершением запроса на запись. Операции чтения возвращают актуальные данные для всех реплик.

Уровень согласованности для операции состояния задается путем присоединения к операции указания *согласованности* . В следующей *фигурной* команде запись `Hello=World` пары "ключ-значение" записывается в хранилище состояний с помощью подсказки строгой согласованности:

```console
curl -X POST http://localhost:3500/v1.0/state/<store-name> \
  -H "Content-Type: application/json" \
  -d '[
        {
          "key": "Hello",
          "value": "World",
          "options": {
            "consistency": "strong"
          }
        }
      ]'
```

> [!IMPORTANT]
> Компонент хранилища состояний ДАПР позволяет выполнить подсказку согласованности, присоединенную к операции. Не все хранилища данных поддерживают оба уровня согласованности. Если подсказка о согласованности не задана, поведение по умолчанию — в **конечном итоге**.

### <a name="concurrency"></a>Параллелизм

В приложении с несколькими пользователями существует вероятность того, что несколько пользователей будут одновременно обновлять одни и те же данные (одновременно). ДАПР поддерживает управление оптимистичным параллелизмом (OCC) для управления конфликтами. OCC основан на предположении, что конфликты обновления встречаются редко, так как пользователи работают с различными частями данных. Более эффективно предположить, что обновление будет выполняться, и повторить попытку, если это не так. Альтернатива, реализация пессимистической блокировки может повлиять на производительность с долговременной блокировкой, вызывающей состязание за использование данных.

ДАПР поддерживает управление оптимистичным параллелизмом (OCC) с помощью тегов ETag. ETag — это значение, связанное с определенной версией хранимой пары "ключ-значение". Каждый раз при обновлении пары "ключ-значение" значение ETag также обновляется. Когда клиент получает пару "ключ-значение", ответ включает текущее значение ETag. Когда клиент обновляет или удаляет пару "ключ-значение", он должен отправить значение ETag обратно в тексте запроса. Если другой клиент обновил данные, Теги ETag не будут совпадать, и запрос завершится ошибкой. На этом этапе клиент должен получить обновленные данные, внести изменения еще раз и повторно отправить обновление. Эта стратегия называется **первой записью WINS**.

ДАПР также поддерживает стратегию **последней записи в службу WINS** . При таком подходе клиент не присоединяет ETag к запросу записи. Компонент хранилища состояний всегда будет разрешать обновление, даже если базовое значение было изменено во время сеанса. Последняя запись — WINS полезна для сценариев записи с высокой пропускной способностью с низким состязанием за данные. Кроме того, можно допустить случайное обновление пользователя.

### <a name="transactions"></a>Transactions

ДАПР может записывать *многоэлементные изменения* в хранилище данных в виде одной операции, реализованной в виде транзакции. Эта функция доступна только для хранилищ данных, поддерживающих транзакции [ACID](https://en.wikipedia.org/wiki/ACID) . На момент написания этой статьи в эти магазины входят Redis, MongoDB, PostgreSQL, SQL Server и Azure CosmosDB.

В приведенном ниже примере операция с несколькими элементами отправляется в хранилище состояний в одной транзакции. Для фиксации транзакции должны быть выполнены все операции. При сбое одной или нескольких операций выполняется откат всей транзакции.

```console
curl -X POST http://localhost:3500/v1.0/state/<store-name>/transaction \
  -H "Content-Type: application/json" \
  -d '{
        "operations": [
          {
            "operation": "upsert",
            "request": { "key": "Key1", "value": "Value1"
            }
          },
          {
            "operation": "delete",
            "request": { "key": "Key2" }
          }
        ]
      }'
```

Для хранилищ данных, которые не поддерживают транзакции, несколько ключей по-прежнему можно отправить как один запрос. В следующем примере показана операция **групповой** записи:

```console
curl -X POST http://localhost:3500/v1.0/state/<store-name> \
  -H "Content-Type: application/json" \
  -d '[
        { "key": "Key1", "value": "Value1" },
        { "key": "Key2", "value": "Value2" }
      ]'
```

Для выполнения операций с массовыми операциями ДАПР будет отправлять каждую пару "ключ-значение" как отдельный запрос к хранилищу данных.

## <a name="use-the-dapr-net-sdk"></a>Использование пакета SDK для ДАПР .NET

Пакет SDK для ДАПР для .NET обеспечивает поддержку платформы .NET Core для конкретного языка. `DaprClient`Для чтения и записи данных разработчики могут использовать класс, представленный в [главе 3](getting-started.md) . В следующем примере показано, как использовать `DaprClient.GetStateAsync<TValue>` метод для чтения данных из хранилища состояний. Метод принимает имя хранилища, `statestore` и ключ, `AMS` в качестве параметров:

```csharp
var weatherForecast = await daprClient.GetStateAsync<WeatherForecast>("statestore", "AMS");
```

Если хранилище состояний не содержит данных для ключа `AMS` , результатом будет `default(WeatherForecast)` .

Чтобы записать данные в хранилище данных, используйте `DaprClient.SaveStateAsync<TValue>` метод:

```csharp
daprClient.SaveStateAsync("statestore", "AMS", weatherForecast);
```

В примере используется стратегия **Last-Write-WINS** , так как значение ETag не передается в компонент хранилища состояний. Чтобы использовать управление оптимистичным параллелизмом (OCC) с стратегией с **первой записью WINS** , сначала извлеките текущий ETag с помощью `DaprClient.GetStateAndETagAsync` метода. Затем запишите обновленное значение и передайте полученный ETag с помощью `DaprClient.TrySaveStateAsync` метода.

```csharp
var (weatherForecast, etag) = await daprClient.GetStateAndETagAsync<WeatherForecast>("statestore", city);

// ... make some changes to the retrieved weather forecast

var result = await daprClient.TrySaveStateAsync("statestore", city, weatherForecast, etag);
```

`DaprClient.TrySaveStateAsync`Метод завершается ошибкой, если данные (и связанные с ними ETag) были изменены в хранилище состояний после извлечения данных. Метод возвращает логическое значение, указывающее, был ли вызов успешной. Стратегия обработки сбоя заключается в том, чтобы просто перезагрузить обновленные данные из хранилища состояний, внести изменения еще раз и повторно отправить обновление.

Если вы всегда хотите, чтобы запись была выполнена, независимо от других изменений данных, используйте стратегию **последней записи и WINS** .

Пакет SDK предоставляет другие методы для получения данных в пакетном режиме, удаления данных и выполнения транзакций. Дополнительные сведения см. в [репозитории SDK для .NET ДАПР](https://github.com/dapr/dotnet-sdk).

### <a name="aspnet-core-integration"></a>Интеграция ASP.NET Core

ДАПР также поддерживает ASP.NET Core, кросс-платформенную платформу для создания современных облачных веб-приложений. Пакет SDK для ДАПР интегрирует возможности управления состоянием непосредственно в возможности [привязки модели ASP.NET Core](/aspnet/core/mvc/models/model-binding) . Конфигурация проста. Добавьте, добавив `IMVCBuilder.AddDapr` `.AddDapr` метод расширения в `Startup.cs` класс, как показано в следующем примере:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers().AddDapr();
}
```

После настройки ДАПР может внедрить пару "ключ-значение" непосредственно в действие контроллера с помощью атрибута ASP.NET Core `FromState` . Обращение к `DaprClient` объекту больше не требуется. В следующем примере показан веб-API, который возвращает прогноз погоды для данного города:

```csharp
[HttpGet("{city}")]
public ActionResult<WeatherForecast> Get([FromState("statestore", "city")] StateEntry<WeatherForecast> forecast)
{
    if (forecast.Value == null)
    {
      return NotFound();
    }

    return forecast.Value;
}
```

В этом примере контроллер загружает прогноз погоды с помощью `FromState` атрибута. Первый параметр атрибута — это хранилище состояний, `statestore` . Вторым параметром атрибута `city` является имя переменной [шаблона маршрута](/aspnet/core/mvc/controllers/routing#route-templates) для получения ключа состояния. Если опустить второй параметр, `forecast` для поиска переменной шаблона маршрута используется имя параметра привязанного метода ().

`StateEntry`Класс содержит свойства для всей информации, полученной для одной пары «ключ-значение `StoreName` »:, `Key` , `Value` и `ETag` . ETag полезен для реализации стратегии управления оптимистичным параллелизмом (OCC). Класс также предоставляет методы для удаления или обновления полученных данных типа "ключ-значение" без необходимости использования `DaprClient` экземпляра. В следующем примере `TrySaveAsync` метод используется для обновления полученного прогноза погоды с помощью OCC.

```csharp
[HttpPut("{city}")]
public async Task Put(WeatherForecast updatedForecast, [FromState("statestore", "city")] StateEntry<WeatherForecast> currentForecast)
{
    // update cached current forecast with updated forecast passed into service endpoint
    currentForecast.Value = updatedForecast;

    // update state store
    var success = await currentForecast.TrySaveAsync();

    // ... check result
}
```

## <a name="state-store-components"></a>Компоненты хранилища состояний

На момент написания этой статьи ДАПР обеспечивает поддержку следующих транзакционных хранилищ состояний:

- Azure CosmosDB
- Azure SQL Server;
- MongoDB
- PostgreSQL
- Redis

ДАПР также включает поддержку хранилищ состояний, поддерживающих операции CRUD, но не транзакционные возможности:

- аероспике
- Хранилище BLOB-объектов Azure
- Хранилище таблиц Azure
- Cassandra
- клаудстате
- Couchbase
- etcd
- Google Cloud Фиресторе
- Hashicorp Consul
- хазелкаст
- Memcached
- Zookeeper

### <a name="configuration"></a>Конфигурация

При инициализации для локальной, автономной разработки ДАПР регистрирует Redis в качестве хранилища состояний по умолчанию. Ниже приведен пример конфигурации хранилища состояний по умолчанию. Запишите имя по умолчанию `statestore` :

```yaml
apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
  name: statestore
spec:
  type: state.redis
  version: v1
  metadata:
  - name: redisHost
    value: localhost:6379
  - name: redisPassword
    value: ""
  - name: actorStateStore
    value: "true"
```

 > [!NOTE]
 > Многие хранилища состояний могут быть зарегистрированы в одном приложении с разными именами.

Хранилище состояний Redis требует `redisHost` , `redisPassword` чтобы метаданные подключались к экземпляру Redis. В приведенном выше примере пароль Redis (по умолчанию это пустая строка) хранится в виде простой строки. Рекомендуется избегать строк с четким текстом и всегда использовать секретные ссылки. Дополнительные сведения об управлении секретами см. в [главе 10](secrets.md).

Другое поле метаданных `actorStateStore` указывает, может ли хранилище состояний использоваться стандартным блоком субъектов.

### <a name="key-prefix-strategies"></a>Стратегии префиксов ключей

Компоненты хранилища состояний позволяют различным стратегиям хранить пары "ключ-значение" в базовом хранилище. Взпомните предыдущий пример службы корзины покупок, в которой хранятся товары, которые клиент хочет приобрести:

```console
curl -X POST http://localhost:3500/v1.0/state/statestore \
  -H "Content-Type: application/json" \
  -d '[{
        "key": "basket1",
        "value": {
          "customerId": 1,
          "items": [
            { "itemId": "DaprHoodie", "quantity": 1 }
          ]
        }
     }]'
```

С помощью средства консоли Redis просмотрите кэш Redis, чтобы увидеть, как компонент хранилища состояний Redis сохраняет данные.

```
127.0.0.1:6379> KEYS *
1) "basketservice||basket1"

127.0.0.1:6379> HGETALL basketservice||basket1
1) "data"
2) "{\"items\":[{\"itemId\":\"DaprHoodie\",\"quantity\":1}],\"customerId\":1}"
3) "version"
4) "1"
```

Выходные данные показывают полный **ключ** Redis для данных в виде `basketservice||basket1` . По умолчанию ДАПР использует `application id` экземпляр ДАПР ( `basketservice` ) в качестве префикса для ключа. Это соглашение об именовании позволяет нескольким экземплярам ДАПР совместно использовать одно и то же хранилище данных без конфликтов имен ключей. Для разработчика важно всегда указывать то же самое `application id` при запуске приложения с помощью ДАПР. Если этот параметр опущен, ДАПР создаст уникальный идентификатор приложения. В случае `application id` изменения приложение больше не сможет получить доступ к состоянию, сохраненному с помощью предыдущего префикса ключа.

С другой стороны, можно настроить *постоянное значение* для префикса ключа в `keyPrefix` поле метаданных в файле компонента хранилища состояний. Рассмотрим следующий пример.

```yaml
spec:
  metadata:
  - name: keyPrefix
  - value: MyPrefix
```

Префикс константного ключа обеспечивает доступ к хранилищу состояний в нескольких приложениях ДАПР. Более того, установка параметра `keyPrefix` позволяет `none` полностью опустить префикс.

## <a name="reference-application-eshopondapr"></a>Эталонное приложение: Ешопондапр

Эта книга содержит Справочное приложение `eShopOnDapr` . Она моделируется на основе более раннего справочного приложения по микрослужбам Майкрософт, `eShopOnContainers` .

Исходная архитектура [eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers) использовала `IBasketRepository` интерфейс для чтения и записи данных для службы корзины. `RedisBasketRepository`Класс предоставил реализацию, используя Redis в качестве базового хранилища данных:

```csharp
public class RedisBasketRepository : IBasketRepository
{
    private readonly ConnectionMultiplexer _redis;
    private readonly IDatabase _database;

    public RedisBasketRepository(ConnectionMultiplexer redis)
    {
        _redis = redis;
        _database = redis.GetDatabase();
    }

    public async Task<CustomerBasket> GetBasketAsync(string customerId)
    {
        var data = await _database.StringGetAsync(customerId);

        if (data.IsNullOrEmpty)
        {
            return null;
        }

        return JsonConvert.DeserializeObject<CustomerBasket>(data);
    }

    // ...
}
```

В этом коде используется сторонний `StackExchange.Redis` пакет NuGet. Чтобы загрузить корзину покупок для данного клиента, необходимо выполнить следующие действия.

1. Вставьте в `ConnectionMultiplexer` конструктор. `ConnectionMultiplexer`Регистрируется с помощью платформы внедрения зависимостей в `Startup.cs` файле:

   ```csharp
   services.AddSingleton<ConnectionMultiplexer>(sp =>
   {
       var settings = sp.GetRequiredService<IOptions<BasketSettings>>().Value;
       var configuration = ConfigurationOptions.Parse(settings.ConnectionString, true);
       configuration.ResolveDns = true;
       return ConnectionMultiplexer.Connect(configuration);
   });
   ```

1. Используйте `ConnectionMultiplexer` для создания `IDatabase` экземпляра в каждом использующем классе.

1. Используйте `IDatabase` экземпляр для выполнения вызова Стрингжет Redis с помощью указанного в `customerId` качестве ключа.

1. Проверьте, загружены ли данные из Redis. Если нет, возвращается значение `null` .

1. Десериализация данных из Redis в `CustomerBasket` объект и возврат результата.

В обновленном эталонном приложении [ешопондапр](https://github.com/dotnet-architecture/eShopOnDapr) новый `DaprBasketRepository` класс заменяет `RedisBasketRepository` класс:

```csharp
public class DaprBasketRepository : IBasketRepository
{
    private const string StoreName = "eshop-basket-statestore";

    private readonly DaprClient _daprClient;

    public DaprBasketRepository(DaprClient daprClient)
    {
        _daprClient = daprClient ?? throw new ArgumentNullException(nameof(daprClient));;
    }

    public async Task<CustomerBasket> GetBasketAsync(string customerId)
    {
        return await _daprClient.GetStateAsync<CustomerBasket>(StoreName, customerId);
    }

    // ...
}
```

Обновленный код использует пакет SDK для .NET ДАПР для чтения и записи данных с помощью стандартного блока управления состоянием. Новые шаги по загрузке корзины для клиента значительно упрощены:

1. Вставьте в `DaprClient` конструктор. `DaprClient`Регистрируется в файле в инфраструктуре внедрения зависимостей `Startup.cs` .
1. Используйте `DaprClient.GetStateAsync` метод, чтобы загрузить элементы корзины покупок клиента из настроенного хранилища состояний и вернуть результат.

Обновленная реализация по-прежнему использует Redis в качестве базового хранилища данных. Но ДАПР абстрагирует `StackExchange.Redis` ссылки и сложность приложения. Требуется файл конфигурации ДАПР:

```yaml
apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
  name: eshop-basket-statestore
  namespace: eshop
spec:
  type: state.redis
  version: v1
  metadata:
  - name: redisHost
    value: redis:6379
  - name: redisPassword
    secretKeyRef:
      name: redisPassword
auth:
  secretStore: eshop-secretstore
```

Реализация ДАПР также упрощает изменение базового хранилища данных. Например, для переключения на хранилище таблиц Azure требуется только изменение содержимого файла конфигурации. Изменения кода не требуются.

## <a name="summary"></a>Итоги

Стандартный блок управления состоянием ДАПР предоставляет API для хранения данных ключа и значения в различных хранилищах данных. API обеспечивает поддержку следующих функций:

- Массовые операции
- Строгая и окончательная согласованность
- Управление оптимистическим параллелизмом
- Транзакции для нескольких элементов

Пакет SDK для .NET предоставляет поддержку для конкретного языка для .NET Core и ASP.NET Core. Интеграция привязки модели упрощает доступ и обновление состояния из методов действий контроллера ASP.NET Core.

В приложении Ешопондапр Reference преимущества перехода на управление состоянием ДАПР очевидны:

1. В новой реализации используется меньше строк кода.
1. Он абстрагирует сложность API стороннего разработчика `StackExchange.Redis` .
1. Замена базового кэша Redis другим типом хранилища данных теперь требует только внесения изменений в файл конфигурации хранилища состояний.

### <a name="references"></a>Ссылки

- [ДАПР поддерживаемые хранилища состояний](https://docs.dapr.io/operations/components/setup-state-store/supported-state-stores/)

> [!div class="step-by-step"]
> [Назад](reference-application.md)
> [Вперед](service-invocation.md)
