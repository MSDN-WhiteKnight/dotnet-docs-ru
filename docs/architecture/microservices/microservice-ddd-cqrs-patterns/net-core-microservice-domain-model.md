---
title: Реализация модели предметной области микрослужбы с помощью .NET
description: Архитектура микрослужб .NET для контейнерных приложений .NET | Сведения о реализации модели предметной области, ориентированной на DDD.
ms.date: 02/02/2021
ms.openlocfilehash: 87d832101d95f3ab69d1a40bbdc820e1e09af5db
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2021
ms.locfileid: "99665280"
---
# <a name="implement-a-microservice-domain-model-with-net"></a>Реализация модели предметной области микрослужбы с помощью .NET

В предыдущем разделе были представлены основные принципы и шаблоны для проектирования модели предметной области. Теперь настало время рассмотреть возможные способы реализации модели предметной области с помощью .NET (обычного кода C\#) и EF Core. Ваша модель предметной области будет состоять только из вашего кода. В ней будут реализованы требования модели EF Core, но не реальные зависимости от EF. В модели предметной области не должно быть строгих зависимостей или ссылок на EF Core или любой другой сопоставитель ORM.

## <a name="domain-model-structure-in-a-custom-net-standard-library"></a>Структура модели предметной области в пользовательской библиотеке .NET Standard

Структура папок в образце приложения eShopOnContainers демонстрирует модель DDD для приложения. В вашем случае требованиям проекта более точно может отвечать другая структура папок. Как видно на рис. 7-10, в модели предметной области размещения заказов имеются два агрегата: агрегат заказа и агрегат покупателя. Каждый агрегат представляет собой группу сущностей предметной области и объектов значений, хотя агрегат может состоять и из одной сущности предметной области (корневой сущности агрегата).

:::image type="complex" source="./media/net-core-microservice-domain-model/ordering-microservice-container.png" alt-text="Снимок экрана: проект Ordering.Domain в обозревателе решений.":::
Представление обозревателя решений для проекта Ordering.Domain, в котором отображается папка AggregatesModel, содержащая папки BuyerAggregate и OrderAggregate, каждая из которых содержит свои классы сущностей, объектные файлы значений и т. д.
:::image-end:::

**Рис. 7-10**. Структура модели предметной области для микрослужбы размещения заказов в eShopOnContainers

Кроме того, уровень модели предметной области включает в себя контракты репозиториев (интерфейсы), которые представляют требования к инфраструктуре, предъявляемые моделью предметной области. Иными словами, эти интерфейсы описывают то, какие репозитории и методы должен реализовывать уровень инфраструктуры. Важным требованием является реализация репозиториев вне уровня модели предметной области, а именно в библиотеке уровня инфраструктуры, чтобы уровень модели предметной области не "засорялся" интерфейсами API или классами, связанными с технологиями инфраструктуры, такими как Entity Framework.

Обратите также внимание на папку [SeedWork](https://martinfowler.com/bliki/Seedwork.html), содержащую пользовательские базовые классы, которые можно использовать в качестве основы для сущностей предметной области и объектов значений, чтобы избежать избыточного кода в каждом классе объекта предметной области.

## <a name="structure-aggregates-in-a-custom-net-standard-library"></a>Структура агрегатов в пользовательской библиотеке .NET Standard

Под агрегатом понимается совокупность объектов предметной области, сгруппированных с целью обеспечения согласованности транзакций. Эти объекты могут представлять собой сущности (одна из которых является корневой сущностью агрегата), а также дополнительные объекты значений.

Согласованность транзакций гарантирует согласованность и актуальность агрегата по завершении бизнес-действия. Например, агрегат заказа из модели предметной области микрослужбы размещения заказов eShopOnContainers состоит из компонентов, показанных на рис. 7-11.

:::image type="complex" source="./media/net-core-microservice-domain-model/vs-solution-explorer-order-aggregate.png" alt-text="Снимок экрана: папка OrderAggregate и ее классы.":::
Подробное представление папки OrderAggregate: Address.cs — объект значения, IOrderRepository — интерфейс репозитория, Order.cs — корень агрегации, OrderItem.cs — дочерняя сущность, а OrderStatus.cs — класс перечисления.
:::image-end:::

**Рис. 7-11**. Агрегат заказа в решении Visual Studio

Если открыть любой файл в папке агрегата, можно увидеть, что он помечен как пользовательский базовый класс или интерфейс, например сущность или объект значения. Пример реализации см. в папке [SeedWork](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork).

## <a name="implement-domain-entities-as-poco-classes"></a>Реализация сущностей предметной области в виде классов POCO

Модель предметной области реализуется в .NET путем создания классов POCO, которые реализуют сущности предметной области. В приведенном ниже примере класс Order определен как сущность, а также как корневая сущность агрегата. Так как класс Order является производным от базового класса Entity, в нем можно использовать код, общий для всех сущностей. Имейте в виду, что эти базовые классы и интерфейсы определяются вами в проекте модели предметной области, поэтому это ваш код, а не код инфраструктуры из ORM, например EF.

```csharp
// COMPATIBLE WITH ENTITY FRAMEWORK CORE 5.0
// Entity is a custom base class with the ID
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId;

    public OrderStatus OrderStatus { get; private set; }
    private int _orderStatusId;

    private string _description;
    private int? _paymentMethodId;

    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;

    public Order(string userId, Address address, int cardTypeId, string cardNumber, string cardSecurityNumber,
            string cardHolderName, DateTime cardExpiration, int? buyerId = null, int? paymentMethodId = null)
    {
        _orderItems = new List<OrderItem>();
        _buyerId = buyerId;
        _paymentMethodId = paymentMethodId;
        _orderStatusId = OrderStatus.Submitted.Id;
        _orderDate = DateTime.UtcNow;
        Address = address;

        // ...Additional code ...
    }

    public void AddOrderItem(int productId, string productName,
                            decimal unitPrice, decimal discount,
                            string pictureUrl, int units = 1)
    {
        //...
        // Domain rules/logic for adding the OrderItem to the order
        // ...

        var orderItem = new OrderItem(productId, productName, unitPrice, discount, pictureUrl, units);

        _orderItems.Add(orderItem);

    }
    // ...
    // Additional methods with domain rules/logic related to the Order aggregate
    // ...
}
```

Важно отметить, что это сущность предметной области, реализованная в виде класса POCO. Она не имеет прямой зависимости от Entity Framework Core или любой другой платформы инфраструктуры. Именно такая реализация должна использоваться в DDD — просто код C#, реализующий модель предметной области.

Кроме того, класс снабжен интерфейсом с именем IAggregateRoot. Это пустой интерфейс, иногда называемый *интерфейсом-маркером*, который служит лишь для указания на то, что этот класс сущности также является корневой сущностью агрегата.

Интерфейсы-маркеры порой считают антишаблонами; однако они также позволяют ясно помечать классы, особенно если интерфейс может развиваться. В качестве маркеров можно также применять атрибуты, однако базовый класс (Entity) проще заметить рядом с интерфейсом IAggregate, чем атрибут-маркер Aggregate, размещенный над классом. В любом случае это зависит от предпочтений.

Наличие корневой сущности агрегата означает, что большая часть кода, связанного с обеспечением согласованности и бизнес-правилами сущностей агрегата, должна реализовываться в виде методов класса корневой сущности агрегата Order (например, AddOrderItem при добавлении объекта OrderItem в агрегат). Объекты OrderItems не следует создавать или изменять отдельно или напрямую; класс AggregateRoot должен контролировать все операции изменения его дочерних сущностей и поддерживать их согласованность.

## <a name="encapsulate-data-in-the-domain-entities"></a>Инкапсуляция данных в сущностях предметной области

Распространенной проблемой моделей сущностей является то, что они предоставляют свойства навигации коллекции как общедоступные типы списка. Это позволяет любому разработчику управлять содержимым этих типов в коллекции в процессе совместной работы. В результате могут обходиться важные бизнес-правила, связанные с коллекцией, из-за чего объект может оказаться в недопустимом состоянии. Решение заключается в предоставлении доступа только для чтения к связанным коллекциям и явном предоставлении методов, которые определяют возможные способы работы клиентов с этими коллекциями.

В предыдущем коде обратите внимание на то, что многие атрибуты доступны только для чтения или являются закрытыми и могут изменяться только методами класса, поэтому при любом изменении учитываются инварианты и логика предметной области, определенные в методах класса.

Например, согласно шаблонам DDD ***не* следует выполнять следующую операцию** из любого обработчика команд или класса прикладного уровня (фактически, сделать это будет невозможно):

```csharp
// WRONG ACCORDING TO DDD PATTERNS – CODE AT THE APPLICATION LAYER OR
// COMMAND HANDLERS
// Code in command handler methods or Web API controllers
//... (WRONG) Some code with business logic out of the domain classes ...
OrderItem myNewOrderItem = new OrderItem(orderId, productId, productName,
    pictureUrl, unitPrice, discount, units);

//... (WRONG) Accessing the OrderItems collection directly from the application layer // or command handlers
myOrder.OrderItems.Add(myNewOrderItem);
//...
```

В этом случае метод Add представляет собой исключительно операцию добавления данных с прямым доступом к коллекции OrderItems. Поэтому большая часть логики предметной области, правил или проверок, связанных с этой операцией с дочерними сущностями, будет распределена по прикладному уровню (обработчикам команд и контроллерам веб-интерфейса API).

Если обойти корневую сущность агрегата, ее инвариантность, допустимость или согласованность не может быть гарантирована. В конечном итоге получится спагетти-код или код транзакционного скрипта.

Если следовать шаблонам DDD, сущности не должны иметь открытых методов задания ни в одном свойстве сущности. Изменения в сущности должны производиться явными методами, в которых с помощью единого языка формулируются производимые ими изменения.

Кроме того, коллекции в сущности (например, элементы заказа) должны быть свойствами, доступными только для чтения (см. описание метода AsReadOnly далее). Возможность их изменения должна быть доступна только из методов класса корневой сущности агрегата или из методов дочерних сущностей.

Как видно в коде корневой сущности агрегата Order, все методы задания должны быть закрытыми либо по крайней мере доступными только для чтения извне, чтобы любая операция с данными сущности или ее дочерними сущностями выполнялась посредством методов в классе сущности. Это позволяет обеспечивать согласованность контролируемым и объектно-ориентированным образом вместо реализации кода транзакционного скрипта.

В приведенном ниже фрагменте кода показан правильный способ реализации задачи для добавления объекта OrderItem в агрегат Order.

```csharp
// RIGHT ACCORDING TO DDD--CODE AT THE APPLICATION LAYER OR COMMAND HANDLERS
// The code in command handlers or WebAPI controllers, related only to application stuff
// There is NO code here related to OrderItem object's business logic
myOrder.AddOrderItem(productId, productName, pictureUrl, unitPrice, discount, units);

// The code related to OrderItem params validations or domain rules should
// be WITHIN the AddOrderItem method.

//...
```

В этом фрагменте большая часть проверок и логики, связанных с созданием объекта OrderItem, контролируется корневой сущностью агрегата Order в методе AddOrderItem, в частности, проверки и логика, связанные с другими элементами агрегата. Например, один и тот же элемент продукта может быть получен в результате нескольких вызовов метода AddOrderItem. В этом методе можно проверять элементы продуктов и объединять одинаковые элементы в один объект OrderItem с несколькими единицами. Кроме того, если имеется несколько разных размеров скидок, но идентификатор продукта один и тот же, скорее всего, следует применить наибольшую скидку. Этот принцип применим к любой другой логике предметной области для объекта OrderItem.

Кроме того, операция new OrderItem(params) также будет контролироваться и выполняться методом AddOrderItem из корневой сущности агрегата Order. Поэтому большая часть логики или проверок, связанных с этой операцией (особенно все, что влияет на согласованность дочерних сущностей), будет находиться в одном месте в корневой сущности агрегата. Это конечная цель шаблона корневой сущности агрегата.

В Entity Framework Core 1.1 или более поздней версии сущность DDD можно описать лучше благодаря возможности [сопоставления с полями](/ef/core/modeling/backing-field), помимо свойств. Это полезно при защите коллекций дочерних сущностей или объектов значений. Благодаря этому улучшению вы можете использовать простые закрытые поля вместо свойств и реализовать любое изменение коллекции полей в открытых методах, предоставив доступ только для чтения посредством метода AsReadOnly.

В рамках DDD желательно изменять сущность только с помощью методов самой сущности (или конструктора), чтобы контролировать инварианты и согласованность данных, поэтому свойства определяются только с помощью метода доступа get. Свойства поддерживаются закрытыми полями. Закрытые члены доступны только внутри класса. Однако есть одно исключение: платформе EF Core необходимо также задать эти поля (поэтому она может возвращать объект с надлежащими значениями).

### <a name="map-properties-with-only-get-accessors-to-the-fields-in-the-database-table"></a>Сопоставление свойств только с методами доступа get с полями в таблице базы данных

За сопоставление свойств со столбцами в таблице базы данных отвечает не предметная область, а инфраструктура и уровень хранения данных. Мы упоминаем это здесь, чтобы вы знали о новых возможностях, связанных с моделированием сущностей, в EF Core 1.1 и более поздних версиях. Дополнительные сведения по этой теме приводятся в разделе, посвященном инфраструктуре и хранению данных.

При использовании EF Core 1.0 или более поздней версии в классе DbContext необходимо сопоставлять свойства, определенные только с методами задания, с фактическими полями в таблице базы данных. Для этого служит метод HasField класса PropertyBuilder.

### <a name="map-fields-without-properties"></a>Сопоставление полей без свойств

Благодаря возможности сопоставления столбцов с полями в EF Core 1.1 и более поздних версиях можно также не использовать свойства. Вместо этого можно просто сопоставить столбцы таблицы с полями. Распространенным сценарием применения этой возможности являются закрытые поля для хранения внутреннего состояния, доступ к которым не должен осуществляться извне сущности.

Так, в предыдущем примере кода OrderAggregate есть несколько закрытых полей, таких как `_paymentMethodId`, которые не имеют связанного свойства для метода задания или метода получения. Такое поле могло бы вычисляться в бизнес-логике заказа и использоваться из методов заказа, но оно также должно сохраняться в базе данных. Поэтому в EF Core (начиная с версии 1.1) есть возможность сопоставления поля, с которым не связано свойство, со столбцом в базе данных. Об этом также рассказывается в разделе [Уровень инфраструктуры](ddd-oriented-microservice.md#the-infrastructure-layer) этого руководства.

### <a name="additional-resources"></a>Дополнительные ресурсы

- **Вон Вернон (Vaughn Vernon). Моделирование агрегатов с помощью DDD и Entity Framework.** Обратите внимание, что речь идет *не* об Entity Framework Core. \
  <https://kalele.io/blog-posts/modeling-aggregates-with-ddd-and-entity-framework/>

- **Julie Lerman (Джули Лерман). Точки данных — создание кода при проблемно-ориентированном проектировании: советы для разработчиков, ориентированных на данные** \
  <https://docs.microsoft.com/archive/msdn-magazine/2013/august/data-points-coding-for-domain-driven-design-tips-for-data-focused-devs>

- **Уди Дахан (Udi Dahan). Создание полностью инкапсулированных моделей предметной области** \
  <https://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

> [!div class="step-by-step"]
> [Назад](microservice-domain-model.md)
> [Вперед](seedwork-domain-model-base-classes-interfaces.md)
