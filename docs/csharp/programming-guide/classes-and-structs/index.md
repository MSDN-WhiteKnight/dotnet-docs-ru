---
title: Руководство по программированию на C#. Классы и структуры
description: Описание использования классов и структур в C#.
ms.date: 02/25/2021
helpviewer_keywords:
- structs [C#], about structs
- classes [C#], overview
- C# language, structs
- C# language, objects
- objects [C#]
- C# language, classes
ms.assetid: cc39dbda-8754-423e-b5b1-16a1db0734c0
ms.openlocfilehash: 2d4aa6ce8a8ac6d8c5b9f24ed55221873055018c
ms.sourcegitcommit: 9c589b25b005b9a7f87327646020eb85c3b6306f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2021
ms.locfileid: "102258498"
---
# <a name="classes-and-structs-c-programming-guide"></a>Классы и структуры (руководство по программированию на C#)

Классы и структуры являются двумя основными конструкциями системы общих типов CTS, используемой на платформе .NET. Оба они являются структурами данных, которые инкапсулируют набор данных и поведений в одной логической сущности. Данные и поведение являются *членами* класса или структуры. К ним относятся методы, свойства, события и другие элементы, которые описаны далее в этой статье.  
  
 Объявление класса или структуры служит своего рода чертежом для создания экземпляров или объектов во время выполнения. Если вы определите класс или структур с именем `Person`, то `Person` здесь обозначает имя типа. Если вы объявите и инициализируете переменную `p` типа `Person`, принято говорить, что `p` является объектом (или экземпляром) `Person`. Можно создать несколько экземпляров одного типа `Person`, и каждый экземпляр будет иметь разные значения свойств и полей.  
  
 Класс является ссылочным типом. Когда вы создаете объект класса и сохраняете его в переменную, эта переменная содержит только ссылку на память объекта. Если ссылка на объект сохраняется в новую переменную, эта переменная также ссылается на исходный объект. Изменения, внесенные через одну переменную, отражаются и в другой переменной, поскольку обе они ссылаются на одни и те же данные.
  
 Структура (struct) является типом значения. При создании структуры переменная, которой присвоена структура, содержит фактические данные этой структуры. Если структура присваивается новой переменной, все данные копируются. Таким образом, новая переменная и исходная переменная содержат две отдельные копии одинаковых данных. Изменения, внесенные в одну копию, не влияют на другую.  
  
 В общем случае классы используются для моделирования более сложного поведения или для таких данных, которые будут изменяться после создания объекта класса. Структуры лучше подходят для небольших структур данных, информация в которых не должна изменяться после создания структуры. Начиная с C# 9 типы записей доступны для более крупных структур данных, информация в которых не должна изменяться после создания объекта.
  
 См. сведения в описании [классов](./classes.md), [объектов](./objects.md), [типов структур](../../language-reference/builtin-types/struct.md) и [записей](../../language-reference/builtin-types/record.md).
  
## <a name="example"></a>Пример  

 В следующем примере в пространстве имен `ProgrammingGuide` определен класс `CustomClass` с тремя членами: конструктор экземпляра, свойство с именем `Number` и метод с именем `Multiply`. Метод `Main` в классе `Program` создает экземпляр (объект) класса `CustomClass`. Обращение к методам и свойствам объекта осуществляется с использованием точечной нотации.
  
 [!code-csharp[csProgGuideObjects#1](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/class1.cs#1)]  
  
## <a name="encapsulation"></a>Инкапсуляция  

 Концепцию *инкапсуляции* признают одним из основополагающих принципов объектно-ориентированного программирования. Принцип инкапсуляции заключается в том, что в классе или структуре можно указать уровень доступности для обращения к каждому из его членов из кода, расположенного вне этого класса или структуры. Вы можете скрыть методы и переменные, которые не предназначены для использования вне класса или сборки. Это позволяет снизить риск ошибок в коде и вредоносных действий.  
  
 Дополнительные сведения о классах вы найдете в статьях [Классы](./classes.md) и [Объекты](./objects.md).  
  
## <a name="members"></a>Участники  

 Все методы, поля, константы, свойства и события должны объявляться внутри типа. Совокупно они называются *членами* типа. В C# не существует глобальных переменных или методов, как в некоторых других языках. Даже точка входа программы, то есть метод `Main`, должна объявляться внутри класса или структуры. Ниже приведен полный список возможных членов, которые можно объявить в классе или структуре.  
  
- [Поля](./fields.md)  
  
- [Константы](./constants.md)  
  
- [Свойства](./properties.md)  
  
- [Методы](./methods.md)  
  
- [Конструкторы](./constructors.md)  
  
- [События](../events/index.md)  
  
- [Методы завершения](./destructors.md)  
  
- [Индексаторы](../indexers/index.md)  
  
- [Инструкции](../../language-reference/operators/index.md)  
  
- [Вложенные типы](./nested-types.md)  
  
## <a name="accessibility"></a>Специальные возможности  

 Некоторые методы и свойства специально предназначены для того, чтобы их вызов или доступ к ним осуществлялся из *клиентского кода*, то есть из кода за пределами этого класса или структуры. Другие методы и свойства могут использоваться только в самом классе или структуре. Важно ограничить доступность кода так, чтобы только нужные элементы клиентского кода получали к нему доступ. Уровень доступности для типов и их членов вы можете задать с помощью модификаторов доступа [public](../../language-reference/keywords/public.md), [protected](../../language-reference/keywords/protected.md), [internal](../../language-reference/keywords/internal.md), [protected internal](../../language-reference/keywords/protected-internal.md), [private](../../language-reference/keywords/private.md) и [private protected](../../language-reference/keywords/private-protected.md). По умолчанию используется режим доступа `private`. Дополнительные сведения см. в статье [Модификаторы доступа](./access-modifiers.md).  
  
## <a name="inheritance"></a>Наследование  

 Классы (но не структуры) поддерживают наследование. Класс, производный от другого класса (*базового класса*), автоматически включает все открытые, защищенные и внутренние члены базового класса за исключением конструкторов и методов завершения. Дополнительные сведения см. в статьях о [наследовании](./inheritance.md) и [полиморфизме](./polymorphism.md).  
  
 Классы могут быть объявлены как [абстрактные](../../language-reference/keywords/abstract.md). Это означает, что один или несколько их членов не имеют реализации. Из абстрактных классов нельзя напрямую создать экземпляры. Они выполняют роль базовых классов для других классов, которые предоставляют реализацию недостающих членов. Также классы можно объявить [запечатанными](../../language-reference/keywords/sealed.md), чтобы запретить наследование от них других классов. Дополнительные сведения см. в статье [Абстрактные и запечатанные классы и члены классов](./abstract-and-sealed-classes-and-class-members.md).  
  
## <a name="interfaces"></a>Интерфейсы  

 Классы и структуры могут наследовать несколько интерфейсов. Наследование интерфейса означает, что тип реализует все методы, определенные в этом интерфейсе. Дополнительные сведения см. в статье [Интерфейсы](../interfaces/index.md).  
  
## <a name="generic-types"></a>Универсальные типы  

 Для класса или структуры можно определить один или несколько параметров типа. Клиентский код назначает тип при создании экземпляра типа. Например, класс <xref:System.Collections.Generic.List%601> в пространстве имен <xref:System.Collections.Generic> определен с помощью одного параметра типа. Клиентский код создает экземпляр `List<string>` или `List<int>`, информируя о том, сущности какого типа будут храниться в этом списке. Дополнительные сведения см. в статье [Универсальные шаблоны](../generics/index.md).  
  
## <a name="static-types"></a>Статические типы  

 Классы (но не структуры) могут быть объявлены как [статические](../../language-reference/keywords/static.md). Статический класс может содержать только статические члены. Для него нельзя создать экземпляр с помощью ключевого слова new. При запуске программы в память загружается одна копия такого класса. Доступ к его членам осуществляется через имя класса. Классы и структуры могут содержать статические члены. Дополнительные сведения см. в статье [Статические классы и члены статических классов](./static-classes-and-static-class-members.md).  
  
## <a name="nested-types"></a>Вложенные типы  

 Класс или структура могут быть вложены в другой класс или структуру. Дополнительные сведения см. в разделе [Вложенные типы](./nested-types.md).  
  
## <a name="partial-types"></a>Разделяемые типы  

 Вы можете разделить определение класса, структуры или метода на несколько файлов с кодом. Дополнительные сведения см. в статье [Разделяемые классы и методы](./partial-classes-and-methods.md).  
  
## <a name="object-initializers"></a>Инициализаторы объектов  

 Вы можете создавать и инициализировать экземпляры класса или структуры, а также коллекции объектов, без явного вызова соответствующих конструкторов. Дополнительные сведения см. в статье [Инициализаторы объектов и коллекций](./object-and-collection-initializers.md).  
  
## <a name="anonymous-types"></a>Анонимные типы  

 В некоторых ситуациях нет смысла или пользы создавать именованный класс, например при заполнении списка структурами данных, которые не будут сохраняться или передаваться другому методу. В таких случаях можно использовать анонимные типы. Дополнительные сведения см. в статье [Анонимные типы](./anonymous-types.md).  
  
## <a name="extension-methods"></a>Методы расширения  

 Вы можете "расширить" класс, даже не создавая производного класса. Для этого можно создать отдельный тип и вызывать его методы так, как если бы они принадлежали исходному типу. Дополнительные сведения см. в разделе [Методы расширения](./extension-methods.md).  
  
## <a name="implicitly-typed-local-variables"></a>Неявно типизированные локальные переменные  

 Внутри метода класса или структуры можно использовать неявное типизирование, чтобы компилятор самостоятельно определял правильный тип во время компиляции. Дополнительные сведения см. в статье [Неявно типизированные локальные переменные (руководство по программированию на C#)](./implicitly-typed-local-variables.md).  

## <a name="records"></a>Записи

В C# 9 появился тип `record`, ссылочный тип, который можно создать вместо класса или структуры. Записи — это классы со встроенным поведением для инкапсуляции данных в неизменяемых типах. Запись предоставляет следующие возможности:

* краткий синтаксис для создания ссылочного типа с неизменяемыми свойствами;

* равенство значений.

  Две переменные типа записи равны, если определения типов записей идентичны и если для каждого поля значения в обеих записях равны. Это отличается от классов, которые используют равенство ссылок: две переменные типа класса равны, если они ссылаются на один и тот же объект.

* Краткий синтаксис для обратимого изменения.

  Выражение `with` позволяет создать новый экземпляр записи, который является копией существующего экземпляра, но в котором изменены значения указанных свойств.

* Встроенное форматирование для отображения.

  Метод `ToString` выводит имя типа записи и имена и значения общих свойств.

* Поддержка иерархий наследования.

  Наследование поддерживается, так как запись по сути является классом, а не структурой.

Дополнительные сведения см. в статье [Записи](../../language-reference/builtin-types/record.md).

## <a name="c-language-specification"></a>Спецификация языка C#  

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]  
  
## <a name="see-also"></a>См. также

- [Руководство по программированию на C#](../index.md)
