---
title: Руководство по программированию на C#. Объекты
description: Для определения типов объектов в C# используется определение класса или структуры. В объектно-ориентированном языке, таком как C#, программа состоит из динамически взаимодействующих объектов.
ms.date: 02/03/2021
helpviewer_keywords:
- objects [C#], about objects
- variables [C#]
ms.assetid: af4a5230-fbf3-4eea-95e1-8b883c2f845c
ms.openlocfilehash: df549b76c5bd49fa91424915928527ec14d7689c
ms.sourcegitcommit: 65af0f0ad316858882845391d60ef7e303b756e8
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2021
ms.locfileid: "99585718"
---
# <a name="objects-c-programming-guide"></a>Объекты (Руководство по программированию на C#)

Определение класса или структуры подобно чертежу, на котором указаны действия, выполняемые типом. В сущности, объект является блоком памяти, выделенной и настроенной в соответствии с чертежом. Программа может создать множество объектов одного класса. Объекты также называют экземплярами. Они могут храниться либо в именованной переменной, либо в массиве или коллекции. Клиентский код — это код, использующий эти переменные для вызова методов и доступа к открытым свойствам объекта. В объектно-ориентированном языке, таком как C#, стандартная программа состоит из нескольких динамически взаимодействующих объектов.  
  
> [!NOTE]
> Поведение статических типов отличается от описанного здесь поведения. Дополнительные сведения см. в статье [Статические классы и члены статических классов](./static-classes-and-static-class-members.md).
  
## <a name="struct-instances-vs-class-instances"></a>Экземпляры структуры и Экземпляры классов  

 Так как классы являются ссылочными типами, в переменной объекта класса хранится ссылка на адрес объекта в управляемой куче. Если первому объекту назначен второй объект того же типа, обе переменные ссылаются на объект, расположенный по данному адресу. Эта особенность обсуждается более подробно далее в этом разделе.  
  
 Экземпляры классов создаются с помощью [оператора new](../../language-reference/operators/new-operator.md). В приведенном ниже примере `Person` является типом, а `person1` и `person2` — экземплярами или объектами этого типа.  
  
 [!code-csharp[csProgGuideStatements#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#30)]  
  
 Так как структуры являются типами значений, в переменной объекта структуры хранится копия всего объекта. Экземпляры структур также можно создавать с помощью оператора `new`, однако он не является обязательным, как показано в следующем примере:  
  
 [!code-csharp[csProgGuideStatements#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#31)]  
  
 Память для `p1` и `p2` выделена в стеке потока. Эта память освобождается вместе с типом или методом, в котором она объявляется. Эта одна из причин того, почему структуры копируются при присваивании. Напротив, при выходе всех ссылок на объект из области действия среда CLR автоматически освобождает память (выполняет сборку мусора), выделенную для экземпляра класса. Возможность детерминированного уничтожения объекта класса, имеющаяся в C++, в данном случае отсутствует. Дополнительные сведения о сборке мусора в .NET см. в статье [Сборка мусора](../../../standard/garbage-collection/index.md).  
  
> [!NOTE]
> В среде CLR процесс выделения и освобождения памяти в управляемой куче значительно оптимизирован. В большинстве случаев нет существенной разницы в затратах производительности на выделение экземпляра класса в куче и выделение экземпляра структуры в стеке.
  
## <a name="object-identity-vs-value-equality"></a>Идентификация объектов и равенство значений  

 Сравнивая два объекта на предмет равенства, сначала необходимо определить, нужно ли узнать, представляют ли две переменные один объект в памяти или значения одного или нескольких их полей являются равными. Если вы планируете сравнить значения, следует решить, являются ли объекты экземплярами типов значений (структурами) или ссылочными типами (классами, делегатами, массивами).  
  
- Чтобы определить, ссылаются ли два экземпляра класса на одно расположение в памяти (то есть имеют одинаковый *идентификатор*), воспользуйтесь статическим методом <xref:System.Object.Equals%2A>. (<xref:System.Object?displayProperty=nameWithType> является неявным базовым классом для всех типов значений и ссылочных типов, включая структуры и классы, определенные пользователем.)  
  
- Чтобы определить, имеют ли поля экземпляра в двух экземплярах структуры одинаковые значения, воспользуйтесь методом <xref:System.ValueType.Equals%2A?displayProperty=nameWithType>. Так как все структуры неявно наследуются от <xref:System.ValueType?displayProperty=nameWithType>, метод можно вызвать непосредственно в объекте, как показано в следующем примере:  
  
 [!code-csharp[csProgGuideStatements#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#32)]  
  
 В некоторых случаях `Equals` в реализации <xref:System.ValueType?displayProperty=nameWithType> использует упаковку-преобразование и отражение. Сведения о том, как обеспечить эффективный алгоритм равенства, соответствующий вашему типу, см. в статье [Руководство по программированию на C#. Как определить равенства значений для типа](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md).

- Чтобы определить, равны ли значения полей в двух экземплярах класса, можно воспользоваться методом <xref:System.Object.Equals%2A> или [оператором ==](../../language-reference/operators/equality-operators.md#equality-operator-). Однако их следует использовать, только если они переопределены или перегружены классом с целью предоставления пользовательского определение равенства для объектов этого типа. Класс может также реализовывать интерфейс <xref:System.IEquatable%601> или интерфейс <xref:System.Collections.Generic.IEqualityComparer%601>. Оба интерфейса предоставляют методы, которые можно использовать для проверки равенства значений. При создании собственных классов, переопределяющих `Equals`, обязательно выполните инструкции из руководства по [определению равенства значений для типа ](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md) и <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.
  
## <a name="related-sections"></a>Связанные разделы  

 Дополнительные сведения:  
  
- [Классы](./classes.md)  
  
- [Конструкторы](./constructors.md)  
  
- [Методы завершения](./destructors.md)  
  
- [События](../events/index.md)  
  
## <a name="see-also"></a>См. также

- [Руководство по программированию на C#](../index.md)
- [object](../../language-reference/builtin-types/reference-types.md)
- [Наследование](./inheritance.md)
- [class](../../language-reference/keywords/class.md)
- [Типы структур](../../language-reference/builtin-types/struct.md)
- [Оператор new](../../language-reference/operators/new-operator.md)
- [Система общих типов CTS](../../../standard/base-types/common-type-system.md)
