---
title: Общие сведения о делегатах
description: Общие сведения о делегатах, обзор связанных с ними основных понятий и обсуждение целей разработки языка для делегатов.
ms.date: 02/02/2021
ms.technology: csharp-fundamentals
ms.assetid: 59b61d77-84e5-457b-8da5-fb5f24ca6ed6
ms.openlocfilehash: 72086301a6dd0552ab25baf732978802ad62669b
ms.sourcegitcommit: 4df8e005c074ceb1f978f007b222fe253be2baf3
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/04/2021
ms.locfileid: "99548348"
---
# <a name="introduction-to-delegates"></a>Общие сведения о делегатах

Делегаты предоставляют механизм *позднего связывания* в .NET. Позднее связывание означает, что создается алгоритм, где вызывающий объект также предоставляет по крайней мере один метод, который реализует часть алгоритма.

Например, рассмотрим сортировку списка звезд в астрономическом приложении.
Можно отсортировать звезды по расстоянию от Земли, по величине или по воспринимаемой яркости.

Во всех этих случаях метод Sort() выполняет, по сути, одно и то же: упорядочивает элементы в списке на основе некоего сравнения. Для каждого порядка сортировки используется разный код, сравнивающий две звезды.

Такого рода решения использовались в программном обеспечении в течение полувека.
Концепция использования делегатов в языке C# обеспечивает первоклассную поддержку языка и безопасность типов.

Как вы увидите далее в этой серии статей, код C#, создаваемый для подобных алгоритмов, является строго типизированным и использует правила языка и компилятор для соответствия типов аргументам и типам возвращаемых значений.

В C# 9 для похожих сценариев, где требуется больший контроль над соглашением о вызовах, были добавлены [указатели на функции](~/_csharplang/proposals/csharp-9.0/function-pointers.md). Код, связанный с делегатом, вызывается с помощью виртуального метода, добавленного к типу делегата. Используя указатели функций, можно указать другие соглашения.

## <a name="language-design-goals-for-delegates"></a>Цели разработки языка для делегатов

Разработчики, использующие язык, определили несколько целей для функций, которые в итоге стали делегатами.

Группе разработчиков требовалась общая языковая конструкция, которую можно было бы использовать для любых алгоритмов позднего связывания. Делегаты позволяют разработчикам изучить одну концепцию и применять ее для решения множества различных задач программного обеспечения.

Во-вторых, команде нужна поддержка одиночных и многоадресных вызовов методов. (Многоадресные делегаты — это делегаты, которые объединяют в цепочку несколько вызовов методов.
Вы увидите примеры [далее в этой серии](delegate-class.md).)

Группа разработчиков хотела, чтобы делегаты поддерживали ту же безопасность типа, ожидаемую от всех конструкций C#.

Наконец группа пришла к выводу, что шаблон событий является определенным шаблоном, где использование делегатов (или любого алгоритма позднего связывания) очень эффективно. Разработчикам требовалось, чтобы код для делегатов служил основой для шаблона событий .NET.

Результатом всей этой работы стала поддержка делегатов и событий в C# и .NET. В оставшихся статьях в этом разделе будут рассматриваться возможности языка, поддержка библиотек и распространенные идиомы, которые применяются при работе с делегатами.

Вы узнаете о ключевом слове `delegate` и коде, который он создает. Вы узнаете о функциях в классе `System.Delegate` и их использовании. Вы научитесь создавать типобезопасные делегаты и ознакомитесь со способами создания методов, которые можно вызывать с помощью делегатов. Вы также узнаете, как работать с делегатами и событиями с помощью лямбда-выражения. Вы увидите, каким образом делегаты становятся одними из стандартных блоков для LINQ. Вы узнаете, что делегаты являются основой для шаблона событий .NET, и определите их отличия.

Итак, начнем.

[Вперед](delegate-class.md)
