<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1052;&#1086;&#1076;&#1077;&#1083;&#1100; &#1072;&#1074;&#1090;&#1086;&#1084;&#1072;&#1090;&#1080;&#1079;&#1072;&#1094;&#1080;&#1080; &#1087;&#1086;&#1083;&#1100;&#1079;&#1086;&#1074;&#1072;&#1090;&#1077;&#1083;&#1100;&#1089;&#1082;&#1086;&#1075;&#1086; &#1080;&#1085;&#1090;&#1077;&#1088;&#1092;&#1077;&#1081;&#1089;&#1072; &#1087;&#1086;&#1083;&#1100;&#1079;&#1086;&#1074;&#1072;&#1090;&#1077;&#1083;&#1100;&#1089;&#1082;&#1086;&#1075;&#1086; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1072; &#1091;&#1087;&#1088;&#1072;&#1074;&#1083;&#1077;&#1085;&#1080;&#1103; WPF | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1052;&#1086;&#1076;&#1077;&#1083;&#1100; &#1072;&#1074;&#1090;&#1086;&#1084;&#1072;&#1090;&#1080;&#1079;&#1072;&#1094;&#1080;&#1080; &#1087;&#1086;&#1083;&#1100;&#1079;&#1086;&#1074;&#1072;&#1090;&#1077;&#1083;&#1100;&#1089;&#1082;&#1086;&#1075;&#1086; &#1080;&#1085;&#1090;&#1077;&#1088;&#1092;&#1077;&#1081;&#1089;&#1072; &#1087;&#1086;&#1083;&#1100;&#1079;&#1086;&#1074;&#1072;&#1090;&#1077;&#1083;&#1100;&#1089;&#1082;&#1086;&#1075;&#1086; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1072; &#1091;&#1087;&#1088;&#1072;&#1074;&#1083;&#1077;&#1085;&#1080;&#1103; WPF | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="ui-automation-of-a-wpf-custom-control">Модель автоматизации пользовательского интерфейса пользовательского элемента управления WPF</h1>

<p>Модель автоматизации пользовательского интерфейса Майкрософт предоставляет единый общий интерфейс, который клиенты могут использовать для проверки или использования пользовательских интерфейсов различных платформ и инфраструктур автоматизации. Автоматизация пользовательского интерфейса обеспечивает проверку кода качества (тестирования), так и приложениями со специальными возможностями, такие как средства чтения с экрана для проверки элементов пользовательского интерфейса и моделирования пользовательского взаимодействия с ними из другого кода. Сведения о Автоматизация пользовательского интерфейса на всех платформах см. в разделе, посвященном специальным возможностям.</p>
<p>В этом разделе описывается реализация серверного поставщика автоматизации пользовательского интерфейса для пользовательского элемента управления, применяемого в приложении WPF. WPF поддерживает Автоматизация пользовательского интерфейса с помощью дерева одноранговых объектов автоматизации, которое сопутствует дереву элементов интерфейса пользователя. Тестовый код и приложения с поддержкой специальных возможностей могут использовать одноранговые объекты автоматизации напрямую (для внутрипроцессного кода) или через универсальный интерфейс, предоставляемый Автоматизация пользовательского интерфейса.</p>
<p><a name="AutomationPeerClasses"></a></p>
<h2 id="automation-peer-classes">Одноранговые классы автоматизации</h2>
<p>Элементы управления WPF поддерживают Автоматизация пользовательского интерфейса посредством дерева одноранговых классов, производных от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer">AutomationPeer</a>. В соответствии с соглашением имена одноранговых классов начинаются с имени класса элемента управления, к которому добавляется строка &quot;AutomationPeer&quot;. Например <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.buttonautomationpeer">ButtonAutomationPeer</a> — это одноранговый класс для <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.button">Button</a> класс элемента управления. Одноранговые классы примерно похожи на типы элементов управления Автоматизация пользовательского интерфейса, но относятся к элементам WPF. Код автоматизации, обращающийся к приложениям WPF через интерфейс Автоматизация пользовательского интерфейса, не использует одноранговые классы автоматизации напрямую, но код автоматизации в том же пространстве процесса может использовать их напрямую.</p>
<p><a name="BuiltInAutomationPeerClasses"></a></p>
<h2 id="built-in-automation-peer-classes">Встроенные одноранговые классы автоматизации</h2>
<p>Элементы реализуют одноранговый класс автоматизации, если они принимают взаимодействие пользователя с интерфейсом или содержат информацию, необходимую пользователям приложений для чтения с экрана. Не все визуальные элементы WPF имеют одноранговые классы автоматизации. Примеры классов, реализующих одноранговые объекты автоматизации: <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.button">Button</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.textbox">TextBox</a>, и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.label">Label</a>. Примерами классов, не реализующих одноранговые объекты автоматизации являются классами, производными от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.decorator">Decorator</a>, такие как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.border">Border</a>и классы, основанные на <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a>, такие как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a>.</p>
<p>Базовый <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.control">Control</a> класс не имеет соответствующего однорангового класса. Если требуется, чтобы одноранговый класс соответствовал пользовательскому элементу управления, производный от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.control">Control</a>, необходимо создать производный класс пользовательского однорангового <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.frameworkelementautomationpeer">FrameworkElementAutomationPeer</a>.</p>
<p><a name="SecurityConsiderations"></a></p>
<h2 id="security-considerations-for-derived-peers">Вопросы безопасности для производных одноранговых классов</h2>
<p>Одноранговые классы автоматизации должны работать в среде с частичным доверием. Код в сборке UIAutomationClient не настроен для выполнения в среде с частичным доверием и код однорангового класса автоматизации не должен ссылаться на эту сборку. Вместо этого следует использовать классы в сборке UIAutomationTypes. Например, следует использовать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.automationelementidentifiers">AutomationElementIdentifiers</a> класса из сборки UIAutomationTypes, который соответствует <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.automationelement">AutomationElement</a> класс в сборке UIAutomationClient. В коде однорангового класса автоматизации можно безопасно ссылаться на сборку UIAutomationTypes.</p>
<p><a name="PeerNavigation"></a></p>
<h2 id="peer-navigation">Навигация по одноранговым объектам</h2>
<p>После обнаружения однорангового объекта автоматизации, внутрипроцессный код может перемещаться по дереву одноранговых путем вызова объекта <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.getchildren">GetChildren</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.getparent">GetParent</a> методы. Перемещение между WPF элементов в элементе управления поддерживается реализацией однорангового узла <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.getchildrencore">GetChildrenCore</a> метод. Система модели автоматизации пользовательского интерфейса вызывает этот метод для построения дерева подэлементов, содержащихся в элементе управления (например, элементов списка в элементе управления &quot;список&quot; (ListBox)). Значение по умолчанию <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.uielementautomationpeer.getchildrencore">UIElementAutomationPeer.GetChildrenCore</a> метод обходит визуальное дерево элементов для построения дерева одноранговых объектов автоматизации. Пользовательские элементы управления переопределяют этот метод для предоставления дочерних элементов клиентам автоматизации, возвращая одноранговые объекты автоматизации элементов, которые передают информацию или разрешают взаимодействие с пользователем.</p>
<p><a name="Customizations"></a></p>
<h2 id="customizations-in-a-derived-peer">Настройка производного однорангового класса</h2>
<p>Все классы, производные от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement">UIElement</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.contentelement">ContentElement</a> содержат защищенный виртуальный метод <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.oncreateautomationpeer">OnCreateAutomationPeer</a>. WPF вызывает <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.oncreateautomationpeer">OnCreateAutomationPeer</a> для получения однорангового объекта автоматизации для каждого элемента управления. Код автоматизации может использовать одноранговый объект для получения информации о характеристиках и функциях элемента управления и моделирования интерактивного использования. Пользовательский элемент управления, поддерживающий автоматизацию необходимо переопределить <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.oncreateautomationpeer">OnCreateAutomationPeer</a> и возвращать экземпляр класса, производного от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer">AutomationPeer</a>. Например, если пользовательский элемент управления является производным от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.buttonbase">ButtonBase</a> класса, то объект, возвращенный <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.oncreateautomationpeer">OnCreateAutomationPeer</a> должен быть производным от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.buttonbaseautomationpeer">ButtonBaseAutomationPeer</a>.</p>
<p>При реализации пользовательского элемента управления необходимо переопределить методы &quot;Core&quot; базового однорангового класса автоматизации, которые описывают специфическое поведение пользовательского элемента управления.</p>
<h3 id="override-oncreateautomationpeer">Переопределение метода OnCreateAutomationPeer</h3>
<p>Переопределить <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.oncreateautomationpeer">OnCreateAutomationPeer</a> метод для пользовательского элемента управления так, чтобы он возвращал объект поставщика, который должен прямо или косвенно наследующие от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer">AutomationPeer</a>.</p>
<h3 id="override-getpattern">Переопределение метода GetPattern</h3>
<p>Одноранговые классы автоматизации упрощают некоторые аспекты реализации поставщиков Автоматизация пользовательского интерфейса на стороне сервера, но одноранговые классы автоматизации пользовательских элементов управления по-прежнему должны обрабатывать интерфейсы шаблонов. Как и поставщиках, отличных от WPF, одноранговые классы поддерживают шаблоны элементов управления, предоставляя реализации интерфейсов в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.provider">System.Windows.Automation.Provider</a> пространства имен, такие как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.provider.iinvokeprovider">IInvokeProvider</a>. Интерфейсы шаблонов элементов управления могут быть реализованы самим одноранговым классом или другим объектом. Реализация однорангового узла <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.getpattern">GetPattern</a> возвращает объект, который поддерживает указанный шаблон. Автоматизация пользовательского интерфейса код вызывает <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.uielementautomationpeer.getpattern">GetPattern</a> метода с указанием <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.patterninterface">PatternInterface</a> значение перечисления. Переопределенный <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.uielementautomationpeer.getpattern">GetPattern</a> должен возвращать объект, который реализует заданный шаблон. Если элемент управления не имеет пользовательской реализации шаблона, можно вызвать реализацию базового типа <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.getpattern">GetPattern</a> для извлечения его реализации или значение null, если шаблон не поддерживается для данного типа элемента управления. Например, пользовательский элемент управления NumericUpDown может быть присвоено значение в диапазоне, поэтому его Автоматизация пользовательского интерфейса одноранговый <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.provider.irangevalueprovider">IRangeValueProvider</a> интерфейс. В следующем примере показан способ однорангового узла <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.uielementautomationpeer.getpattern">GetPattern</a> метод переопределяется, чтобы реагировать на них <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.patterninterface#System_Windows_Automation_Peers_PatternInterface_RangeValue">PatternInterface.RangeValue</a> значение.</p>
<pre><code class="lang-csharp" name="CustomControlNumericUpDown#GetPattern">public override object GetPattern(PatternInterface patternInterface)
{
    if (patternInterface == PatternInterface.RangeValue)
    {
        return this;
    }
    return base.GetPattern(patternInterface);
}
</code></pre>
<p>Объект <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.uielementautomationpeer.getpattern">GetPattern</a> метод также может указывать подэлемент в качестве поставщика шаблона. В следующем коде показано, как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.itemscontrol">ItemsControl</a> передает обработку шаблона в одноранговый своих внутренних прокрутки <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.scrollviewer">ScrollViewer</a> элемента управления.</p>
<pre><code class="lang-csharp">public override object GetPattern(PatternInterface patternInterface)  
{  
    if (patternInterface == PatternInterface.Scroll)  
    {  
        ItemsControl owner = (ItemsControl) base.Owner;  
  
        // ScrollHost is internal to the ItemsControl class  
        if (owner.ScrollHost != null)  
        {  
            AutomationPeer peer = UIElementAutomationPeer.CreatePeerForElement(owner.ScrollHost);  
            if ((peer != null) &amp;&amp; (peer is IScrollProvider))  
            {  
                peer.EventsSource = this;  
                return (IScrollProvider) peer;  
            }  
        }  
    }  
    return base.GetPattern(patternInterface);  
}  
</code></pre>
<pre><code class="lang-vb">Public Class Class1  
    Public Overrides Function GetPattern(ByVal patternInterface__1 As PatternInterface) As Object  
        If patternInterface1 = PatternInterface.Scroll Then  
            Dim owner As ItemsControl = DirectCast(MyBase.Owner, ItemsControl)  
  
            ' ScrollHost is internal to the ItemsControl class  
            If owner.ScrollHost IsNot Nothing Then  
                Dim peer As AutomationPeer = UIElementAutomationPeer.CreatePeerForElement(owner.ScrollHost)  
                If (peer IsNot Nothing) AndAlso (TypeOf peer Is IScrollProvider) Then  
                    peer.EventsSource = Me  
                    Return DirectCast(peer, IScrollProvider)  
                End If  
            End If  
        End If  
        Return MyBase.GetPattern(patternInterface1)  
    End Function  
End Class  
</code></pre>
<p>Чтобы указать подэлемент для обработки шаблона, этот код получает объект подэлемента, создает одноранговый объект с помощью <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.uielementautomationpeer.createpeerforelement">CreatePeerForElement</a> задает метод, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.eventssource">EventsSource</a> свойства нового однорангового текущему одноранговому узлу и возвращает новый одноранговый элемент. Установка <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.eventssource">EventsSource</a> на подэлемент подэлементе предотвращает появление в дереве одноранговых классов автоматизации и определяет все события, вызванные вложенного элемента как исходящие из элемента управления, указанного в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.eventssource">EventsSource</a>. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.scrollviewer">ScrollViewer</a> Управления не отображается в дереве модели автоматизации, а события прокрутки, которые она создает выглядят как исходящие от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.itemscontrol">ItemsControl</a> объекта.</p>
<h3 id="override-core-methods">Переопределение методов &quot;Core&quot;</h3>
<p>Код автоматизации получает информацию о вашем элементе управления, вызывая открытые методы однорангового класса. Чтобы предоставить информацию о своем элементе управления, переопределите все методы, имена которых заканчиваются на &quot;Core&quot;, если ваша реализация элемента управления отличается от той, которая имеется в базовом одноранговом классе автоматизации. Как минимум, необходимо реализовать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.getclassnamecore">GetClassNameCore</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.getautomationcontroltypecore">GetAutomationControlTypeCore</a> методы, как показано в следующем примере.</p>
<pre><code class="lang-csharp" name="CustomControlNumericUpDown#CoreOverrides">protected override string GetClassNameCore()
{
    return &quot;NumericUpDown&quot;;
}

protected override AutomationControlType GetAutomationControlTypeCore()
{
    return AutomationControlType.Spinner;
}
</code></pre>
<p>Реализация <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.getautomationcontroltypecore">GetAutomationControlTypeCore</a> описывает ваш элемент управления, возвращая <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.controltype">ControlType</a> значение. Хотя вы можете вернуть <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.controltype.custom">ControlType.Custom</a>, следует возвращать один более конкретные типы элементов управления, если он точно описывает ваш элемент управления. Возвращаемое значение, равное <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.controltype.custom">ControlType.Custom</a> требует дополнительной работы поставщика, чтобы реализовать Автоматизация пользовательского интерфейса, и Автоматизация пользовательского интерфейса клиентские продукты не могут предвидеть структуру элемента управления, взаимодействие с клавиатурой и возможных шаблонах элементов управления.</p>
<p>Реализуйте <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.iscontentelementcore">IsContentElementCore</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.iscontrolelementcore">IsControlElementCore</a> методов для обозначения ли элемент управления содержимым данных или выполняет интерактивную роль в пользовательском интерфейсе (или оба). По умолчанию оба метода возвращают значение <code>true</code>. Эти параметры повышают удобство использования средств автоматизации (например, средств чтения с экрана), которые могут использовать эти методы для фильтрации дерева автоматизации. Если ваш <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.getpattern">GetPattern</a> метод передает обработку шаблона в одноранговый объект подэлемента однорангового элемента <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.iscontrolelementcore">IsControlElementCore</a> метод может возвращать значение false, чтобы скрыть одноранговый узел подэлемента в дереве автоматизации. Например, прокрутка в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.listbox">ListBox</a> обрабатывается <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.scrollviewer">ScrollViewer</a>и одноранговый элемент автоматизации для <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.patterninterface#System_Windows_Automation_Peers_PatternInterface_Scroll">PatternInterface.Scroll</a> возвращается <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.getpattern">GetPattern</a> метод <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.scrollviewerautomationpeer">ScrollViewerAutomationPeer</a> , связанный с <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.listboxautomationpeer">ListBoxAutomationPeer</a>. Таким образом <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.iscontrolelementcore">IsControlElementCore</a> метод <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.scrollviewerautomationpeer">ScrollViewerAutomationPeer</a> возвращает <code>false</code>, так что <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.scrollviewerautomationpeer">ScrollViewerAutomationPeer</a> не отображается в дереве модели автоматизации.</p>
<p>Одноранговый класс автоматизации должен предоставлять необходимые значения по умолчанию для вашего элемента управления. Обратите внимание, что XAML, который ссылается на элемент управления может переопределить реализации базовых методов путем включения <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.automationproperties">AutomationProperties</a> атрибуты. Например, следующий код XAML создает кнопку, которая имеет два настраиваемых свойства Автоматизация пользовательского интерфейса.</p>
<pre><code class="lang-xaml">&lt;Button AutomationProperties.Name=&quot;Special&quot;   
    AutomationProperties.HelpText=&quot;This is a special button.&quot;/&gt;  
</code></pre>
<h3 id="implement-pattern-providers">Реализация поставщиков шаблонов</h3>
<p>Интерфейсы, реализованные с помощью пользовательского поставщика, объявляются явно в том случае, если элемент-владелец является производным непосредственно от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.control">Control</a>. Например, в следующем коде объявляется одноранговый объект для объекта <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.control">Control</a> , реализующий значение диапазона.</p>
<pre><code class="lang-csharp">public class RangePeer1 : FrameworkElementAutomationPeer, IRangeValueProvider { }  
</code></pre>
<pre><code class="lang-vb">Public Class RangePeer1  
    Inherits FrameworkElementAutomationPeer  
    Implements IRangeValueProvider  
End Class  
</code></pre>
<p>Владелец-элемент управления, производного от определенного типа элемента управления, такие как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.rangebase">RangeBase</a>, одноранговый узел может быть производным от эквивалентного производного однорангового класса. В этом случае одноранговый узел будет наследовать от класса <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.rangebaseautomationpeer">RangeBaseAutomationPeer</a>, который предоставляет базовую реализацию <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.provider.irangevalueprovider">IRangeValueProvider</a>. В следующем коде показано объявление такого однорангового класса.</p>
<pre><code class="lang-csharp">public class RangePeer2 : RangeBaseAutomationPeer { }  
</code></pre>
<pre><code class="lang-vb">Public Class RangePeer2  
    Inherits RangeBaseAutomationPeer  
End Class  
</code></pre>
<p>Пример реализации см. в разделе <a href="https://go.microsoft.com/fwlink/?LinkID=160025">Пример пользовательского элемента управления NumericUpDown с темой и поддержкой модели автоматизации пользовательского интерфейса</a>.</p>
<h3 id="raise-events">Создание событий</h3>
<p>Клиенты автоматизации могут подписаться на события автоматизации. Пользовательские элементы управления должны сообщать об изменениях для управления состоянием, вызвав <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.raiseautomationevent">RaiseAutomationEvent</a> метод. Аналогично, при изменении значения свойства следует вызывать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.automation.peers.automationpeer.raisepropertychangedevent">RaisePropertyChangedEvent</a> метод. В приведенном ниже коде показано, как получить одноранговый объект из кода элемента управления и вызвать метод для создания события. В качестве меры оптимизации код также определяет, имеются ли прослушиватели для этого типа событий. Создание событий только при наличии соответствующих прослушивателей позволяет избежать лишней нагрузки и помогает сохранять должную скорость отклика элемента управления.</p>
<pre><code class="lang-csharp" name="CustomControlNumericUpDown#RaiseEventFromControl">if (AutomationPeer.ListenerExists(AutomationEvents.PropertyChanged))
{
    NumericUpDownAutomationPeer peer =
        UIElementAutomationPeer.FromElement(nudCtrl) as NumericUpDownAutomationPeer;

    if (peer != null)
    {
        peer.RaisePropertyChangedEvent(
            RangeValuePatternIdentifiers.ValueProperty,
            (double)oldValue,
            (double)newValue);
    }
}
</code></pre><h2 id="see-also">См. также</h2>
<ul>
<li><a href="../../ui-automation/ui-automation-overview.md">Общие сведения о модели автоматизации пользовательского интерфейса</a></li>
<li><a href="https://go.microsoft.com/fwlink/?LinkID=160025">Пользовательского элемента управления NumericUpDown с темой и пример Поддержка автоматизации пользовательского интерфейса</a></li>
<li><a href="../../ui-automation/server-side-ui-automation-provider-implementation.md">Реализация поставщика автоматизации пользовательского интерфейса на стороне сервера</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span><a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru">Неофициальная документация по .NET на русском языке</a>. Лицензия: <a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru/blob/main/LICENSE">CC-BY 4.0</a>. Основано на <a href="https://docs.microsoft.com/ru-ru/dotnet/">документации по .NET с Microsoft Docs</a><br>Generated by <strong>DocFX</strong></span><script type="text/javascript">(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(65150713, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/65150713" style="position:absolute; left:-9999px;" alt=""></div></noscript>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
