<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1054;&#1073;&#1097;&#1080;&#1077; &#1089;&#1074;&#1077;&#1076;&#1077;&#1085;&#1080;&#1103; &#1086; &#1087;&#1072;&#1085;&#1077;&#1083;&#1103;&#1093; | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1054;&#1073;&#1097;&#1080;&#1077; &#1089;&#1074;&#1077;&#1076;&#1077;&#1085;&#1080;&#1103; &#1086; &#1087;&#1072;&#1085;&#1077;&#1083;&#1103;&#1093; | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="panels-overview">Общие сведения о панелях</h1>

<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> элементы являются компонентами, которые управляют отображением элементов — их размер и измерения, их положение и расположение их дочернего содержимого. Windows Presentation Foundation (WPF) Предоставляет ряд предопределенных <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> элементы, а также возможность создания пользовательских <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> элементов.</p>
<p>В этом разделе содержатся следующие подразделы.</p>
<ul>
<li><p><a href="#Panels_view_from_10000_feet">Класс Panel</a></p>
</li>
<li><p><a href="#Panels_declared_members">Общие члены элементов Panel</a></p>
</li>
<li><p><a href="#Panels_derived_elements">Производные элементы Panel</a></p>
</li>
<li><p><a href="#Panels_main_UI_elements">Панели пользовательского интерфейса</a></p>
</li>
<li><p><a href="#Panels_nested_panel_elements">Вложенные элементы Panel</a></p>
</li>
<li><p><a href="#Panels_custom_panel_elements">Пользовательские элементы Panel</a></p>
</li>
<li><p><a href="#Panels_global_localization">Поддержка локализации и глобализации</a></p>
</li>
</ul>
<p><a name="Panels_view_from_10000_feet"></a></p>
<h2 id="the-panel-class">Класс Panel</h2>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> является базовым классом для всех элементов, которые предоставляют макет поддерживает в Windows Presentation Foundation (WPF). Производные <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> элементы используются для размещения и упорядочения элементов в Язык XAML и кода.</p>
<p>WPF включает полный набор реализаций производных панели, позволяющих использовать множество сложных макетов. Эти производные классы предоставляют свойства и методы, с помощью которых реализуется большинство стандартных сценариев пользовательский интерфейс. Разработчики, которые не смогли найти поведение упорядочение дочерних, удовлетворяющих их потребности могут создать новые макеты путем переопределения <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.arrangeoverride">ArrangeOverride</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.measureoverride">MeasureOverride</a> методы. Дополнительные сведения о поведении пользовательских макетов см. в разделе <a href="#Panels_custom_panel_elements">Пользовательские элементы Panel</a>.</p>
<p><a name="Panels_declared_members"></a></p>
<h2 id="panel-common-members">Общие члены элементов Panel</h2>
<p>Все <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> элементы поддерживают базовые изменения размеров и положения свойств, определенных <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement">FrameworkElement</a>, в том числе <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.height">Height</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.width">Width</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.horizontalalignment">HorizontalAlignment</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.verticalalignment">VerticalAlignment</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.margin">Margin</a>, и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.layouttransform">LayoutTransform</a>. Дополнительные сведения о свойствах, которые определяются изменения положения <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement">FrameworkElement</a>, см. в разделе <a href="../advanced/alignment-margins-and-padding-overview.html">выравнивание, Margins и Padding Обзор</a>.</p>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> предоставляет дополнительные свойства, которые очень важны в понимании и использовании макета. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel.background">Background</a> Свойство используется для заполнения области между границами производного элемента панели с <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.media.brush">Brush</a>. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel.children">Children</a> Представляет коллекцию дочерних элементов, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> включает в себя. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel.internalchildren">InternalChildren</a> представляет содержимое <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel.children">Children</a> коллекции, а также элементы, созданные привязкой данных. Оба свойства состоят <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.uielementcollection">UIElementCollection</a> дочерних элементов, размещенных в родительском элементе <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a>.</p>
<p>Панель также предоставляет <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel.zindex">Panel.ZIndex</a> присоединенного свойства, который может использоваться для получения многослойного в производном <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a>. Элементы панели <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel.children">Children</a> коллекции с более высоким <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel.zindex">Panel.ZIndex</a> значение отображаются перед элементами с более низким <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel.zindex">Panel.ZIndex</a> значение. Это особенно полезно для панелей такие как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> что позволяет дочерним элементам совместно использовать одну систему координат.</p>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> также определяет <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel.onrender">OnRender</a> метод, который может использоваться для переопределения поведения представления по умолчанию <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a>.</p>
<h4 id="attached-properties">Вложенные свойства</h4>
<p>Производные элементы панели широко используют вложенные свойства. Вложенное свойство представляет собой особую форму свойства зависимости, не имеющего обычной &quot;оболочки&quot; свойства среда CLR. Вложенные свойства имеют специальный синтаксис в языке Язык XAML, с которым можно познакомиться в некоторых из следующих примеров.</p>
<p>Одной из целей вложенного свойства является предоставление возможности дочерним элементам хранить уникальные значения свойства, фактически определенные в родительском элементе. Случаем применения данной возможности является уведомление родительского элемента со стороны дочерних элементов о способе их представления в пользовательский интерфейс, что очень полезно при создании макета приложения. Дополнительные сведения см. в разделе <a href="../advanced/attached-properties-overview.html">Общие сведения о вложенных свойствах</a>.</p>
<p><a name="Panels_derived_elements"></a></p>
<h2 id="derived-panel-elements">Производные элементы Panel</h2>
<p>Многие объекты являются производными от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a>, но не все из них предназначены для использования в качестве поставщиков корневого макета. Существует шесть определенных классов панелей (<a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel">StackPanel</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.virtualizingstackpanel">VirtualizingStackPanel</a>, и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.wrappanel">WrapPanel</a>), предназначенных специально для создания приложений ИП.</p>
<p>Каждый элемент панели имеет собственные специальные возможности, представленные в следующей таблице.</p>
<table>
<thead>
<tr>
<th>Имя элемента</th>
<th>Панель пользовательского интерфейса?</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a></td>
<td>Да</td>
<td>Определяет область, внутри которой можно явным образом разместить дочерние элементы с помощью координатах по отношению к <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> области.</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a></td>
<td>Да</td>
<td>Определяет область, в которой можно горизонтально либо вертикально упорядочивать дочерние элементы относительно друг друга.</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a></td>
<td>Да</td>
<td>Определяет область с таблицей переменного размера, состоящей из столбцов и строк. Дочерние элементы <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> может быть настроено с помощью <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.margin">Margin</a> свойство.</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel">StackPanel</a></td>
<td>Да</td>
<td>Выравнивает дочерние элементы в одну линию, ориентированную горизонтально или вертикально.</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.tabpanel">TabPanel</a></td>
<td>Нет</td>
<td>Обрабатывает макет кнопок вкладки в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.tabcontrol">TabControl</a>.</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.toolbaroverflowpanel">ToolBarOverflowPanel</a></td>
<td>Нет</td>
<td>Упорядочивает содержимое в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.toolbar">ToolBar</a> элемента управления.</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.uniformgrid">UniformGrid</a></td>
<td>Нет</td>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.uniformgrid">UniformGrid</a> используется для упорядочивания дочерних элементов в сетке с ячейками одинакового размера.</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.virtualizingpanel">VirtualizingPanel</a></td>
<td>Нет</td>
<td>Предоставляет базовый класс для панелей, которые могут &quot;виртуализировать&quot; дочерние коллекции.</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.virtualizingstackpanel">VirtualizingStackPanel</a></td>
<td>Да</td>
<td>Упорядочивает и виртуализирует одну строку содержимого, ориентированную горизонтально или вертикально.</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.wrappanel">WrapPanel</a></td>
<td>Да</td>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.wrappanel">WrapPanel</a> Размещает дочерние элементы последовательно слева направо, перенося содержимое на следующую строку на границе содержащего поля. Дальнейшее упорядочивание происходит последовательно сверху вниз или слева направо в зависимости от значения <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.wrappanel.orientation">Orientation</a> свойство.</td>
</tr>
</tbody>
</table>
<p><a name="Panels_main_UI_elements"></a></p>
<h2 id="user-interface-panels">Панели пользовательского интерфейса</h2>
<p>Существует шесть классов панелей, доступных в WPF , оптимизированы для поддержки ИП сценариев: <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel">StackPanel</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.virtualizingstackpanel">VirtualizingStackPanel</a>, и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.wrappanel">WrapPanel</a>. Эти элементы панели являются простыми в использовании, гибкими и достаточно широкими для большинства приложений.</p>
<p>Каждый производный <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> элемент рассматривает ограничения размеров по-разному. Основные сведения о том, как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> обрабатывает ограничения в горизонтальном или вертикальном направлении, может сделать макет более предсказуемой.</p>
<table>
<thead>
<tr>
<th><strong>Имя панели</strong></th>
<th><strong>Оси x</strong></th>
<th><strong>Измерение y</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a></td>
<td>Ограничено содержимым</td>
<td>Ограничено содержимым</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a></td>
<td>Ограничено</td>
<td>Ограничено</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel">StackPanel</a> (Вертикальная ориентация)</td>
<td>Ограничено</td>
<td>Ограничено содержимым</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel">StackPanel</a> (Горизонтальная ориентация)</td>
<td>Ограничено содержимым</td>
<td>Ограничено</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a></td>
<td>Ограничено</td>
<td>Ограничено, кроме случаев где <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.gridunittype#System_Windows_GridUnitType_Auto">Auto</a> применяется к строкам и столбцам</td>
</tr>
<tr>
<td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.wrappanel">WrapPanel</a></td>
<td>Ограничено содержимым</td>
<td>Ограничено содержимым</td>
</tr>
</tbody>
</table>
<p>С более подробными описаниями и примерами использования каждого из этих элементов можно ознакомиться ниже.</p>
<p><a name="Panels_overview_Canvas_subsection"></a></p>
<h3 id="canvas">Canvas</h3>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> Элемент позволяет размещать содержимое в соответствии с абсолютными <em>x -</em> и <em>y -</em> координаты. Элементы могут быть нарисованы в уникальном месте или, если элементы занимают одни координаты, порядок, в котором они отображаются в разметке, определяется порядком, в котором нарисованы эти элементы.</p>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> предоставляет самую гибкую поддержку макета любого <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a>. Для определения области холста используются свойства высоты и ширины и элементам внутри назначаются абсолютные координаты относительно области родительского <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a>. Четыре вложенных свойства, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas.left">Canvas.Left</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas.top">Canvas.Top</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas.right">Canvas.Right</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas.bottom">Canvas.Bottom</a>, точное управление расположением объекта внутри <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a>, позволяя разработчику для размещения и упорядочения элементов на экране.</p>
<h4 id="cliptobounds-within-a-canvas">Свойство ClipToBounds в элементе Canvas</h4>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> можно расположить дочерние элементы в любом месте на экране, даже в координатах, находящихся за пределами определены собственные <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.height">Height</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.width">Width</a>. Кроме того <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> не влияет размер его дочерних элементов. Таким образом, это возможно для дочернего элемента может быть нарисован поверх других элементов за пределами ограничивающего прямоугольника родительского <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a>. По умолчанию <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> является разрешение дочерним элементам отображаться за пределами границ родительского <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a>. Если такое поведение нежелательно, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.cliptobounds">ClipToBounds</a> можно присвоить свойство <code>true</code>. В результате <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> отсечения до собственного размера. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> является единственным элементом макета, позволяет дочерним элементам отображаться вне границ элемента.</p>
<p>Такое поведение графически показано в <a href="https://go.microsoft.com/fwlink/?LinkID=160050">примере сравнения свойств ширины</a>.</p>
<h4 id="defining-and-using-a-canvas">Определение и использование Canvas</h4>
<p>Объект <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> можно легко создать с помощью Язык XAML или кода. Следующий пример демонстрирует, как использовать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> для размещения содержимого по абсолютным. Этот код рисует три квадрата со стороной в 100 пикселей. Первый квадрат — красный и координаты (<em>x, y</em>) его левого верхнего угла имеют значение (0, 0). Второй квадрат — зеленый, и его левый верхний угол имеет координаты (100, 100). Он находится ниже и правее первого квадрата. Третий квадрат — синий, его левый верхний угол имеет координаты (50, 50); таким образом, он пересекается с правым нижним углом первого квадрата и левым верхним углом второго. Так как третий квадрат накладывается последним, он будет отображаться поверх первых двух квадратов — то есть пересекающиеся участки принимают цвет третьей фигуры.</p>
<pre><code class="lang-csharp" name="CanvasOvwSample#1">
// Create the application's main window
mainWindow = new Window ();
mainWindow.Title = &quot;Canvas Sample&quot;;

// Create the Canvas
myParentCanvas = new Canvas();
myParentCanvas.Width = 400;
myParentCanvas.Height = 400;

// Define child Canvas elements
myCanvas1 = new Canvas();
myCanvas1.Background = Brushes.Red;
myCanvas1.Height = 100;
myCanvas1.Width = 100;
Canvas.SetTop(myCanvas1, 0);
Canvas.SetLeft(myCanvas1, 0);

myCanvas2 = new Canvas();
myCanvas2.Background = Brushes.Green;
myCanvas2.Height = 100;
myCanvas2.Width = 100;
Canvas.SetTop(myCanvas2, 100);
Canvas.SetLeft(myCanvas2, 100);

myCanvas3 = new Canvas();
myCanvas3.Background = Brushes.Blue;
myCanvas3.Height = 100;
myCanvas3.Width = 100;
Canvas.SetTop(myCanvas3, 50);
Canvas.SetLeft(myCanvas3, 50);

// Add child elements to the Canvas' Children collection
myParentCanvas.Children.Add(myCanvas1);
myParentCanvas.Children.Add(myCanvas2);
myParentCanvas.Children.Add(myCanvas3);

// Add the parent Canvas as the Content of the Window Object
mainWindow.Content = myParentCanvas;
mainWindow.Show ();

</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><pre><code class="lang-xaml" name="CanvasOvwSample#1">&lt;Page WindowTitle=&quot;Canvas Sample&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&gt;
  &lt;Canvas Height=&quot;400&quot; Width=&quot;400&quot;&gt;
    &lt;Canvas Height=&quot;100&quot; Width=&quot;100&quot; Top=&quot;0&quot; Left=&quot;0&quot; Background=&quot;Red&quot;/&gt;
    &lt;Canvas Height=&quot;100&quot; Width=&quot;100&quot; Top=&quot;100&quot; Left=&quot;100&quot; Background=&quot;Green&quot;/&gt;
    &lt;Canvas Height=&quot;100&quot; Width=&quot;100&quot; Top=&quot;50&quot; Left=&quot;50&quot; Background=&quot;Blue&quot;/&gt;
  &lt;/Canvas&gt;
&lt;/Page&gt;
</code></pre>
<p>Скомпилированное приложение возвращает новый ИП, который выглядит следующим образом.</p>
<p><img src="media/panel-intro-canvas.PNG" alt="Обычный элемент Canvas." title="panel_intro_canvas"></p>
<p><a name="Panels_overview_DockPanel_subsection"></a></p>
<h3 id="dockpanel">DockPanel</h3>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a> Элемент использует <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel.dock">DockPanel.Dock</a> присоединенного свойства, заданные в дочерних элементах содержимого для размещения содержимого у границ контейнера. Когда <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel.dock">DockPanel.Dock</a> присваивается <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dock#System_Windows_Controls_Dock_Top">Top</a> или <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dock#System_Windows_Controls_Dock_Bottom">Bottom</a>, оно располагает дочерние элементы выше или ниже друг с другом. Когда <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel.dock">DockPanel.Dock</a> присваивается <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dock#System_Windows_Controls_Dock_Left">Left</a> или <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dock#System_Windows_Controls_Dock_Right">Right</a>, оно располагает дочерние элементы слева или справа от друг с другом. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel.lastchildfill">LastChildFill</a> Свойство определяет положение последнего элемента, добавленного в качестве дочернего элемента <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a>.</p>
<p>Можно использовать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a> для размещения группы связанных элементов управления, таких как набор кнопок. Кроме того, можно использовать его для создания разделенного на панели ИП, похожего на интерфейс Microsoft Outlook.</p>
<h4 id="sizing-to-content">Изменение размеров в зависимости от содержимого</h4>
<p>Если его <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.height">Height</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.width">Width</a> свойства не указаны, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a> размеры его содержимого. Размер может увеличиваться или уменьшаться, чтобы вместить его дочерние элементы. Тем не менее, если заданы эти свойства и больше нет свободного места для следующего указанного дочернего элемента <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a> не отображает этот дочерний элемент и последующие дочерние элементы и не измеряет последующие дочерние элементы.</p>
<h4 id="lastchildfill">LastChildFill</h4>
<p>По умолчанию последний дочерний узел данного <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a> элемент «заполнит» оставшееся незанятое пространство. Если такое поведение нежелательно, задайте <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel.lastchildfill">LastChildFill</a> свойства <code>false</code>.</p>
<h4 id="defining-and-using-a-dockpanel">Определение и использование DockPanel</h4>
<p>В следующем примере демонстрируется разделение пространства с помощью <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a>. Пять <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.border">Border</a> элементы добавляются как дочерние элементы родительского узла <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a>. Каждый из них использует свое свойство размещения <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a> для разделения пространства. Последний элемент &quot;заполняет&quot; оставшееся незанятое пространство.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><pre><code class="lang-csharp" name="DockPanelOvwSample#1">
// Create the application's main window
mainWindow = new Window ();
mainWindow.Title = &quot;DockPanel Sample&quot;;

// Create the DockPanel
DockPanel myDockPanel = new DockPanel();
myDockPanel.LastChildFill = true;

// Define the child content
Border myBorder1 = new Border();
myBorder1.Height = 25;
myBorder1.Background = Brushes.SkyBlue;
myBorder1.BorderBrush = Brushes.Black;
myBorder1.BorderThickness = new Thickness(1);
DockPanel.SetDock(myBorder1, Dock.Top);
TextBlock myTextBlock1 = new TextBlock();
myTextBlock1.Foreground = Brushes.Black;
myTextBlock1.Text = &quot;Dock = Top&quot;;
myBorder1.Child = myTextBlock1;

Border myBorder2 = new Border();
myBorder2.Height = 25;
myBorder2.Background = Brushes.SkyBlue;
myBorder2.BorderBrush = Brushes.Black;
myBorder2.BorderThickness = new Thickness(1);
DockPanel.SetDock(myBorder2, Dock.Top);
TextBlock myTextBlock2 = new TextBlock();
myTextBlock2.Foreground = Brushes.Black;
myTextBlock2.Text = &quot;Dock = Top&quot;;
myBorder2.Child = myTextBlock2;

Border myBorder3 = new Border();
myBorder3.Height = 25;
myBorder3.Background = Brushes.LemonChiffon;
myBorder3.BorderBrush = Brushes.Black;
myBorder3.BorderThickness = new Thickness(1);
DockPanel.SetDock(myBorder3, Dock.Bottom);
TextBlock myTextBlock3 = new TextBlock();
myTextBlock3.Foreground = Brushes.Black;
myTextBlock3.Text = &quot;Dock = Bottom&quot;;
myBorder3.Child = myTextBlock3;

Border myBorder4 = new Border();
myBorder4.Width = 200;
myBorder4.Background = Brushes.PaleGreen;
myBorder4.BorderBrush = Brushes.Black;
myBorder4.BorderThickness = new Thickness(1);
DockPanel.SetDock(myBorder4, Dock.Left);
TextBlock myTextBlock4 = new TextBlock();
myTextBlock4.Foreground = Brushes.Black;
myTextBlock4.Text = &quot;Dock = Left&quot;;
myBorder4.Child = myTextBlock4;

Border myBorder5 = new Border();
myBorder5.Background = Brushes.White;
myBorder5.BorderBrush = Brushes.Black;
myBorder5.BorderThickness = new Thickness(1);
TextBlock myTextBlock5 = new TextBlock();
myTextBlock5.Foreground = Brushes.Black;
myTextBlock5.Text = &quot;This content will Fill the remaining space&quot;;
myBorder5.Child = myTextBlock5;

// Add child elements to the DockPanel Children collection
myDockPanel.Children.Add(myBorder1);
myDockPanel.Children.Add(myBorder2);
myDockPanel.Children.Add(myBorder3);
myDockPanel.Children.Add(myBorder4);
myDockPanel.Children.Add(myBorder5);

// Add the parent Canvas as the Content of the Window Object
mainWindow.Content = myDockPanel;
mainWindow.Show ();

</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><pre><code class="lang-xaml" name="DockPanelOvwSample#1">&lt;Page xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; WindowTitle=&quot;DockPanel Sample&quot;&gt;
  &lt;DockPanel LastChildFill=&quot;True&quot;&gt;
    &lt;Border Height=&quot;25&quot; Background=&quot;SkyBlue&quot; BorderBrush=&quot;Black&quot; BorderThickness=&quot;1&quot; DockPanel.Dock=&quot;Top&quot;&gt;
      &lt;TextBlock Foreground=&quot;Black&quot;&gt;Dock = &quot;Top&quot;&lt;/TextBlock&gt;
    &lt;/Border&gt;
    &lt;Border Height=&quot;25&quot; Background=&quot;SkyBlue&quot; BorderBrush=&quot;Black&quot; BorderThickness=&quot;1&quot; DockPanel.Dock=&quot;Top&quot;&gt;
      &lt;TextBlock Foreground=&quot;Black&quot;&gt;Dock = &quot;Top&quot;&lt;/TextBlock&gt;
    &lt;/Border&gt;
    &lt;Border Height=&quot;25&quot; Background=&quot;LemonChiffon&quot; BorderBrush=&quot;Black&quot; BorderThickness=&quot;1&quot; DockPanel.Dock=&quot;Bottom&quot;&gt;
      &lt;TextBlock Foreground=&quot;Black&quot;&gt;Dock = &quot;Bottom&quot;&lt;/TextBlock&gt;
    &lt;/Border&gt;
    &lt;Border Width=&quot;200&quot; Background=&quot;PaleGreen&quot; BorderBrush=&quot;Black&quot; BorderThickness=&quot;1&quot; DockPanel.Dock=&quot;Left&quot;&gt;
      &lt;TextBlock Foreground=&quot;Black&quot;&gt;Dock = &quot;Left&quot;&lt;/TextBlock&gt;
    &lt;/Border&gt;
    &lt;Border Background=&quot;White&quot; BorderBrush=&quot;Black&quot; BorderThickness=&quot;1&quot;&gt;
      &lt;TextBlock Foreground=&quot;Black&quot;&gt;This content will &quot;Fill&quot; the remaining space&lt;/TextBlock&gt;
    &lt;/Border&gt;
  &lt;/DockPanel&gt;
&lt;/Page&gt;
</code></pre>
<p>Скомпилированное приложение возвращает новый ИП, который выглядит следующим образом.</p>
<p><img src="media/panel-intro-dockpanel.PNG" alt="Обычный сценарий DockPanel." title="panel_intro_dockpanel"></p>
<p><a name="Panels_overview_Grid_subsection"></a></p>
<h3 id="grid">Grid</h3>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> Элемент объединяет возможности абсолютного позиционирования и управления табличными данными. Объект <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> позволяет легко изменять положение и стиль элементов. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> позволяет определить группы столбцов и строк, гибкий и предоставляет возможность распространять информацию о размере между несколькими <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> элементов.</p>
<h4 id="how-is-grid-different-from-table">Чем Grid отличается от Table?</h4>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.documents.table">Table</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> совместно использовать некоторые общие функциональные возможности, но каждый из них лучше всего подходит для различных сценариев. Объект <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.documents.table">Table</a> предназначен для использования в потоковом содержимом (см. в разделе <a href="../advanced/flow-document-overview.html">Общие</a> Дополнительные сведения о потоковом содержимом). Сетки лучше всего использовать внутри форм (по сути в любом месте вне потокового содержимого). В рамках <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.documents.flowdocument">FlowDocument</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.documents.table">Table</a> поддерживает поток такие возможности, как разбиение на страницы, Перекомпоновка столбцов и Выбор содержимого при <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> — нет. Объект <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> с другой стороны лучше всего использовать за пределами <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.documents.flowdocument">FlowDocument</a> по многим причинам, в том числе <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> добавляет элементы на основе индекса строк и столбцов, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.documents.table">Table</a> — нет. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> Элемент позволяет создавать слои дочернего содержимого, позволяя более чем одного элемента существовать внутри одной «ячейки». <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.documents.table">Table</a> не поддерживает слои. Дочерние элементы <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> можно абсолютно позиционировать относительно области границ их «ячейки». <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.documents.table">Table</a> не поддерживает эту функцию. Наконец <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> легче, чем <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.documents.table">Table</a>.</p>
<h4 id="sizing-behavior-of-columns-and-rows">Поведение столбцов и строк при изменении их размера</h4>
<p>Столбцы и строки, определенные в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> можно воспользоваться преимуществами <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.gridunittype#System_Windows_GridUnitType_Star">Star</a> изменения размера, чтобы пропорционально распределить оставшееся пространство. Когда <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.gridunittype#System_Windows_GridUnitType_Star">Star</a> выбран в качестве высоты или ширины строки или столбца, что столбец или строка получает пропорциональную часть оставшегося доступного пространства. Это отличается от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.gridunittype#System_Windows_GridUnitType_Auto">Auto</a>, который распределяет пространство равномерно с учетом размера содержимого столбца или строки. Это значение выражается как <code>*</code> или <code>2*</code> при использовании языка Язык XAML. В первом случае строка или столбец будет получать определенное доступное пространство, а во втором случае — в два раза больше. При объединении этой методики для пропорционального распределения пространства с <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.horizontalalignment">HorizontalAlignment</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.verticalalignment">VerticalAlignment</a> значение <code>Stretch</code> имеется возможность разделения пространства макета в процентах от пространства экрана. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> является единственной панелью макета, может распределять пространство таким образом.</p>
<h4 id="defining-and-using-a-grid">Определение и использование Grid</h4>
<p>В следующем примере демонстрируется построение ИП аналогичного используемому в диалоговом окне Run, доступном в меню &quot;Пуск&quot; Windows.</p>
<pre><code class="lang-csharp" name="GridRunDialog#1">
// Create the Grid.
grid1 = new Grid ();
grid1.Background = Brushes.Gainsboro;
grid1.HorizontalAlignment = HorizontalAlignment.Left;
grid1.VerticalAlignment = VerticalAlignment.Top;
grid1.ShowGridLines = true;
grid1.Width = 425;
grid1.Height = 165;

// Define the Columns.
colDef1 = new ColumnDefinition();
colDef1.Width = new GridLength(1, GridUnitType.Auto);
colDef2 = new ColumnDefinition();
colDef2.Width = new GridLength(1, GridUnitType.Star);
colDef3 = new ColumnDefinition();
colDef3.Width = new GridLength(1, GridUnitType.Star);
colDef4 = new ColumnDefinition();
colDef4.Width = new GridLength(1, GridUnitType.Star);
colDef5 = new ColumnDefinition();
colDef5.Width = new GridLength(1, GridUnitType.Star);
grid1.ColumnDefinitions.Add(colDef1);
grid1.ColumnDefinitions.Add(colDef2);
grid1.ColumnDefinitions.Add(colDef3);
grid1.ColumnDefinitions.Add(colDef4);
grid1.ColumnDefinitions.Add(colDef5);

// Define the Rows.
rowDef1 = new RowDefinition();
rowDef1.Height = new GridLength(1, GridUnitType.Auto);
rowDef2 = new RowDefinition();
rowDef2.Height = new GridLength(1, GridUnitType.Auto);
rowDef3 = new RowDefinition();
rowDef3.Height = new GridLength(1, GridUnitType.Star);
rowDef4 = new RowDefinition();
rowDef4.Height = new GridLength(1, GridUnitType.Auto);
grid1.RowDefinitions.Add(rowDef1);
grid1.RowDefinitions.Add(rowDef2);
grid1.RowDefinitions.Add(rowDef3);
grid1.RowDefinitions.Add(rowDef4);

// Add the Image.
img1 = new Image();
img1.Source = new System.Windows.Media.Imaging.BitmapImage(new Uri(&quot;runicon.png&quot;, UriKind.Relative));
Grid.SetRow(img1, 0);
Grid.SetColumn(img1, 0);

// Add the main application dialog.
txt1 = new TextBlock();
txt1.Text = &quot;Type the name of a program, folder, document, or Internet resource, and Windows will open it for you.&quot;;
txt1.TextWrapping = TextWrapping.Wrap;
Grid.SetColumnSpan(txt1, 4);
Grid.SetRow(txt1, 0);
Grid.SetColumn(txt1, 1);

// Add the second text cell to the Grid.
txt2 = new TextBlock();
txt2.Text = &quot;Open:&quot;;
Grid.SetRow(txt2, 1);
Grid.SetColumn(txt2, 0);

// Add the TextBox control.
tb1 = new TextBox();
Grid.SetRow(tb1, 1);
Grid.SetColumn(tb1, 1);
Grid.SetColumnSpan(tb1, 5);

// Add the buttons.
button1 = new Button();
button2 = new Button();
button3 = new Button();
button1.Content = &quot;OK&quot;;
button2.Content = &quot;Cancel&quot;;
button3.Content = &quot;Browse ...&quot;;
Grid.SetRow(button1, 3);
Grid.SetColumn(button1, 2);
button1.Margin = new Thickness(10, 0, 10, 15);
button2.Margin = new Thickness(10, 0, 10, 15);
button3.Margin = new Thickness(10, 0, 10, 15);
Grid.SetRow(button2, 3);
Grid.SetColumn(button2, 3);
Grid.SetRow(button3, 3);
Grid.SetColumn(button3, 4);

grid1.Children.Add(img1);
grid1.Children.Add(txt1);
grid1.Children.Add(txt2);
grid1.Children.Add(tb1);
grid1.Children.Add(button1);
grid1.Children.Add(button2);
grid1.Children.Add(button3);

mainWindow.Content = grid1;
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Скомпилированное приложение возвращает новый ИП, который выглядит следующим образом.</p>
<p><img src="media/avalon-run-dialog.PNG" alt="Обычный элемент сетки." title="avalon_run_dialog"></p>
<p><a name="Panels_overview_StackPanel_subsection"></a></p>
<h3 id="stackpanel">StackPanel</h3>
<p>Объект <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel">StackPanel</a> позволяет «выстраивать» элементы в определенном направлении. По умолчанию направление стека является вертикальным. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel.orientation">Orientation</a> Свойство может использоваться для управления потоком содержимого.</p>
<h4 id="stackpanel-vs-dockpanel">Сравнение StackPanel и DockPanel</h4>
<p>Несмотря на то что <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a> можно также «стопку» дочерних элементов, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel">StackPanel</a> не дают аналогичных результатов в некоторых случаях использования. Например, порядок дочерних элементов может повлиять на их размер в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a> , но не в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel">StackPanel</a>. Это обусловлено <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel">StackPanel</a> направлении стека в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.double.positiveinfinity">PositiveInfinity</a>, тогда как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a> измеряет только доступный размер.</p>
<p>Следующий пример демонстрирует это ключевое различие.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><pre><code class="lang-csharp" name="StackPanelOvw4#1">
// Create the application's main window
mainWindow = new Window ();
mainWindow.Title = &quot;StackPanel vs. DockPanel&quot;;

// Add root Grid
myGrid = new Grid();
myGrid.Width = 175;
myGrid.Height = 150;
RowDefinition myRowDef1 = new RowDefinition();
RowDefinition myRowDef2 = new RowDefinition();
myGrid.RowDefinitions.Add(myRowDef1);
myGrid.RowDefinitions.Add(myRowDef2);

// Define the DockPanel
myDockPanel = new DockPanel();
Grid.SetRow(myDockPanel, 0);

//Define an Image and Source
Image myImage = new Image();
BitmapImage bi = new BitmapImage();
bi.BeginInit();
bi.UriSource = new Uri(&quot;smiley_stackpanel.png&quot;, UriKind.Relative);
bi.EndInit();
myImage.Source = bi;

Image myImage2 = new Image();
BitmapImage bi2 = new BitmapImage();
bi2.BeginInit();
bi2.UriSource = new Uri(&quot;smiley_stackpanel.png&quot;, UriKind.Relative);
bi2.EndInit();
myImage2.Source = bi2;

Image myImage3 = new Image();
BitmapImage bi3 = new BitmapImage();
bi3.BeginInit();
bi3.UriSource = new Uri(&quot;smiley_stackpanel.PNG&quot;, UriKind.Relative);
bi3.EndInit();
myImage3.Stretch = Stretch.Fill;
myImage3.Source = bi3;

// Add the images to the parent DockPanel
myDockPanel.Children.Add(myImage);
myDockPanel.Children.Add(myImage2);
myDockPanel.Children.Add(myImage3);

//Define a StackPanel
myStackPanel = new StackPanel();
myStackPanel.Orientation = Orientation.Horizontal;
Grid.SetRow(myStackPanel, 1);

Image myImage4 = new Image();
BitmapImage bi4 = new BitmapImage();
bi4.BeginInit();
bi4.UriSource = new Uri(&quot;smiley_stackpanel.png&quot;, UriKind.Relative);
bi4.EndInit();
myImage4.Source = bi4;

Image myImage5 = new Image();
BitmapImage bi5 = new BitmapImage();
bi5.BeginInit();
bi5.UriSource = new Uri(&quot;smiley_stackpanel.png&quot;, UriKind.Relative);
bi5.EndInit();
myImage5.Source = bi5;

Image myImage6 = new Image();
BitmapImage bi6 = new BitmapImage();
bi6.BeginInit();
bi6.UriSource = new Uri(&quot;smiley_stackpanel.PNG&quot;, UriKind.Relative);
bi6.EndInit();
myImage6.Stretch = Stretch.Fill;
myImage6.Source = bi6;

// Add the images to the parent StackPanel
myStackPanel.Children.Add(myImage4);
myStackPanel.Children.Add(myImage5);
myStackPanel.Children.Add(myImage6);

// Add the layout panels as children of the Grid
myGrid.Children.Add(myDockPanel);
myGrid.Children.Add(myStackPanel);

// Add the Grid as the Content of the Parent Window Object
mainWindow.Content = myGrid;
mainWindow.Show ();

</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><pre><code class="lang-xaml" name="StackPanelOvw4#1">&lt;Page xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
      WindowTitle=&quot;StackPanel vs. DockPanel&quot;&gt;
  &lt;Grid Width=&quot;175&quot; Height=&quot;150&quot;&gt;
    &lt;Grid.ColumnDefinitions&gt;
      &lt;ColumnDefinition /&gt;
    &lt;/Grid.ColumnDefinitions&gt;
    &lt;Grid.RowDefinitions&gt;
      &lt;RowDefinition /&gt;
      &lt;RowDefinition /&gt;
    &lt;/Grid.RowDefinitions&gt;
    
    &lt;DockPanel Grid.Column=&quot;0&quot; Grid.Row=&quot;0&quot;&gt;
      &lt;Image Source=&quot;smiley_stackpanel.png&quot; /&gt;
      &lt;Image Source=&quot;smiley_stackpanel.png&quot; /&gt;
      &lt;Image Source=&quot;smiley_stackpanel.png&quot; Stretch=&quot;Fill&quot;/&gt;
    &lt;/DockPanel&gt;

    &lt;StackPanel Grid.Column=&quot;0&quot; Grid.Row=&quot;1&quot;  Orientation=&quot;Horizontal&quot;&gt;
      &lt;Image Source=&quot;smiley_stackpanel.png&quot; /&gt;
      &lt;Image Source=&quot;smiley_stackpanel.png&quot; /&gt;
      &lt;Image Source=&quot;smiley_stackpanel.png&quot; Stretch=&quot;Fill&quot;/&gt;
    &lt;/StackPanel&gt;
    &lt;/Grid&gt;
&lt;/Page&gt;
</code></pre>
<p>На этом рисунке видна разница в поведении отрисовки.</p>
<p><img src="media/layout-smiley-stackpanel.PNG" alt="Снимок экрана: Сравнение StackPanel и снимок экрана DockPanel" title="layout_smiley_stackpanel"></p>
<h4 id="defining-and-using-a-stackpanel">Определение и использование StackPanel</h4>
<p>Следующий пример демонстрирует, как использовать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel">StackPanel</a> для создания набора вертикально расположенных кнопок. Для горизонтального расположения задайте <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel.orientation">Orientation</a> свойства <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.orientation#System_Windows_Controls_Orientation_Horizontal">Horizontal</a>.</p>
<pre><code class="lang-csharp" name="StackPanel_ovw2#1">
// Create the application's main window
mainWindow = new Window ();
mainWindow.Title = &quot;StackPanel Sample&quot;;

// Define the StackPanel
myStackPanel = new StackPanel();
myStackPanel.HorizontalAlignment = HorizontalAlignment.Left;
myStackPanel.VerticalAlignment = VerticalAlignment.Top;

// Define child content
Button myButton1 = new Button();
myButton1.Content = &quot;Button 1&quot;;
Button myButton2 = new Button();
myButton2.Content = &quot;Button 2&quot;;
Button myButton3 = new Button();
myButton3.Content = &quot;Button 3&quot;;

// Add child elements to the parent StackPanel
myStackPanel.Children.Add(myButton1);
myStackPanel.Children.Add(myButton2);
myStackPanel.Children.Add(myButton3);

// Add the StackPanel as the Content of the Parent Window Object
mainWindow.Content = myStackPanel;
mainWindow.Show ();

</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Скомпилированное приложение возвращает новый ИП, который выглядит следующим образом.</p>
<p><img src="media/panel-intro-stackpanel.PNG" alt="Обычный элемент StackPanel." title="panel_intro_stackpanel"></p>
<p><a name="Panels_overview_VirtualizingStackPanel_subsection"></a></p>
<h4 id="virtualizingstackpanel">VirtualizingStackPanel</h4>
<p>WPF также предоставляет разновидность <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel">StackPanel</a> элемент, который автоматически «виртуализирует» привязкой к данным дочернего содержимого. В данном контексте слово &quot;виртуализация&quot; означает способ, с помощью которого подмножество элементов создается из большего количества элементов данных в зависимости от того, какие из элементов отображаются на экране. Как для памяти, так и для процессора затратно создавать большое число элементов пользовательского интерфейса, при том что только несколько из них могут отображаться на экране одновременно. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.virtualizingstackpanel">VirtualizingStackPanel</a> (с помощью функций, предоставляемых <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.virtualizingpanel">VirtualizingPanel</a>) подсчитывает видимые элементы и работает с <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.itemcontainergenerator">ItemContainerGenerator</a> из <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.itemscontrol">ItemsControl</a> (такие как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.listbox">ListBox</a> или <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.listview">ListView</a>) создавать только элементы для видимых элементов.</p>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.virtualizingstackpanel">VirtualizingStackPanel</a> Элемент автоматически устанавливается как узел элементов для элементов управления, такие как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.listbox">ListBox</a>. При размещении данных присоединенной коллекции, содержимое будет автоматически виртуализировано, до тех пор, пока оно находится в границах <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.scrollviewer">ScrollViewer</a>. Это значительно повышает производительность при размещении большого числа дочерних элементов.</p>
<p>Следующая разметка демонстрирует использование <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.virtualizingstackpanel">VirtualizingStackPanel</a> качестве узла элементов. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.virtualizingstackpanel.isvirtualizingproperty">VirtualizingStackPanel.IsVirtualizingProperty</a> Присоединенное свойство должно быть присвоено <code>true</code> (по умолчанию) для виртуализации, возникает.</p>
<pre><code class="lang-xaml" name="VirtualizingStackPanel_Intro#1">&lt;StackPanel DataContext=&quot;{Binding Source={StaticResource Leagues}}&quot;&gt;
    &lt;TextBlock Text=&quot;{Binding XPath=@name}&quot; FontFamily=&quot;Arial&quot; FontSize=&quot;18&quot; Foreground=&quot;Black&quot;/&gt;
        &lt;ListBox VirtualizingStackPanel.IsVirtualizing=&quot;True&quot; 
                 ItemsSource=&quot;{Binding XPath=Team}&quot; 
                 ItemTemplate=&quot;{DynamicResource NameDataStyle}&quot;/&gt;      
&lt;/StackPanel&gt;
</code></pre>
<p><a name="Panels_overview_WrapPanel"></a></p>
<h3 id="wrappanel">WrapPanel</h3>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.wrappanel">WrapPanel</a> используется для размещения дочерних элементов в последовательности слева направо, перенося содержимое на следующую строку при достижении границы родительского контейнера. Содержимое может быть ориентировано горизонтально или вертикально. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.wrappanel">WrapPanel</a> полезно, когда пользовательский интерфейс сценариев. Его также можно использовать для установления единого размера для всех его дочерних элементов.</p>
<p>Следующий пример демонстрирует создание <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.wrappanel">WrapPanel</a> для отображения <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.button">Button</a> элементов управления, которые переносятся при достижении границы контейнера.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><pre><code class="lang-csharp" name="WrapPanel_Intro#1">
// Create the application's main window
mainWindow = new System.Windows.Window();
mainWindow.Title = &quot;WrapPanel Sample&quot;;


// Instantiate a new WrapPanel and set properties
myWrapPanel = new WrapPanel();
myWrapPanel.Background = System.Windows.Media.Brushes.Azure;
myWrapPanel.Orientation = Orientation.Horizontal;
myWrapPanel.Width = 200;
myWrapPanel.HorizontalAlignment = HorizontalAlignment.Left;
myWrapPanel.VerticalAlignment = VerticalAlignment.Top;

// Define 3 button elements. The last three buttons are sized at width
// of 75, so the forth button wraps to the next line.
btn1 = new Button();
btn1.Content = &quot;Button 1&quot;;
btn1.Width = 200;
btn2 = new Button();
btn2.Content = &quot;Button 2&quot;;
btn2.Width = 75;
btn3 = new Button();
btn3.Content = &quot;Button 3&quot;;
btn3.Width = 75;
btn4 = new Button();
btn4.Content = &quot;Button 4&quot;;
btn4.Width = 75;

// Add the buttons to the parent WrapPanel using the Children.Add method.
myWrapPanel.Children.Add(btn1);
myWrapPanel.Children.Add(btn2);
myWrapPanel.Children.Add(btn3);
myWrapPanel.Children.Add(btn4);

// Add the WrapPanel to the MainWindow as Content
mainWindow.Content = myWrapPanel;
mainWindow.Show();

</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><pre><code class="lang-xaml" name="WrapPanel_Intro#1">&lt;Page xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; WindowTitle=&quot;WrapPanel Sample&quot;&gt;
  &lt;Border HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Top&quot; BorderBrush=&quot;Black&quot; BorderThickness=&quot;2&quot;&gt;
        &lt;WrapPanel Background=&quot;LightBlue&quot; Width=&quot;200&quot; Height=&quot;100&quot;&gt;
            &lt;Button Width=&quot;200&quot;&gt;Button 1&lt;/Button&gt;
            &lt;Button&gt;Button 2&lt;/Button&gt;
            &lt;Button&gt;Button 3&lt;/Button&gt;
            &lt;Button&gt;Button 4&lt;/Button&gt;
        &lt;/WrapPanel&gt;
  &lt;/Border&gt;    
&lt;/Page&gt;
</code></pre>
<p>Скомпилированное приложение возвращает новый ИП, который выглядит следующим образом.</p>
<p><img src="media/wrappanel-element.PNG" alt="Обычный элемент WrapPanel." title="WrapPanel_Element"></p>
<p><a name="Panels_nested_panel_elements"></a></p>
<h2 id="nested-panel-elements">Вложенные элементы Panel</h2>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> элементы могут быть вложены друг к другу для создания сложных макетов. Это может оказаться очень полезным в ситуациях, где одно <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> идеально подходит для части ИП, но не может удовлетворить потребности другой части ИП.</p>
<p>Практически не существует ограничения объема вложения, которое может поддерживать приложение, но лучше ограничить приложение использованием только тех панелей, которые действительно необходимы для макета. Во многих случаях <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a> элемент может использоваться вместо вложенных панелей благодаря его гибкости в качестве контейнера макета. Это может повысить производительность приложения, убирая ненужные элементы из дерева.</p>
<p>Следующий пример демонстрирует создание ИП , использующего преимущества вложенных <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> элементы, чтобы получить определенный макет. В данном конкретном случае <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a> элемент используется для предоставления ИП структурировать и вложенными <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel">StackPanel</a> элементов, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a>и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> используются для размещения дочерних элементов внутри родительского <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a>.</p>
<pre><code class="lang-csharp" name="Nested_Panels#1">
// Define the DockPanel.
myDockPanel = new DockPanel();

// Add the Left Docked StackPanel
Border myBorder2 = new Border();
myBorder2.BorderThickness = new Thickness(1);
myBorder2.BorderBrush = Brushes.Black;
DockPanel.SetDock(myBorder2, Dock.Left);
StackPanel myStackPanel = new StackPanel();
Button myButton1 = new Button();
myButton1.Content = &quot;Left Docked&quot;;
myButton1.Margin = new Thickness(5);
Button myButton2 = new Button();
myButton2.Content = &quot;StackPanel&quot;;
myButton2.Margin = new Thickness(5);
myStackPanel.Children.Add(myButton1);
myStackPanel.Children.Add(myButton2);
myBorder2.Child = myStackPanel;

// Add the Top Docked Grid.
Border myBorder3 = new Border();
myBorder3.BorderThickness = new Thickness(1);
myBorder3.BorderBrush = Brushes.Black;
DockPanel.SetDock(myBorder3, Dock.Top);
Grid myGrid = new Grid();
myGrid.ShowGridLines = true;
RowDefinition myRowDef1 = new RowDefinition();
RowDefinition myRowDef2 = new RowDefinition();
ColumnDefinition myColDef1 = new ColumnDefinition();
ColumnDefinition myColDef2 = new ColumnDefinition();
ColumnDefinition myColDef3 = new ColumnDefinition();
myGrid.ColumnDefinitions.Add(myColDef1);
myGrid.ColumnDefinitions.Add(myColDef2);
myGrid.ColumnDefinitions.Add(myColDef3);
myGrid.RowDefinitions.Add(myRowDef1);
myGrid.RowDefinitions.Add(myRowDef2);
TextBlock myTextBlock1 = new TextBlock();
myTextBlock1.FontSize = 20;
myTextBlock1.Margin = new Thickness(10);
myTextBlock1.Text = &quot;Grid Element Docked at the Top&quot;;
Grid.SetRow(myTextBlock1, 0);
Grid.SetColumnSpan(myTextBlock1, 3);
Button myButton3 = new Button();
myButton3.Margin = new Thickness(5);
myButton3.Content = &quot;A Row&quot;;
Grid.SetColumn(myButton3, 0);
Grid.SetRow(myButton3, 1);
Button myButton4 = new Button();
myButton4.Margin = new Thickness(5);
myButton4.Content = &quot;of Button&quot;;
Grid.SetColumn(myButton4, 1);
Grid.SetRow(myButton4, 1);
Button myButton5 = new Button();
myButton5.Margin = new Thickness(5);
myButton5.Content = &quot;Elements&quot;;
Grid.SetColumn(myButton5, 2);
Grid.SetRow(myButton5, 1);
myGrid.Children.Add(myTextBlock1);
myGrid.Children.Add(myButton3);
myGrid.Children.Add(myButton4);
myGrid.Children.Add(myButton5);
myBorder3.Child = myGrid;

// Add the Bottom Docked StackPanel.
Border myBorder4 = new Border();
myBorder4.BorderBrush = Brushes.Black;
myBorder4.BorderThickness = new Thickness(1);
DockPanel.SetDock(myBorder4, Dock.Bottom);
StackPanel myStackPanel2 = new StackPanel();
myStackPanel2.Orientation = Orientation.Horizontal;
TextBlock myTextBlock2 = new TextBlock();
myTextBlock2.Text = &quot;This StackPanel is Docked to the Bottom&quot;;
myTextBlock2.Margin = new Thickness(5);
myStackPanel2.Children.Add(myTextBlock2);
myBorder4.Child = myStackPanel2;

// Add the Canvas, that fills remaining space.
Border myBorder5 = new Border();
myBorder4.BorderBrush = Brushes.Black;
myBorder5.BorderThickness = new Thickness(1);
Canvas myCanvas = new Canvas();
myCanvas.ClipToBounds = true;
TextBlock myTextBlock3 = new TextBlock();
myTextBlock3.Text = &quot;Content in the Canvas will Fill the remaining space.&quot;;
Canvas.SetTop(myTextBlock3, 50);
Canvas.SetLeft(myTextBlock3, 50);
Ellipse myEllipse = new Ellipse();
myEllipse.Height = 100;
myEllipse.Width = 125;
myEllipse.Fill = Brushes.CornflowerBlue;
myEllipse.Stroke = Brushes.Aqua;
Canvas.SetTop(myEllipse, 100);
Canvas.SetLeft(myEllipse, 150);
myCanvas.Children.Add(myTextBlock3);
myCanvas.Children.Add(myEllipse);
myBorder5.Child = myCanvas;

// Add child elements to the parent DockPanel.
myDockPanel.Children.Add(myBorder2);
myDockPanel.Children.Add(myBorder3);
myDockPanel.Children.Add(myBorder4);
myDockPanel.Children.Add(myBorder5);
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Скомпилированное приложение возвращает новый ИП, который выглядит следующим образом.</p>
<p><img src="media/nested-panels.PNG" alt="Пользовательский интерфейс, использующий вложенные панели." title="nested_panels"></p>
<p><a name="Panels_custom_panel_elements"></a></p>
<h2 id="custom-panel-elements">Пользовательские элементы Panel</h2>
<p>Хотя WPF предоставляет целый ряд гибких элементов управления макетом, настраиваемый макет, также поведения можно достигнуть путем переопределения <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.arrangeoverride">ArrangeOverride</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.measureoverride">MeasureOverride</a> методы. Пользовательские изменения размеров и положения могут быть выполнены путем определения нового поведения размещения с помощью этих методов переопределения.</p>
<p>Аналогичным образом, пользовательские расширения функциональности макета на основе производных классов (таких как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> или <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a>) можно задать путем переопределения их <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.arrangeoverride">ArrangeOverride</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.measureoverride">MeasureOverride</a> методы.</p>
<p>Следующая разметка демонстрирует создание пользовательского <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a> элемент. Этот новый <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.panel">Panel</a>, определенная как <code>PlotPanel</code>, поддерживает размещение дочерних элементов с использованием жестко <em>x -</em> и <em>y -</em> координаты. В этом примере <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shapes.rectangle">Rectangle</a> элемент (не показан) находится в точке с координатами 50 (<em>x</em>) до 50 (<em>y</em>).</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div><pre><code class="lang-csharp" name="PlotPanel#1">public class PlotPanel : Panel
{
    // Default public constructor
    public PlotPanel()
        : base()
    {
    }

    // Override the default Measure method of Panel
    protected override Size MeasureOverride(Size availableSize)
    {
        Size panelDesiredSize = new Size();

        // In our example, we just have one child.
        // Report that our panel requires just the size of its only child.
        foreach (UIElement child in InternalChildren)
        {
            child.Measure(availableSize);
            panelDesiredSize = child.DesiredSize;
        }

        return panelDesiredSize ;
    }
    protected override Size ArrangeOverride(Size finalSize)
    {
        foreach (UIElement child in InternalChildren)
        {
            double x = 50;
            double y = 50;

            child.Arrange(new Rect(new Point(x, y), child.DesiredSize));
        }
        return finalSize; // Returns the final Arranged size
    }
}
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Более сложные реализации пользовательских панелей можно найти в разделе <a href="https://go.microsoft.com/fwlink/?LinkID=159979">примера создания пользовательской панели с переносом содержимого</a>.</p>
<p><a name="Panels_global_localization"></a></p>
<h2 id="localizationglobalization-support">Поддержка локализации и глобализации</h2>
<p>WPF поддерживает ряд функций, которые помогают в создании локализуемого ИП.</p>
<p>Все элементы панели изначально поддерживают <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.flowdirection">FlowDirection</a> свойство, которое может использоваться для динамического содержимого на основе параметров языкового стандарта или языка пользователя. Дополнительные сведения см. в разделе <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.flowdirection">FlowDirection</a>.</p>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.sizetocontent">SizeToContent</a> Свойство предоставляет механизм, который позволяет разработчикам приложений предвидеть потребности локализованного ИП. С помощью <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.sizetocontent#System_Windows_SizeToContent_WidthAndHeight">WidthAndHeight</a> значение этого свойства родительского <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> всегда динамически изменяет размер в соответствии с размером и не ограничивается искусственных ограничений высоты или ширины.</p>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.dockpanel">DockPanel</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.grid">Grid</a>, и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.stackpanel">StackPanel</a> — это хороший выбор для локализуемых ИП. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas">Canvas</a> Тем не менее, является не лучшим выбором, так как он размещает содержимое абсолютно, что затрудняет локализацию.</p>
<p>Дополнительные сведения о создании приложений WPF с локализуемыми пользовательские интерфейсы (UI) см. в разделе <a href="../advanced/use-automatic-layout-overview.html">Обзор использования автоматической разметки</a>.</p>
<h2 id="see-also">См. также</h2>
<ul>
<li><a href="../getting-started/walkthrough-my-first-wpf-desktop-application.html">Пошаговое руководство. Создание классического приложения WPF</a></li>
<li><a href="https://go.microsoft.com/fwlink/?LinkID=160054">Пример коллекции макетов WPF</a></li>
<li><a href="../advanced/layout.html">Макет</a></li>
<li><a href="https://go.microsoft.com/fwlink/?LinkID=160053">Пример коллекции элементов управления WPF</a></li>
<li><a href="../advanced/alignment-margins-and-padding-overview.html">Общие сведения о свойствах Alignment, Margin, Padding</a></li>
<li><a href="https://go.microsoft.com/fwlink/?LinkID=159979">Создание пользовательского содержимого пример</a></li>
<li><a href="../advanced/attached-properties-overview.html">Общие сведения о вложенных свойствах зависимостей</a></li>
<li><a href="../advanced/use-automatic-layout-overview.html">Обзор использования автоматической разметки</a></li>
<li><a href="../advanced/optimizing-performance-layout-and-design.html">Разметка и разработка</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span><a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru">Неофициальная документация по .NET на русском языке</a>. Лицензия: <a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru/blob/main/LICENSE">CC-BY 4.0</a>. Основано на <a href="https://docs.microsoft.com/ru-ru/dotnet/">документации по .NET с Microsoft Docs</a><br>Generated by <strong>DocFX</strong></span><script type="text/javascript">(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(65150713, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/65150713" style="position:absolute; left:-9999px;" alt=""></div></noscript>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
