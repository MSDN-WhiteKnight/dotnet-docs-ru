<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1052;&#1072;&#1088;&#1082;&#1080;&#1088;&#1086;&#1074;&#1082;&#1072; &#1087;&#1077;&#1088;&#1077;&#1085;&#1072;&#1087;&#1088;&#1072;&#1074;&#1083;&#1077;&#1085;&#1085;&#1099;&#1093; &#1089;&#1086;&#1073;&#1099;&#1090;&#1080;&#1081; &#1082;&#1072;&#1082; &#1086;&#1073;&#1088;&#1072;&#1073;&#1086;&#1090;&#1072;&#1085;&#1085;&#1099;&#1093; &#1080; &#1086;&#1073;&#1088;&#1072;&#1073;&#1086;&#1090;&#1082;&#1072; &#1082;&#1083;&#1072;&#1089;&#1089;&#1086;&#1074; | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1052;&#1072;&#1088;&#1082;&#1080;&#1088;&#1086;&#1074;&#1082;&#1072; &#1087;&#1077;&#1088;&#1077;&#1085;&#1072;&#1087;&#1088;&#1072;&#1074;&#1083;&#1077;&#1085;&#1085;&#1099;&#1093; &#1089;&#1086;&#1073;&#1099;&#1090;&#1080;&#1081; &#1082;&#1072;&#1082; &#1086;&#1073;&#1088;&#1072;&#1073;&#1086;&#1090;&#1072;&#1085;&#1085;&#1099;&#1093; &#1080; &#1086;&#1073;&#1088;&#1072;&#1073;&#1086;&#1090;&#1082;&#1072; &#1082;&#1083;&#1072;&#1089;&#1089;&#1086;&#1074; | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="marking-routed-events-as-handled-and-class-handling">Маркировка перенаправленных событий как обработанных и обработка классов</h1>

<p>Обработчики для перенаправленных событий могут помечать событие как обработанное в данных этого события. Обработка событий эффективно сокращает маршрут. Обработка класса — это концепция программирования, поддерживаемая перенаправленными событиями. Обработчик класса может обрабатывать отдельное перенаправленное событие на уровне класса с помощью обработчика, который вызывается перед любым обработчиком экземпляра в любом экземпляре класса.</p>
<p><a name="prerequisites"></a></p>
<h2 id="prerequisites">Предварительные требования</h2>
<p>В этом разделе описываются основные понятия, представленные в разделе <a href="routed-events-overview.html">Общие сведения о перенаправленных событиях</a>.</p>
<p><a name="When_to_Mark_Events_as_Handled"></a></p>
<h2 id="when-to-mark-events-as-handled">Когда следует помечать события как обработанные</h2>
<p>Если задано значение <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.routedeventargs.handled">Handled</a> свойства <code>true</code> событий данные для перенаправленного события, это называется «маркировка события как обработанного». Нет абсолютного правила, кто должен помечать перенаправленные события как обработанные — разработчик приложения или разработчик элемента управления, который реагирует на существующие или реализует новые перенаправленные события. По большей части концепция «обработанный», вносимая в данные перенаправленного события, должна использоваться в качестве ограниченного протокола для ответов собственного приложения на различные перенаправленные события, предоставленные в API WPF, а также на любые пользовательские перенаправленные события. С другой стороны, главным образом следует помечать перенаправленное событие как обработанное, если код отвечал на перенаправленное событие значительным и относительно законченным образом. Как правило, не должно быть более одного значительного ответа, которому требуется реализация отдельных обработчиков для каждого отдельного перенаправленного события. Если требуются дополнительные ответы, необходимый код должен быть реализован посредством логики приложения, связанной с простым обработчиком, а не с помощью системы перенаправленных событий для переадресации. Понятие того, что является «значительным», также субъективно и зависит от приложения или кода. В качестве общих рекомендаций можно привести следующие примеры «значительного ответа»: установка фокуса, изменение общедоступного состояния, установка свойств, влияющих на визуальное представление, и создание других новых событий. Примеры незначительных ответов: изменение закрытого состояния (без визуального воздействия или программного представления), ведение журнала событий, просмотр аргументов события и выбор не отвечать на него.</p>
<p>Поведение системы перенаправленных событий усиливает эту модель «значительного ответа» для использования обработанного состояния перенаправленного события, поскольку обработчики, добавленные в XAML или в общую подпись <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.addhandler">AddHandler</a> не вызываются в ответ на перенаправленное событие где события данные уже помечено как обработанное. Вы должны проходить через дополнительные усилия, добавить обработчик с <code>handledEventsToo</code> версией параметра (<a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.addhandler#System_Windows_UIElement_AddHandler_System_Windows_RoutedEvent_System_Delegate_System_Boolean_">AddHandler(RoutedEvent, Delegate, Boolean)</a>) для обработки перенаправленных событий, которые помечены как обработанные, более ранними участниками маршрута события.</p>
<p>В некоторых случаях элементы управления сами помечают некоторые перенаправленные события как обработанные. Обработанное перенаправленное событие представляет решение разработчиков элемента управления WPF, что действия этого элемента управления в ответ на перенаправленное событие являются значительными или завершенными в рамках реализации элемента управления, и событие не требует дальнейшей обработки. Обычно это делается путем добавления обработчика класса для события или путем переопределения одного из виртуальных методов обработчика класса, который существует в базовом классе. При необходимости вы по-прежнему можете обойти обработку этого события; см. раздел <a href="#WorkingAroundEventSuppressionByControls">Обход подавления событий элементами управления</a> далее в этой статье.</p>
<p><a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a></p>
<h2 id="preview-tunneling-events-vs-bubbling-events-and-event-handling">События предварительного просмотра по сравнению с событиями восходящей маршрутизации и обработка событий</h2>
<p>Перенаправленные события предварительного просмотра — это события нисходящей маршрутизации через дерево элементов. Выражение «Предварительный просмотр» в соглашении об именовании указывает на общий принцип для событий ввода, согласно которому перенаправленные события предварительного просмотра (нисходящей маршрутизации) вызываются до эквивалентных перенаправленных событий восходящей маршрутизации. Кроме того, перенаправленные события, имеющие пару нисходящей и восходящей маршрутизации, имеют другую логику обработки. Если перенаправленное событие нисходящей маршрутизации (событие предварительного просмотра) помечается прослушивателем событий как обработанное, то перенаправленное событие восходящей маршрутизации будет помечено как обработанное даже до того, как это событие будет получено каким-либо прослушивателем событий восходящей маршрутизации. Перенаправленные события нисходящей и восходящей маршрутизации технически являются отдельными событиями, но они специально совместно используют один и тот же экземпляр данных события, чтобы такое поведение стало возможным.</p>
<p>Связь между перенаправленными событиями нисходящей и восходящей маршрутизации обеспечивается внутренней реализацией того, как любой конкретный класс WPF вызывает свои собственные объявленные перенаправленные события, и это справедливо для пары перенаправленных событий ввода. Но если данная реализация на уровне класса отсутствует, то между перенаправленными событиями нисходящей и восходящей маршрутизации, совместно использующими эту схему именования, нет связи: без такой реализации это будут два абсолютно раздельных перенаправленных события, которые не будут вызываться в последовательности и не будут совместно использовать данные события.</p>
<p>Дополнительные сведения о реализации пары перенаправленных событий нисходящей и восходящей маршрутизации в пользовательском классе см. в разделе <a href="how-to-create-a-custom-routed-event.html">Создание пользовательских перенаправленных событий</a>.</p>
<p><a name="Class_Handlers_and_Instance_Handlers"></a></p>
<h2 id="class-handlers-and-instance-handlers">Обработчики классов и обработчики экземпляров</h2>
<p>Перенаправленные события поддерживают два разных типа прослушивателей события: прослушиватели классов и прослушиватели экземпляров. Прослушиватели классов существуют, так как типы определенный <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.eventmanager">EventManager</a> API ,<a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.eventmanager.registerclasshandler">RegisterClassHandler</a>, в своем статическом конструкторе, или переопределяют виртуальный метод обработчика класса из элемента базового класса. Прослушиватели экземпляров — экземпляры определенного класса или элементы, где один или несколько привязаны обработчики для этого перенаправленного события путем вызова <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.addhandler">AddHandler</a>. Существующие WPF вызывают перенаправленные события <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.addhandler">AddHandler</a> как часть CLR Добавление программы-оболочки событий{} и удалить{} реализации событий, который также является как простой XAML механизм присоединения обработчики событий через синтаксис атрибутов включен. Таким образом, даже простое XAML использования конечном счете приравнивается к <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.addhandler">AddHandler</a> вызова.</p>
<p>Элементы в пределах визуального дерева проверяются на наличие реализаций зарегистрированных обработчиков. Обработчики потенциально вызываются на всем маршруте в порядке, соответствующем типу стратегии маршрутизации для этого перенаправленного события. Например, перенаправленные события восходящей маршрутизации сначала будут вызывать обработчики, присоединенные к элементу, который вызвал это перенаправленное событие. Затем перенаправленное событие «поднимается» к следующему родительскому элементу и так далее, пока не будет достигнут корневой элемент приложения.</p>
<p>С точки зрения корневого элемента в восходящем маршруте, если обработка класса или любой элемент, ближайший к источнику перенаправленного события, вызывает обработчики, которые помечают аргументы события как обработанные, то обработчики в корневых элементах не вызываются и маршрут события эффективно укорачивается до достижения этого корневого элемента. Однако маршрут не полностью останавливается, так как обработчики могут быть добавлены с использованием специального условия, что они должны по-прежнему вызываться, даже если обработчик класса или обработчик экземпляра пометил перенаправленное событие как обработанное. Это объясняется в разделе <a href="#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled">Добавление обработчиков экземпляра, которые вызываются, даже когда события помечены как обработанные</a> далее в этой статье.</p>
<p>На более глубоком уровне, чем маршрут события, также потенциально имеется несколько обработчиков класса, действующих в любом экземпляре класса. Это связано с тем, что модель обработки класса для перенаправленных событий позволяет каждому из возможных классов в иерархии классов зарегистрировать свой собственный обработчик класса для каждого перенаправленного события. Каждый обработчик класса добавляется во внутреннее хранилище, и, когда формируется маршрут события для приложения, все обработчики классов добавляются в этот маршрут события. Обработчики классов добавляются в маршрут таким образом, что сначала вызывается обработчик класса, находящегося на самом низком уровне иерархии, а затем вызываются обработчики классов из каждого последующего базового класса. Как правило, обработчики классов не регистрируются, так что они также отвечают на перенаправленные события, которые уже были помечены как обработанные. Таким образом, этот механизм обработки класса позволяет выбрать один из двух следующих вариантов.</p>
<ul>
<li><p>Производные классы могут дополнять обработку класса, наследуемую от базового класса, путем добавления обработчика, который не помечает перенаправленное событие как обработанное, поскольку обработчик базового класса будет иногда вызываться после обработчика производного класса.</p>
</li>
<li><p>Производные классы могут заменять обработку класса из базового класса путем добавления обработчика класса, который помечает перенаправленное событие как обработанное. Следует соблюдать осторожность при таком подходе, потому что в результате возможно изменение планируемой конструкции базового элемента управления в таких областях, как внешний вид, логика состояний, обработки ввода и обработка команд.</p>
</li>
</ul>
<p><a name="Class_Handling_of_Routed_Events"></a></p>
<h2 id="class-handling-of-routed-events-by-control-base-classes">Обработка перенаправленных событий базовыми классами элементов управления</h2>
<p>В каждом узле элементов в маршруте события прослушиватели классов имеют возможность ответить на перенаправленное событие прежде, чем это сможет сделать любой прослушиватель экземпляра в элементе. По этой причине обработчики классов иногда используются для подавления перенаправленных событий, которые определенная реализация класса элементов управления не желает распространять дальше, или для предоставления специальной обработки этого перенаправленного события, являющейся функцией класса. Например, класс может вызывать собственное событие класса, содержащее дополнительные сведения о том, что означает некоторое пользовательское условие ввода в контексте данного класса. Затем эта реализация класса может пометить более общее перенаправленное событие как обработанное. Обработчики класса обычно добавляются таким образом, чтобы они не вызываются для перенаправленных событий, где общие данные события уже помечены как обработанные, однако для нетипичных случаев имеется также <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.eventmanager.registerclasshandler#System_Windows_EventManager_RegisterClassHandler_System_Type_System_Windows_RoutedEvent_System_Delegate_System_Boolean_">RegisterClassHandler(Type, RoutedEvent, Delegate, Boolean)</a> подпись, которая регистрирует обработчики классов для вызова, даже если перенаправленные события имеют помечено как обработанное.</p>
<h3 id="class-handler-virtuals">Виртуальные функции обработчиков классов</h3>
<p>Некоторые элементы, в частности базовые элементы, такие как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement">UIElement</a>, предоставляют пустые «на * событий» и «OnPreview*событий» виртуальные методы, которые соответствуют списку общих перенаправленных событий. Эти виртуальные методы можно переопределить, чтобы реализовать обработчик класса для перенаправленного события. Классы базовых элементов регистрируют эти виртуальные методы как свои обработчики классов для каждого такого перенаправленного события с помощью <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.eventmanager.registerclasshandler#System_Windows_EventManager_RegisterClassHandler_System_Type_System_Windows_RoutedEvent_System_Delegate_System_Boolean_">RegisterClassHandler(Type, RoutedEvent, Delegate, Boolean)</a> как было описано ранее. Виртуальные методы On*Event существенно упрощают реализацию обработки класса для соответствующих перенаправленных события, не требуя специальной инициализации в статических конструкторах для каждого типа. Например, можно добавить обработку класса для <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.dragenter">DragEnter</a> событий в любом <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement">UIElement</a> производный класс, переопределив <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.ondragenter">OnDragEnter</a> виртуального метода. В переопределении можно обрабатывать перенаправленное событие, вызывать другие события, инициировать логику данного класса, которая может изменять свойства элементов в экземплярах или задавать любое сочетание этих действий. Обычно в таких переопределениях следует вызывать базовую реализацию, даже если событие помечается как обработанное. Вызов базовой реализации настоятельно рекомендуется, так как виртуальный метод находится в базовом классе. Стандартный защищенный виртуальный шаблон вызова базовых реализаций из каждого виртуального метода в сущности заменяет и дублирует аналогичный механизм, встроенный в обработку класса перенаправленных событий, в котором обработчики классов для всех классов в иерархии вызываются в любом указанном экземпляре, начиная с обработчика класса, самого дальнего в иерархии, и заканчивая обработчиком базового класса. Вам достаточно лишь опустить вызов базовой реализации, если класс обоснованно требует изменить логику обработки базового класса. Вызов базовой реализации до или после переопределения кода будет зависеть от природы реализации.</p>
<h4 id="input-event-class-handling">Обработка классов событий ввода</h4>
<p>Все виртуальные методы обработчика класса регистрируются таким образом, что они вызываются только в случаях, когда общие данные события еще не помечены как обработанные. Кроме того, исключительно для событий ввода, нисходящая и восходящая версии маршрутизации обычно вызываются последовательно и совместно используют данные события. Это влечет за собой то, что для конкретной пары обработчиков класса событий ввода, где один является версией для нисходящей маршрутизации, а другой — для восходящей, вы можете не захотеть немедленно пометить событие как обработанное. Если вы реализуете виртуальный метод обработки класса событий нисходящей маршрутизации для пометки события как обработанного, это препятствует вызову обработчика класса событий восходящей маршрутизации (а также препятствует вызову любых обычно зарегистрированных обработчиков экземпляров для событий как нисходящей, так и восходящей маршрутизации).</p>
<p>После завершения обработки класса в узле рассматриваются прослушиватели экземпляров.</p>
<p><a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a></p>
<h2 id="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled">Добавление обработчиков экземпляра, которые вызываются, даже когда события помечены как обработанные</h2>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.addhandler">AddHandler</a> Метод предоставляет конкретную перегрузку, которая дает возможность добавлять обработчики, которые будут вызываться системой событий всякий раз, когда событие достигает обрабатываемый элемент в маршруте, даже если некоторые другие обработчики уже отметили данные события для пометки, событие как обработанное. Обычно это не делается. Как правило, обработчики могут быть написаны для корректировки всех областей кода приложения, на которые может влиять событие, независимо от того, где оно было обработано в дереве элементов, даже если требуется несколько конечных результатов. Кроме того, обычно существует только один элемент, который должен отвечать на это событие, и соответствующая прикладная логика уже была применена. Однако перегрузка <code>handledEventsToo</code> доступна в исключительных случаях, когда некоторые элементы в дереве элементов или в составных элементах управления уже пометили событие как обработанное, но другие элементы, находящиеся выше или ниже в дереве элементов (в зависимости от маршрута), по-прежнему требуют вызов своих собственных обработчиков.</p>
<h4 id="when-to-mark-handled-events-as-unhandled">Когда следует помечать обработанные события как необработанные</h4>
<p>Как правило, перенаправленные события, которые помечены как обработанные следует не должны помечаться как необработанные (<a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.routedeventargs.handled">Handled</a> снова установить значение <code>false</code>) даже обработчиками, которые действуют на <code>handledEventsToo</code>. Однако некоторые события ввода имеют представления событий высокого и низкого уровня, которые могут перекрываться, когда событие высокого уровня отображается в одной позиции в дереве, а событие низкого уровня — в другой позиции. Например, рассмотрим случай, где дочерний элемент прослушивает ключевое событие высокого например <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.textinput">TextInput</a> хотя родительский элемент прослушивает событие нижнего уровня, такие как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.keydown">KeyDown</a>. Если родительский элемент обрабатывает событие нижнего уровня, событие верхнего уровня может подавляться даже в дочернем элементе, который интуитивно должен иметь возможность первым обработать это событие.</p>
<p>В таких ситуациях может потребоваться добавить обработчики события нижнего уровня и в родительский, и в дочерний элемент. Реализация обработчика дочернего элемента может пометить событие нижнего уровня как обработанное, но реализация обработчика родительского элемента будет снова устанавливать его как необработанное, чтобы последующие элементы в дереве (а также события высокого уровня) имели возможность ответить. Это достаточно редкая ситуация.</p>
<p><a name="Deliberately_Suppressing_Input_Events_for_Control"></a></p>
<h2 id="deliberately-suppressing-input-events-for-control-compositing">Намеренное подавление событий ввода для составных элементов управления</h2>
<p>Основной сценарий, в котором используется обработка класса перенаправленных событий, предназначен для событий ввода и составных элементов управления. Составной элемент управления по определению состоит из нескольких фактических элементов управления или базовых классов элементов управления. Часто разработчик элемента управления хочет объединить все возможные события ввода, которые могут вызываться каждым из компонентов, чтобы полный элемент управления был единственным источником событий. В некоторых случаях разработчик элемента управления может захотеть полностью подавить события от компонентов или заменить на определяемое компонентом событие, которое содержит дополнительные сведения или подразумевает более конкретное поведение. Типичный пример, который сразу виден любому разработчику компонента — как Windows Presentation Foundation (WPF) <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.button">Button</a> обрабатывает любые события мыши, в конечном итоге будет разрешено в интуитивно понятное событие всех кнопках: <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.buttonbase.click">Click</a> событий.</p>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.button">Button</a> Базового класса (<a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.buttonbase">ButtonBase</a>) является производным от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.control">Control</a> который, в свою очередь, наследуется от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement">FrameworkElement</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement">UIElement</a>и большая часть инфраструктуры событий, необходимой для обработки ввода элемента управления доступны в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement">UIElement</a> уровень. В частности <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement">UIElement</a> обрабатывает Общие <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.input.mouse">Mouse</a> события, которые обрабатывают проверку попадания курсора мыши в пределах его границ и предоставляет различные события для наиболее часто используемых действий кнопок, такие как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.mouseleftbuttondown">MouseLeftButtonDown</a>. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement">UIElement</a> также предоставляет пустой виртуальный <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.onmouseleftbuttondown">OnMouseLeftButtonDown</a> качестве предварительно зарегистрированного обработчика класса для <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.mouseleftbuttondown">MouseLeftButtonDown</a>, и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.buttonbase">ButtonBase</a> ее переопределяет. Аналогичным образом <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.buttonbase">ButtonBase</a> использует класс обработчики для <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.mouseleftbuttonup">MouseLeftButtonUp</a>. В переопределениях, которые передают данные событий, реализации помечают, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.routedeventargs">RoutedEventArgs</a> экземпляр как обработанного путем присвоения <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.routedeventargs.handled">Handled</a> для <code>true</code>, и что же событий данные остаются на всей оставшейся части маршрута к другим обработчикам классов и также к обработчикам экземпляров или методы задания событий. Кроме того <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.buttonbase.onmouseleftbuttonup">OnMouseLeftButtonUp</a> переопределение будет вызывать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.buttonbase.click">Click</a> событий. Конечным результатом для большинства прослушивателей будут, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.mouseleftbuttondown">MouseLeftButtonDown</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.mouseleftbuttonup">MouseLeftButtonUp</a> «исчезновение» событий и замена их <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.buttonbase.click">Click</a>, событие, которое имеет больше смысла, так как известно, поступившее от настоящей кнопки, а не некоторые составной фигуру полностью кнопки или из другой элемент.</p>
<p><a name="WorkingAroundEventSuppressionByControls"></a></p>
<h3 id="working-around-event-suppression-by-controls">Обход скрытия события элементами управления</h3>
<p>Иногда это поведение скрытия события внутри отдельных элементов управления может конфликтовать с некоторыми более общими целями логики обработки событий в приложении. Например если для какой-либо причине приложение имеет обработчик для <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.mouseleftbuttondown">MouseLeftButtonDown</a> находится в корневом элементе приложения, то можно заметить, что любой щелчок мышью по кнопке не вызывает <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.mouseleftbuttondown">MouseLeftButtonDown</a> или <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.mouseleftbuttonup">MouseLeftButtonUp</a> обработчики на корневом уровне. Само событие действительно передается вверх (еще раз, маршруты событий на самом деле не завершены, но система перенаправления событий изменяет поведение вызова их обработчика после пометки их как обработанных). Когда перенаправленное событие достигает кнопки, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.buttonbase">ButtonBase</a> обработку класса помечен <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.mouseleftbuttondown">MouseLeftButtonDown</a> как обработанное, поскольку пытается заменить <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.buttonbase.click">Click</a> событием с большим смыслом. Таким образом, любой стандарт <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.mouseleftbuttondown">MouseLeftButtonDown</a> обработчик далее по маршруту вызываться не будет. Существует два способа гарантировать, что в таких обстоятельствах ваши обработчики будут вызываться.</p>
<p>Первый способ состоит в том, чтобы намеренно добавить обработчик с помощью <code>handledEventsToo</code> подпись <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.addhandler#System_Windows_UIElement_AddHandler_System_Windows_RoutedEvent_System_Delegate_System_Boolean_">AddHandler(RoutedEvent, Delegate, Boolean)</a>. Этот подход ограничен тем, что такой способ присоединения обработчика событий возможен только из кода, но не из разметки. Простой синтаксис указания имени обработчика событий в качестве значения атрибута события посредством XAML не позволяет такое поведение.</p>
<p>Второй способ работает только для событий ввода, где версии нисходящей и восходящей маршрутизации перенаправленного события объединены в пару. Для этих перенаправленных событий можно добавлять обработчики в версию перенаправленного события нисходящей маршрутизации. Это перенаправленное событие будет спускаться по маршруту, начиная от корня, поэтому код обработки класса кнопки не будет его перехватывать, при условии что вы присоединили обработчик предварительного просмотра на уровне предшествующего элемента в дереве элементов приложения. При использовании этого подхода будьте внимательны при пометке любого события предварительного просмотра как обработанного. В примере с <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.uielement.previewmouseleftbuttondown">PreviewMouseLeftButtonDown</a> обрабатывается в корневом элементе, если вы пометили событие как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.routedeventargs.handled">Handled</a> в реализации обработчика, фактически будет подавлено <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.buttonbase.click">Click</a> событий. Обычно это нежелательное поведение.</p>
<h2 id="see-also">См. также</h2>
<ul>
<li><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.eventmanager">EventManager</a></li>
<li><a href="preview-events.html">События предварительного просмотра</a></li>
<li><a href="how-to-create-a-custom-routed-event.html">Создание пользовательских перенаправленных событий</a></li>
<li><a href="routed-events-overview.html">Общие сведения о перенаправленных событиях</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span><a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru">Неофициальная документация по .NET на русском языке</a>. Лицензия: <a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru/blob/main/LICENSE">CC-BY 4.0</a>. Основано на <a href="https://docs.microsoft.com/ru-ru/dotnet/">документации по .NET с Microsoft Docs</a><br>Generated by <strong>DocFX</strong></span><script type="text/javascript">(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(65150713, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/65150713" style="position:absolute; left:-9999px;" alt=""></div></noscript>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
