<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1053;&#1072;&#1089;&#1083;&#1077;&#1076;&#1086;&#1074;&#1072;&#1085;&#1080;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1103; &#1089;&#1074;&#1086;&#1081;&#1089;&#1090;&#1074;&#1072; | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1053;&#1072;&#1089;&#1083;&#1077;&#1076;&#1086;&#1074;&#1072;&#1085;&#1080;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1103; &#1089;&#1074;&#1086;&#1081;&#1089;&#1090;&#1074;&#1072; | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="property-value-inheritance">Наследование значения свойства</h1>

<p>Наследование значения свойства — это функция системы свойств Windows Presentation Foundation (WPF). Наследование значения свойства позволяет дочерним элементам в дереве элементов получать значение конкретного свойства из родительских элементов, наследуя это значение, настроенное в ближайшем родительском элементе. Родительский элемент также мог получить свое значение через наследование значения свойства, поэтому система потенциально рекурсивно проходит по элементам к корню страницы. Наследование значения свойства не является стандартным поведением системы свойств. Чтобы свойство инициировало наследование значения свойства для дочерних элементов, оно должно быть установлено с определенным параметром метаданных.</p>
<p><a name="Property_Value_Inheritance_is_Containment_Inheritance"></a></p>
<h2 id="property-value-inheritance-is-containment-inheritance">Наследование значения свойства является наследованием вложений</h2>
<p>Используемый здесь термин &quot;наследование&quot; отличается от концепции наследования в контексте типов и общего объектно-ориентированного программирования, где производные классы наследуют определения членов от своих базовых классов. Это значение наследования также активно в WPF: свойства, определенные в различных базовых классах, отображаются как атрибуты для производных классов XAML при использовании в качестве элементов и представляются для кода как члены. В частности, наследование значения свойства заключается в том, как значения свойств могут наследоваться от одного элемента к другому на основе иерархических отношений в дереве элементов. Это дерево элементов наиболее явно видно при встраивании элементов в другие элементы во время определения приложения в разметке XAML. Деревья объектов также могут создаваться программно путем добавления объектов к выделенным коллекциям других объектов, а наследование значения свойства работает аналогично в конечном дереве во время выполнения.</p>
<p><a name="Practical_Applications_of_Property_Value_Inheritance"></a></p>
<h2 id="practical-applications-of-property-value-inheritance">Практическое применение наследования значения свойства</h2>
<p>WPF API включают несколько свойств, в которых включено наследование свойства. Как правило, сценарий для них состоит во включении свойства там, где уместно устанавливать свойство только один раз на странице, но это свойство также является членом одного из базовых классов элементов и, таким образом, может существовать в большинстве дочерних элементов. Например <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.flowdirection">FlowDirection</a> свойства элементов управления, переданное содержимое которых следует представлен и организован на странице. Как правило, требуется, чтобы концепция направления текста согласованно обрабатывалась во всех дочерних элементах. Если направление передачи по какой-то причине было прервано на некотором уровне дерева элементов в результате действия пользователя или среды, то оно должно быть перезапущено повсюду. Когда <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.flowdirection">FlowDirection</a> свойство для наследования, то значение нужно только задать или сбросить один раз на уровне в дереве элементов, который охватывает требования каждой страницы в приложении. Таким образом будет наследоваться даже начальное значение по умолчанию. Модель наследования значений свойств также позволяет отдельным элементам сбрасывать значение в тех редких случаях, когда сочетание направлений текста является преднамеренным.</p>
<p><a name="Making_a_Custom_Property_Inheritable"></a></p>
<h2 id="making-a-custom-property-inheritable">Создание настраиваемого наследуемого свойства</h2>
<p>Изменяя метаданные настраиваемого свойства, можно создать собственные наследуемые свойства. Обратите внимание, что назначение свойства как наследуемого оказывает определенное влияние на производительность. В случаях, когда это свойство не имеет установленного локального значения или значения, полученного через стили, шаблоны или привязки данных, наследуемое свойство предоставляет присвоенные ему значения всем дочерним элементам в логическом дереве.</p>
<p>Чтобы свойство участвовало в наследовании значения, создайте настраиваемое присоединенное свойство, как описано в разделе <a href="how-to-register-an-attached-property.html">Регистрация присоединенного свойства</a>. Зарегистрируйте свойство с метаданными (<a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkpropertymetadata">FrameworkPropertyMetadata</a>) и укажите параметр «Наследует» в настройках параметров в этих метаданных. Также убедитесь, что для свойства задано значение по умолчанию, так как теперь это значение будет наследоваться. Несмотря на регистрацию свойства как присоединенного, можно создать &quot;оболочку&quot; свойства для получения/настройки доступа к типу владельца точно так же, как и для &quot;неприсоединенного&quot; свойства зависимостей. После этого наследуемое свойство может быть установлено либо с помощью оболочки прямой свойства для типа владельца или производного типа, или его можно установить с помощью синтаксиса присоединенного свойства для какого-либо <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.dependencyobject">DependencyObject</a>.</p>
<p>Присоединенные свойства похожи на глобальные свойства; можно проверить значение любого <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.dependencyobject">DependencyObject</a> и получить правильный результат. Типичный сценарий для присоединенных свойств является установка значений свойств для дочерних элементов, и этот скрипт будет более эффективен, если рассматриваемое свойство является присоединенным свойством, всегда неявно присутствует в качестве присоединенного свойства для каждого элемента (<a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.dependencyobject">DependencyObject</a>) в дереве.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Несмотря на то что наследование значения свойства может выполняться для неприсоединенных свойств зависимостей, поведение наследования для таких свойств через определенные границы элементов в дереве среды выполнения не определено. Всегда используйте <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.dependencyproperty.registerattached">RegisterAttached</a> для регистрации вы зададите свойства <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkpropertymetadata.inherits">Inherits</a> в метаданных.</p>
</div>
<p><a name="InheritanceContext"></a></p>
<h2 id="inheriting-property-values-across-tree-boundaries">Наследование значений свойств за границами дерева</h2>
<p>Наследование свойств работает путем обхода дерева элементов. Это дерево часто параллельно логическому дереву. Тем не менее, при включении объекта уровня ядра WPF в разметку, определяющую дерево элементов, таких как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.media.brush">Brush</a>, вы создали несплошное логическое дерево. Истинное логическое дерево концептуально не расширяется через <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.media.brush">Brush</a>, так как логическое дерево является концепцией уровня среды WPF. Вы можете увидеть это отражается в результатах, при использовании методов класса <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.logicaltreehelper">LogicalTreeHelper</a>. Тем не менее наследование значения свойства может устранить этот разрыв в логическом дереве и можно по-прежнему передавать унаследованные значения, до тех пор, пока наследуемое свойство зарегистрировано как присоединенное свойство, а не намеренным граница, блокирующая наследование (например <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.frame">Frame</a>) обнаруживается.</p>
<h2 id="see-also">См. также</h2>
<ul>
<li><a href="dependency-property-metadata.html">Метаданные свойства зависимости</a></li>
<li><a href="attached-properties-overview.html">Общие сведения о вложенных свойствах зависимостей</a></li>
<li><a href="dependency-property-value-precedence.html">Приоритет значения свойств зависимостей</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span><a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru">Неофициальная документация по .NET на русском языке</a>. Лицензия: <a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru/blob/main/LICENSE">CC-BY 4.0</a>. Основано на <a href="https://docs.microsoft.com/ru-ru/dotnet/">документации по .NET с Microsoft Docs</a><br>Generated by <strong>DocFX</strong></span><script type="text/javascript">(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(65150713, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/65150713" style="position:absolute; left:-9999px;" alt=""></div></noscript>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
