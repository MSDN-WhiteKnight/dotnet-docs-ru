<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1054;&#1073;&#1097;&#1080;&#1077; &#1089;&#1074;&#1077;&#1076;&#1077;&#1085;&#1080;&#1103; &#1086;&#1073; &#1091;&#1087;&#1088;&#1072;&#1074;&#1083;&#1077;&#1085;&#1080;&#1080; &#1087;&#1088;&#1080;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1077;&#1084; | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1054;&#1073;&#1097;&#1080;&#1077; &#1089;&#1074;&#1077;&#1076;&#1077;&#1085;&#1080;&#1103; &#1086;&#1073; &#1091;&#1087;&#1088;&#1072;&#1074;&#1083;&#1077;&#1085;&#1080;&#1080; &#1087;&#1088;&#1080;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1077;&#1084; | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="application-management-overview">Общие сведения об управлении приложением</h1>

<p>Все приложения имеют тенденцию совместно использовать общий набор функциональных возможностей, который применяется к реализации приложения и управлению им. В этом разделе представлен обзор функциональных возможностей класса <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> для создания приложений и управления ими.</p>
<h2 id="the-application-class">Класс Application</h2>
<p>В WPF функциональные возможности, относящиеся к области приложения, инкапсулируются классом <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a>. Класс <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> включает следующие функциональные возможности:</p>
<ul>
<li><p>отслеживание и взаимодействие со временем существования приложения;</p>
</li>
<li><p>извлечение и обработка параметров командной строки;</p>
</li>
<li><p>обнаружение необработанных исключений и реагирование на них;</p>
</li>
<li><p>совместное использование свойств и ресурсов области приложения;</p>
</li>
<li><p>управление окнами в автономных приложениях;</p>
</li>
<li><p>отслеживание навигации и управление ею.</p>
</li>
</ul>
<p><a name="The_Application_Class"></a></p>
<h2 id="how-to-perform-common-tasks-using-the-application-class">Выполнение стандартных задач с помощью класса приложения</h2>
<p>Если вас не интересуют все аспекты класса <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a>, в следующей таблице перечислены некоторые из наиболее распространенных задач <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> и способах их выполнения. Чтобы получить дополнительные сведения и примеры кода, просмотрите связанные API и разделы.</p>
<table>
<thead>
<tr>
<th>Задача</th>
<th>Подход</th>
</tr>
</thead>
<tbody>
<tr>
<td>Получение объекта, представляющего текущее приложение</td>
<td>Используйте свойство <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.current">Application.Current</a>.</td>
</tr>
<tr>
<td>Добавление заставки в приложение</td>
<td>См. в разделе <a href="how-to-add-a-splash-screen-to-a-wpf-application.html">Добавление в WPF-приложение экрана-заставки</a>.</td>
</tr>
<tr>
<td>Запуск приложения</td>
<td>Воспользуйтесь методом <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.run">Application.Run</a>.</td>
</tr>
<tr>
<td>Остановка приложения</td>
<td>Используйте метод <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown">Shutdown</a> объекта <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.current">Application.Current</a>.</td>
</tr>
<tr>
<td>Получение аргументов командной строки</td>
<td>Обработайте <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Application.Startup</a> и используйте свойство <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.startupeventargs.args">StartupEventArgs.Args</a>. Пример см. в разделе <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Application.Startup</a>.</td>
</tr>
<tr>
<td>Получение и задание кода завершения приложения</td>
<td>Задайте <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.exiteventargs.applicationexitcode">ExitEventArgs.ApplicationExitCode</a> в обработчике событий <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Application.Exit</a> или вызовите <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown">Shutdown</a>, передав в него число.</td>
</tr>
<tr>
<td>Обнаружение необработанных исключений и реагирование на них</td>
<td>Обработайте событие <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.dispatcherunhandledexception">DispatcherUnhandledException</a>.</td>
</tr>
<tr>
<td>Получение и задание ресурсов области приложения</td>
<td>Используйте свойство <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.resources">Application.Resources</a>.</td>
</tr>
<tr>
<td>Использование словаря ресурсов области приложения</td>
<td>См. в разделе <a href="how-to-use-an-application-scope-resource-dictionary.html">использование словаря ресурсов области приложения</a>.</td>
</tr>
<tr>
<td>Получение и задание свойств области приложения</td>
<td>Используйте свойство <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.properties">Application.Properties</a>.</td>
</tr>
<tr>
<td>Получение и сохранение состояния приложения</td>
<td>См. в разделе <a href="persist-and-restore-application-scope-properties.html">сохранение и восстановление свойств области приложения в сеансах приложения</a>.</td>
</tr>
<tr>
<td>Управление файлами данных, включая файлы ресурсов, файлы содержимого и файлы исходного расположения.</td>
<td>См. в разделе <a href="wpf-application-resource-content-and-data-files.html">ресурсы приложения WPF, содержимое и файлы данных</a>.</td>
</tr>
<tr>
<td>Управление окнами в автономных приложениях</td>
<td>См. раздел <a href="wpf-windows-overview.html">Общие сведения об окнах WPF</a>.</td>
</tr>
<tr>
<td>Отслеживание навигации и управление ею</td>
<td>См. в разделе <a href="navigation-overview.html">Общие сведения о переходах</a>.</td>
</tr>
</tbody>
</table>
<p><a name="The_Application_Definition"></a></p>
<h2 id="the-application-definition">Определение приложения</h2>
<p>Чтобы использовать функциональные возможности класса <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a>, необходимо реализовать определение приложения. Определение приложения WPF — это класс, производный от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> и сконфигурированный с помощью специальных настроек MSBuild.</p>
<h3 id="implementing-an-application-definition">Реализация определения приложения</h3>
<p>Типичное определение приложения WPF реализуется с помощью разметки и кода. Это позволяет использовать разметку для декларативного задания свойств и ресурсов приложения и регистрации событий, а обработку событий и поведение приложения реализовывать в коде программной части.</p>
<p>В следующем примере показано, как реализовать определение приложения с помощью разметки и кода:</p>
<pre><code class="lang-xaml" name="ApplicationSnippets#ApplicationXAML">&lt;Application 
  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; 
  x:Class=&quot;SDKSample.App&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="ApplicationSnippets#ApplicationCODEBEHIND">using System.Windows;

namespace SDKSample
{
    public partial class App : Application { }
}
</code></pre>
<p>Для совместной работы файла разметки и файла кода программной части должны выполняться указанные ниже условия.</p>
<ul>
<li><p>В разметке элемент <code>Application</code> должен включать атрибут <code>x:Class</code>. При построении приложения наличие <code>x:Class</code> в разметке указывает MSBuild сформировать <code>partial</code> класс, производный от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> и имеющий имя, заданное параметром атрибута <code>x:Class</code>. Для этого требуется добавить объявление пространства имен XML в схему XAML (<code>xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</code>).</p>
</li>
<li><p>В коде программной части должен быть определен <code>partial</code> класс с тем же именем, которое задается параметром атрибута <code>x:Class</code> в разметке, производный от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a>. Это позволяет связать файл кода с <code>partial</code> классом, созданным из файла разметки при построении приложения (см. в разделе <a href="building-a-wpf-application-wpf.html">построение приложения WPF</a>).</p>
</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>При создании нового проекта приложения WPF или проекта приложения браузера WPF с помощью Visual Studio, определение приложения включается по умолчанию и определяется с помощью разметки и кода.</p>
</div>
<p>Этот код является минимумом, необходимым для реализации определения приложения. Однако, для запуска и построения приложения необходима дополнительная настройка MSBuild.</p>
<h3 id="configuring-the-application-definition-for-msbuild">Настройка определения приложения для MSBuild</h3>
<p>Автономные приложения и приложения браузера XAML (XBAP) требуют реализации инфраструктуры определенного уровня перед своим запуском. Наиболее важной частью этой инфраструктуры является точка входа. При запуске приложения пользователем операционная система вызывает точку входа, известную функцию, используемую для запуска приложения.</p>
<p>Обычно разработчикам требовалось писать весь этот код или его часть самостоятельно в зависимости от технологии. Тем не менее, WPF создает этот код автоматически, при настройке файла разметки для определения приложения в качестве элемента MSBuild <code>ApplicationDefinition</code>, как показано в следующем файле проекта MSBuild:</p>
<pre><code class="lang-xml">&lt;Project   
  DefaultTargets=&quot;Build&quot;  
                        xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;  
  ...  
  &lt;ApplicationDefinition Include=&quot;App.xaml&quot; /&gt;  
  &lt;Compile Include=&quot;App.xaml.cs&quot; /&gt;  
  ...  
&lt;/Project&gt;  
</code></pre>
<p>Так как файл кода содержит код, он помечается как элемент MSBuild <code>Compile</code>, как и обычные файлы кода.</p>
<p>Применение этой конфигурации MSBuild к файлам разметки и кода программной части определения приложения заставляет MSBuild создать следующий код:</p>
<pre><code class="lang-csharp" name="auto-generated-code">using System;
using System.Windows;

namespace SDKSample
{
    public class App : Application
    {
        public App() { }
        [STAThread]
        public static void Main()
        {
            // Create new instance of application subclass
            App app = new App();

            // Code to register events and set properties that were
            // defined in XAML in the application definition
            app.InitializeComponent();

            // Start running the application
            app.Run();
        }

        public void InitializeComponent()
        {
            // Initialization code goes here.
        }
    }
}
</code></pre>
<p>Результирующий код дополняет ваше определение приложения кодом инфраструктуры, которая включает в себя метод точки входа <code>Main</code>. Атрибут <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.stathreadattribute">STAThreadAttribute</a> применяется к методу <code>Main</code>, чтобы указать, что основной поток пользовательского интерфейса для приложения WPF является потоком STA, что необходимо для приложений WPF. При вызове <code>Main</code> создается новый экземпляр класса <code>App</code> и вызывается метод <code>InitializeComponent</code> для регистрации событий и задания свойств, реализованных в разметке. Так как <code>InitializeComponent</code> создается автоматически, не нужно явно вызывать <code>InitializeComponent</code> из определения приложения как для реализаций <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.page">Page</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a>. Наконец, метод  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.run">Run</a> вызывается для запуска приложения.</p>
<p><a name="Getting_the_Current_Application"></a></p>
<h2 id="getting-the-current-application">Получение текущего приложения</h2>
<p>Так как функциональные возможности <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> являются общими для всего приложения, может существовать только один экземпляр <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> на <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.appdomain">AppDomain</a>. Чтобы гарантировать это, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> реализован в виде singleton-класса (см. в разделе <a href="https://docs.microsoft.com/ru-ru/previous-versions/msp-n-p/ff650316(v=pandp.10)">Реализация Singleton в C# </a>, который создает единственный экземпляр самого себя и предоставляет общий доступ к нему с помощью <code>static</code> свойства <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.current">Current</a>.</p>
<p>Ниже показано, как получить ссылку на <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> для текущего <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.appdomain">AppDomain</a>.</p>
<pre><code class="lang-csharp" name="ApplicationManagementOverviewSnippets#GetCurrentAppCODE">// Get current application
Application current = App.Current;
</code></pre>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.current">Current</a> возвращает ссылку на экземпляр <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a>. Если требуется ссылка на ваш класс, производный от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a>, необходимо привести значение <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.current">Current</a>, как показано в следующем примере.</p>
<pre><code class="lang-csharp" name="ApplicationManagementOverviewSnippets#GetSTCurrentAppCODE">// Get strongly-typed current application
App app = (App)App.Current;
</code></pre>
<p>Вы можете проверить значение <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.current">Current</a> в любой момент времени существования объекта <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a>. Однако следует соблюдать осторожность. После создания экземпляра <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> в течение во время которого состояние <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> непредсказуемо. В течение этого периода <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> выполняет различные задачи инициализации, необходимые для исполнения кода, включая создание инфраструктуры приложения, настройку свойств и регистрацию событий. Если вы попытаетесь использовать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> в течение этого периода, код может иметь непредвиденные результаты, особенно в том случае, если он зависит от различных свойств <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a>.</p>
<p>Когда <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> завершает свою работу инициализации, начинается его время существования.</p>
<p><a name="Application_Lifetime"></a></p>
<h2 id="application-lifetime">Время существования приложения</h2>
<p>Время существования приложения WPF отмечается несколькими событиями, которые <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> вызывает, чтобы сообщить вам о запуске приложения, его активации, деактивации и завершении работы.</p>
<p><a name="Splash_Screen"></a></p>
<h3 id="splash-screen">Заставка</h3>
<p>Начиная с версии .NET Framework 3.5 SP1, можно указать изображение, которое может использоваться в качестве <em>заставки</em>. Класс <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.splashscreen">SplashScreen</a> позволяет легко отобразить заставку во время загрузки приложения. Окно <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.splashscreen">SplashScreen</a> создается и отображается перед вызовом <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.run">Run</a>. Дополнительные сведения см. в разделе <a href="../advanced/application-startup-time.html">время запуска приложения</a> и <a href="how-to-add-a-splash-screen-to-a-wpf-application.html">Добавление в WPF-приложение экрана-заставки</a>.</p>
<p><a name="Starting_an_Application"></a></p>
<h3 id="starting-an-application">Запуск приложения</h3>
<p>После вызова <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.run">Run</a> и инициализации приложения оно будет готово к запуску. Этот момент обозначается событием <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Startup</a>:</p>
<pre><code class="lang-csharp" name="Startup-event">using System.Windows;

namespace SDKSample
{
    public partial class App : Application
    {
        void App_Startup(object sender, StartupEventArgs e)
        {
            // Application is running
        }
    }
}
</code></pre>
<p>На этом этапе приложение обычно отображает свой пользовательский интерфейс.</p>
<p><a name="Showing_a_User_Interface"></a></p>
<h3 id="showing-a-user-interface">Отображение пользовательского интерфейса</h3>
<p>Большинство автономных приложений Windows при запуске открывают <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a>. Обработчик события <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Startup</a> — в одно из место, откуда это можно сделать, как показано в следующем примере кода.</p>
<pre><code class="lang-xaml" name="AppShowWindowHardSnippets#StartupEventMARKUP">&lt;Application
  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
  x:Class=&quot;SDKSample.App&quot; 
  Startup=&quot;App_Startup&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="AppShowWindowHardSnippets#StartupEventCODEBEHIND">using System.Windows;

namespace SDKSample
{
    public partial class App : Application
    {
        void App_Startup(object sender, StartupEventArgs e)
        {
            // Open a window
            MainWindow window = new MainWindow();
            window.Show();
        }
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Первое созданное <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> в автономном приложении становится главным окном приложения по умолчанию. На этот объект <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> ссылается свойство <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.mainwindow">Application.MainWindow</a>. Значение <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.mainwindow">MainWindow</a> может быть изменено программно, если главным окном должен стать другой экземпляр <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a>.</p>
</div>
<p>Приложение XBAP при первом запуске обычно выполняет переход к <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.page">Page</a>. Это показано в приведенном ниже коде.</p>
<pre><code class="lang-xaml" name="XBAPAppStartupSnippets#StartupXBAPMARKUP">&lt;Application 
  x:Class=&quot;SDKSample.App&quot;
  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
  Startup=&quot;App_Startup&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="XBAPAppStartupSnippets#StartupXBAPCODEBEHIND">using System;
using System.Windows;
using System.Windows.Navigation;

namespace SDKSample
{
    public partial class App : Application
    {
        void App_Startup(object sender, StartupEventArgs e)
        {
            ((NavigationWindow)this.MainWindow).Navigate(new Uri(&quot;HomePage.xaml&quot;, UriKind.Relative));
        }
    }
}
</code></pre>
<p>Если вы обрабатываете <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Startup</a> только для открытия <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> или перехода к <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.page">Page</a>, можно вместо этого задать <code>StartupUri</code> в разметке.</p>
<p>В следующем примере показано, как использовать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startupuri">StartupUri</a> из отдельного приложения, чтобы открыть <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a>.</p>
<pre><code class="lang-xaml" name="ApplicationManagementOverviewSnippets#OverviewStartupUriMARKUP">&lt;Application
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    StartupUri=&quot;MainWindow.xaml&quot; /&gt;
</code></pre>
<p>В следующем примере показано, как использовать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startupuri">StartupUri</a> в XBAP, чтобы перейти к <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.page">Page</a>.</p>
<pre><code class="lang-xaml" name="PageSnippets#XBAPStartupUriMARKUP">&lt;Application
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    StartupUri=&quot;HomePage.xaml&quot; /&gt;
</code></pre>
<p>Эта разметка действует так же, как и предыдущий код для открытия окна.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Дополнительные сведения о навигации см. в разделе <a href="navigation-overview.html">Общие сведения о переходах</a>.</p>
</div>
<p>Обрабатывать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Startup</a> понадобится, чтобы открыть <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> с помощью конструктора не по умолчанию, когда необходимо задать его свойства либо подписаться на его события перед его отображением, или когда вам необходимо обработать аргументы командной строки, заданные при запуске приложения.</p>
<p><a name="Processing_Command_Line_Arguments"></a></p>
<h3 id="processing-command-line-arguments">Обработка аргументов командной строки</h3>
<p>В Windows автономные приложения можно запустить из командной строки или с рабочего стола. В обоих случаях аргументы командной строки могут быть переданы приложению. В приведенном ниже примере показано приложение, которое запускается с одним аргументом командной строки /StartMinimized:</p>
<p><code>wpfapplication.exe /StartMinimized</code></p>
<p>Во время инициализации приложения WPF получает аргументы командной строки из операционной системы и передает их обработчику события <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Startup</a> через свойство <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.startupeventargs.args">Args</a> параметра <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.startupeventargs">StartupEventArgs</a>. Аргументы командной строки можно извлечь и сохранить с помощью приведенного ниже кода.</p>
<pre><code class="lang-xaml" name="ApplicationStartupSnippets#HandleStartupXAML">&lt;Application
  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
  x:Class=&quot;SDKSample.App&quot;
  Startup=&quot;App_Startup&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="ApplicationStartupSnippets#HandleStartupCODEBEHIND">using System.Windows;

namespace SDKSample
{
    public partial class App : Application
    {
        void App_Startup(object sender, StartupEventArgs e)
        {
            // Application is running
            // Process command line args
            bool startMinimized = false;
            for (int i = 0; i != e.Args.Length; ++i)
            {
                if (e.Args[i] == &quot;/StartMinimized&quot;)
                {
                    startMinimized = true;
                }
            }

            // Create main application window, starting minimized if specified
            MainWindow mainWindow = new MainWindow();
            if (startMinimized)
            {
                mainWindow.WindowState = WindowState.Minimized;
            }
            mainWindow.Show();
        }
    }
}
</code></pre>
<p>Код обрабатывает <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Startup</a> и проверяет, передан ли аргумент командной строки <strong>/StartMinimized</strong>; если да, он открывает главное окно с <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstate">WindowState</a> равным <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstate#System_Windows_WindowState_Minimized">Minimized</a>. Обратите внимание, что поскольку значение <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.windowstate">WindowState</a> необходимо задать программно, главное <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> должно быть явным образом открыто в коде.</p>
<p>XBAP-приложения не могут получить и обработать аргументы командной строки, так как они запускаются с помощью развертывания ClickOnce (см. в разделе <a href="deploying-a-wpf-application-wpf.html">развертывание приложений WPF</a>). Однако они могут извлекать и обрабатывать строковые параметры запроса из URL-адресов, которые используются для их запуска.</p>
<p><a name="Application_Activation_and_Deactivation"></a></p>
<h3 id="application-activation-and-deactivation">Активация и деактивация приложения</h3>
<p>Windows позволяет пользователям переключаться между приложениями. Наиболее простой способ — использовать клавиши ALT+TAB. Приложения можно переключить только в том случае, если оно содержит видимое <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a>, которое пользователь может выбрать. Выбранное в данный момент <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> является <em>активным окном</em> (также известно как <em>окно переднего плана</em>) и принимает вводимые пользователем данные. Приложение с активным окном является <em>активным приложением</em> (или <em>приложением переднего плана</em>). Приложение становится активным в указанных ниже случаях.</p>
<ul>
<li><p>Оно запускается и отображает <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a>.</p>
</li>
<li><p>Пользователь переключается из другого приложения, выбрав <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> в приложении.</p>
</li>
</ul>
<p>Вы можете определить, когда приложение активируется, обработав событие <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.activated">Application.Activated</a>.</p>
<p>Аналогичным образом приложение может стать неактивным в указанных ниже случаях.</p>
<ul>
<li><p>Пользователь переключается на другое приложение из текущего.</p>
</li>
<li><p>Приложение завершает работу.</p>
</li>
</ul>
<p>Можно обнаружить, когда приложение становится неактивным, обрабатывая событие <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.deactivated">Application.Deactivated</a>.</p>
<p>Ниже показано, как обработать события <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.activated">Activated</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.deactivated">Deactivated</a>, чтобы определить, активно ли приложение.</p>
<pre><code class="lang-xaml" name="ApplicationActivationSnippets#DetectActivationStateXAML">&lt;Application 
  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
  x:Class=&quot;SDKSample.App&quot;
  StartupUri=&quot;MainWindow.xaml&quot;
  Activated=&quot;App_Activated&quot; 
  Deactivated=&quot;App_Deactivated&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="ApplicationActivationSnippets#DetectActivationStateCODEBEHIND">using System;
using System.Windows;

namespace SDKSample
{
    public partial class App : Application
    {
        bool isApplicationActive;

        void App_Activated(object sender, EventArgs e)
        {
            // Application activated
            this.isApplicationActive = true;
        }

        void App_Deactivated(object sender, EventArgs e)
        {
            // Application deactivated
            this.isApplicationActive = false;
        }
    }
}
</code></pre>
<p>Объект <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> также можно активировать и деактивировать. Дополнительные сведения см. в разделах <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.activated">Window.Activated</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.deactivated">Window.Deactivated</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Ни <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.activated">Application.Activated</a>, ни <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.deactivated">Application.Deactivated</a> не вызываются для XBAP.</p>
</div>
<p><a name="Application_Shutdown"></a></p>
<h3 id="application-shutdown">Завершение работы приложения</h3>
<p>Время существования приложения заканчивается, когда оно завершает работу, что может возникнуть по указанным ниже причинам.</p>
<ul>
<li><p>Пользователь закрывает каждый <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a>.</p>
</li>
<li><p>Пользователь закрывает главное <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a>.</p>
</li>
<li><p>Пользователь завершает сеанс Windows, выходя из системы или выключая компьютер.</p>
</li>
<li><p>Выполнено специальное условие для выхода, определяемое приложением.</p>
</li>
</ul>
<p>Чтобы помочь в управлении завершением работы приложения, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> предоставляет метод <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown">Shutdown</a>, свойство <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> и события <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.sessionending">SessionEnding</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown">Shutdown</a> может вызываться только из приложений, имеющих <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.security.permissions.uipermission">UIPermission</a>. У автономных приложений WPF всегда есть это разрешение. Однако, XBAP-приложения в песочнице с частичным доверием безопасности зоны Интернета его не имеют.</p>
</div>
<h4 id="shutdown-mode">Режим завершения работы</h4>
<p>Большинство приложений завершают работу при закрытии главного окна или всех окон. Однако, иногда завершение работы приложения должно проиходить при других условиях. Можно указать условия, при которых приложение завершит работу, задав <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> с одним из следующих значений перечисления <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode">ShutdownMode</a>:</p>
<ul>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnLastWindowClose">OnLastWindowClose</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnMainWindowClose">OnMainWindowClose</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnExplicitShutdown">OnExplicitShutdown</a></p>
</li>
</ul>
<p>Значение по умолчанию <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> является <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnLastWindowClose">OnLastWindowClose</a>, что означает, что приложение автоматически завершает работу при закрытии пользователем последнего окна в приложении. Тем не менее, если приложение должно завершить работу при закрытии главного окна, WPF автоматически сделает это, если задать для <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> значение <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnMainWindowClose">OnMainWindowClose</a>. Эти действия показаны в следующем примере.</p>
<pre><code class="lang-xaml" name="ApplicationShutdownModeSnippets#OnMainWindowCloseMARKUP">&lt;Application
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    x:Class=&quot;SDKSample.App&quot;
    ShutdownMode=&quot;OnMainWindowClose&quot; /&gt;
</code></pre>
<p>При наличии условия завершения работы приложения, следует установить для <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> значение <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnExplicitShutdown">OnExplicitShutdown</a>. В этом случае необходимо завершить работу приложения путем явного вызова <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown">Shutdown</a> метода; в противном случае приложение будет продолжать работать, даже если закрыты все окна. Обратите внимание, что <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown">Shutdown</a> вызывается неявно при <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> равном <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnLastWindowClose">OnLastWindowClose</a> или <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnMainWindowClose">OnMainWindowClose</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> можно задать из XBAP, но он не учитывается; приложение XBAP всегда завершает работу при выходе из него в браузере или при закрытии браузера, в котором размещается приложение XBAP. Дополнительные сведения см. в разделе <a href="navigation-overview.html">Общие сведения о переходах</a>.</p>
</div>
<h4 id="session-ending">Завершение сеанса</h4>
<p>Условия завершения работы, описываемые свойством <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a>, зависят от конкретного приложения. Однако в некоторых случаях приложение может завершить работу в результате выполнения внешнего условия. Наиболее обычное внешнее условие возникает, когда пользователь завершает сеанс Windows при выполнении следующих действий:</p>
<ul>
<li><p>выход из системы;</p>
</li>
<li><p>завершение работы;</p>
</li>
<li><p>перезапуск;</p>
</li>
<li><p>спящий режим.</p>
</li>
</ul>
<p>Чтобы обнаружить завершение сеанса Windows, можно обрабатывать событие <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.sessionending">SessionEnding</a>, как показано в следующем примере.</p>
<pre><code class="lang-xaml" name="ApplicationSessionEndingSnippets#HandlingSessionEndingXAML">&lt;Application 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    x:Class=&quot;SDKSample.App&quot;
    StartupUri=&quot;MainWindow.xaml&quot;
    SessionEnding=&quot;App_SessionEnding&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND">using System.Windows;

namespace SDKSample
{
    public partial class App : Application
    {
        void App_SessionEnding(object sender, SessionEndingCancelEventArgs e)
        {
            // Ask the user if they want to allow the session to end
            string msg = string.Format(&quot;{0}. End session?&quot;, e.ReasonSessionEnding);
            MessageBoxResult result = MessageBox.Show(msg, &quot;Session Ending&quot;, MessageBoxButton.YesNo);

            // End session, if specified
            if (result == MessageBoxResult.No)
            {
                e.Cancel = true;
            }
        }
    }
}
</code></pre>
<p>В этом примере код проверяет значение <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.sessionendingcanceleventargs.reasonsessionending">ReasonSessionEnding</a>, чтобы определить способ завершения сеанса Windows. Он использует это значение, чтобы отобразить сообщение подтверждения для пользователя. Если пользователю не нужно завершать сеанс, код задает <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.componentmodel.canceleventargs.cancel">Cancel</a> для <code>true</code> чтобы запретить завершение сеанса Windows.</p>
<div class="NOTE">
<h5>Note</h5>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.sessionending">SessionEnding</a> не вызывается для XBAP.</p>
</div>
<h4 id="exit">Exit</h4>
<p>При завершении работы приложения может возникнуть необходимость выполнить окончательную обработку, например сохранение состояния приложения. В подобных случаях можно обрабатывать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a> событий, как <code>App_Exit</code> обработчик события выполняет в следующем примере. Он определен в качестве обработчика событий в <em>App.xaml</em> файл. Его реализация выделена в файл <em>App.xaml.cs</em>.</p>
<pre><code class="lang-xaml" name="Defining-the-Exit-event-handler" highlight-lines="1-7">&lt;Application
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    x:Class=&quot;SDKSample.App&quot;
    StartupUri=&quot;MainWindow.xaml&quot; 
    Startup=&quot;App_Startup&quot; 
    Exit=&quot;App_Exit&quot;&gt;
    &lt;Application.Resources&gt;
        &lt;SolidColorBrush x:Key=&quot;ApplicationScopeResource&quot; Color=&quot;White&quot;&gt;&lt;/SolidColorBrush&gt;
    &lt;/Application.Resources&gt;
&lt;/Application&gt;
</code></pre><pre><code class="lang-csharp" name="Handling-the-Exit-event" highlight-lines="42-55">using System.Windows;
using System.IO;
using System.IO.IsolatedStorage;

namespace SDKSample
{
    public partial class App : Application
    {
        string filename = &quot;App.txt&quot;;

        public App()
        {
            // Initialize application-scope property
            this.Properties[&quot;NumberOfAppSessions&quot;] = 0;
        }

        private void App_Startup(object sender, StartupEventArgs e)
        {
            // Restore application-scope property from isolated storage
            IsolatedStorageFile storage = IsolatedStorageFile.GetUserStoreForDomain();
            try
            {
                using (IsolatedStorageFileStream stream = new IsolatedStorageFileStream(filename, FileMode.Open, storage))
                using (StreamReader reader = new StreamReader(stream))
                {
                    // Restore each application-scope property individually
                    while (!reader.EndOfStream)
                    {
                        string[] keyValue = reader.ReadLine().Split(new char[] {','});
                        this.Properties[keyValue[0]] = keyValue[1];
                    }
                }
            }
            catch (FileNotFoundException ex)
            {
                // Handle when file is not found in isolated storage:
                // * When the first application session
                // * When file has been deleted
            }
        }

        private void App_Exit(object sender, ExitEventArgs e)
        {
            // Persist application-scope property to isolated storage
            IsolatedStorageFile storage = IsolatedStorageFile.GetUserStoreForDomain();
            using (IsolatedStorageFileStream stream = new IsolatedStorageFileStream(filename, FileMode.Create, storage))
            using (StreamWriter writer = new StreamWriter(stream))
            {
                // Persist each application-scope property individually
                foreach (string key in this.Properties.Keys)
                {
                    writer.WriteLine(&quot;{0},{1}&quot;, key, this.Properties[key]);
                }
            }
        }
    }
}
</code></pre>
<p>Полный пример см. в разделе <a href="persist-and-restore-application-scope-properties.html">сохранение и восстановление свойств области приложения</a>.</p>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a> может обрабатываться автономными приложениями и XBAP-приложениями. Для приложения XBAP <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a> вызывается в следующих случаях:</p>
<ul>
<li><p>Будет выполнен выход из приложения XBAP.</p>
</li>
<li><p>В Internet Explorer 7, при закрытии вкладки, на которой размещается приложение XBAP.</p>
</li>
<li><p>Закрывается браузер.</p>
</li>
</ul>
<h4 id="exit-code">Код выхода</h4>
<p>Приложения, как правило, запускаются операционной системой в ответ на запрос пользователя. Однако приложение может быть запущено другим приложением для выполнения определенной задачи. При завершении работы запущенного приложения приложению, которое его запустило, может понадобиться выяснить условие, при котором запущенное приложение завершает работу. В таких ситуациях Windows позволяет приложениям вернуть код выхода приложения при завершении работы. По умолчанию для приложений WPF возвращается значение кода выхода 0.</p>
<div class="NOTE">
<h5>Note</h5>
<p>При отладке из Visual Studio, код выхода приложения отображается в окне <strong>вывода</strong>, когда приложение завершает работу, в сообщении, которое выглядит следующим образом:</p>
<p><code>The program '[5340] AWPFApp.vshost.exe: Managed' has exited with code 0 (0x0).</code></p>
<p>Окно <strong>вывода</strong> можно открыть, нажав кнопку <strong>выходные данные</strong> в меню <strong>представление</strong>.</p>
</div>
<p>Чтобы изменить код выхода, вы можете вызвать перегрузку <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown#System_Windows_Application_Shutdown_System_Int32_">Shutdown(Int32)</a>, которая принимает целочисленный аргумент для кода выхода:</p>
<pre><code class="lang-csharp" name="ApplicationExitSnippets#AppExitCODE">// Shutdown and return a non-default exit code
Application.Current.Shutdown(-1);
</code></pre>
<p>Можно определить значение кода выхода и изменить его, обработав событие <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a>. Обработчику события <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a> передаются <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.exiteventargs">ExitEventArgs</a>, которые обеспечивает доступ к коду выхода через свойство <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.exiteventargs.applicationexitcode">ApplicationExitCode</a>. Дополнительные сведения см. в разделе <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Можно задать код выхода в автономных приложениях и XBAP-приложениях. Однако значение кода выхода игнорируется для XBAP.</p>
</div>
<p><a name="Unhandled_Exceptions"></a></p>
<h3 id="unhandled-exceptions">Необработанные исключения</h3>
<p>Иногда приложение может завершить работу из-за неправильного состояния, например когда создается непредвиденное исключение. В этом случае в приложении может не быть кода для обнаружения и обработки исключения. Исключение такого типа является необработанным. Перед закрытием приложения выводится уведомление, похожее на показанное на рисунке ниже.</p>
<p><img src="media/application-management-overview/unhandled-exception-notification.png" alt="Снимок экрана, показывающий уведомление о необработанном исключении."></p>
<p>С точки зрения работы пользователя такое поведение приложения по умолчанию лучше переопределить, выполнив некоторые (или все) из следующих действий:</p>
<ul>
<li><p>отображение понятных для пользователя сведений;</p>
</li>
<li><p>попытка продолжить выполнение приложения;</p>
</li>
<li><p>запись подробных, понятных разработчику особых сведений в журнал событий Windows.</p>
</li>
</ul>
<p>Реализация этой поддержки зависит от возможности обнаружить необработанные исключения, которую предоставляет событие <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.dispatcherunhandledexception">DispatcherUnhandledException</a>.</p>
<pre><code class="lang-xaml" name="detecting-unhandled-exceptions">&lt;Application
  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
  x:Class=&quot;SDKSample.App&quot;
  StartupUri=&quot;MainWindow.xaml&quot;
  DispatcherUnhandledException=&quot;App_DispatcherUnhandledException&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="code-to-detect-unhandled-exceptions">using System.Windows;
using System.Windows.Threading;

namespace SDKSample
{
    public partial class App : Application
    {
        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            // Process unhandled exception

            // Prevent default unhandled exception processing
            e.Handled = true;
        }
    }
}
</code></pre>
<p>Обработчику события <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.dispatcherunhandledexception">DispatcherUnhandledException</a> передаются <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.threading.dispatcherunhandledexceptioneventargs">DispatcherUnhandledExceptionEventArgs</a>, содержащие контекстные сведения, касающиеся необработанного исключения, включая само исключение (<a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.threading.dispatcherunhandledexceptioneventargs.exception">DispatcherUnhandledExceptionEventArgs.Exception</a>). Эту информацию можно использовать для определения способа обработки исключений.</p>
<p>При обработке <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.dispatcherunhandledexception">DispatcherUnhandledException</a> следует задать для свойства  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.threading.dispatcherunhandledexceptioneventargs.handled">DispatcherUnhandledExceptionEventArgs.Handled</a> значение <code>true</code>; в противном случае WPF по-прежнему рассматривает исключение как необработанное и возвращается к поведению по умолчанию, описанному ранее. Если возникает необработанное исключение и событие  <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.dispatcherunhandledexception">DispatcherUnhandledException</a> не обрабатывается или свойству <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.threading.dispatcherunhandledexceptioneventargs.handled">Handled</a> присваивается <code>false</code>, приложение немедленно завершает работу. Кроме того никакие другие события <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> не вызываются. Следовательно, вам нужно обрабатывать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.dispatcherunhandledexception">DispatcherUnhandledException</a>, если ваше приложение имеет код, который должен выполняться до завершения работы приложения.</p>
<p>Хотя приложение может завершить работу в результате возникновения необработанного исключения, приложение обычно завершает работу в ответ на запрос пользователя, как описано в следующем разделе.</p>
<p><a name="Application_Lifetime_Events"></a></p>
<h3 id="application-lifetime-events">События жизненного цикла приложения</h3>
<p>Автономные приложения и приложения XBAP имеют разное время жизни. На приведенном ниже рисунке продемонстрированы ключевые события времени существования автономного приложения и показана последовательность, в которой они создаются.</p>
<p><img src="media/applicationmodeloverview-applicationobjectevents.png" alt="Автономное приложение — события объекта Application" title="ApplicationModelOverview_ApplicationObjectEvents"></p>
<p>Аналогичным образом приведенном ниже рисунке продемонстрированы ключевые события времени существования XBAP и показана последовательность, в котором они вызываются.</p>
<p><img src="media/applicationmodeloverview-applicationobjectevents-xbap.png" alt="XBAP — события объекта Application" title="ApplicationModelOverview_ApplicationObjectEvents_xbap"></p>
<h2 id="see-also">См. также</h2>
<ul>
<li><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a></li>
<li><a href="wpf-windows-overview.html">Общие сведения об окнах WPF</a></li>
<li><a href="navigation-overview.html">Общие сведения о переходах</a></li>
<li><a href="wpf-application-resource-content-and-data-files.html">Ресурсы, Содержимое и Файлы данных WPF-приложения</a></li>
<li><a href="pack-uris-in-wpf.html">URI типа &quot;pack&quot; в WPF</a></li>
<li><a href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms749013(v=vs.100)">Модель приложения: Практические руководства</a></li>
<li><a href="index.html">Разработка приложений</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span><a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru">Неофициальная документация по .NET на русском языке</a>. Лицензия: <a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru/blob/main/LICENSE">CC-BY 4.0</a>. Основано на <a href="https://docs.microsoft.com/ru-ru/dotnet/">документации по .NET с Microsoft Docs</a><br>Generated by <strong>DocFX</strong></span><script type="text/javascript">(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(65150713, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/65150713" style="position:absolute; left:-9999px;" alt=""></div></noscript>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
