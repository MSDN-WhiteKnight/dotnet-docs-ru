<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1054;&#1073;&#1097;&#1080;&#1077; &#1089;&#1074;&#1077;&#1076;&#1077;&#1085;&#1080;&#1103; &#1086;&#1073; &#1091;&#1087;&#1088;&#1072;&#1074;&#1083;&#1077;&#1085;&#1080;&#1080; &#1087;&#1088;&#1080;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1077;&#1084; | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1054;&#1073;&#1097;&#1080;&#1077; &#1089;&#1074;&#1077;&#1076;&#1077;&#1085;&#1080;&#1103; &#1086;&#1073; &#1091;&#1087;&#1088;&#1072;&#1074;&#1083;&#1077;&#1085;&#1080;&#1080; &#1087;&#1088;&#1080;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1077;&#1084; | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="application-management-overview">Общие сведения об управлении приложением</h1>

<p>Все приложения имеют тенденцию совместно использовать общий набор функциональных возможностей, который применяется к реализации приложения и управлению им. В этом разделе представлен обзор функциональных возможностей в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> класс для создания и управления приложениями.</p>
<h2 id="the-application-class">Класс Application</h2>
<p>В WPF, функциональные возможности области определения приложения инкапсулируются в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> класса. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> Класс включает в себя следующие функциональные возможности:</p>
<ul>
<li><p>отслеживание и взаимодействие со временем существования приложения;</p>
</li>
<li><p>извлечение и обработка параметров командной строки;</p>
</li>
<li><p>обнаружение необработанных исключений и реагирование на них;</p>
</li>
<li><p>совместное использование свойств области определения приложения и ресурсов;</p>
</li>
<li><p>управление окнами в автономных приложениях;</p>
</li>
<li><p>отслеживание навигации и управление ею.</p>
</li>
</ul>
<p><a name="The_Application_Class"></a></p>
<h2 id="how-to-perform-common-tasks-using-the-application-class">Выполнение стандартных задач с помощью класса приложения</h2>
<p>Если вы не интересуют все аспекты <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> класса, в следующей таблице перечислены некоторые из наиболее распространенных задач <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> и способах их выполнения. Чтобы получить дополнительные сведения и образец кода, просмотрите связанные API и разделы.</p>
<table>
<thead>
<tr>
<th>Задача</th>
<th>Подход</th>
</tr>
</thead>
<tbody>
<tr>
<td>Получение объекта, представляющего текущее приложение</td>
<td>Используйте свойство <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.current">Application.Current</a>.</td>
</tr>
<tr>
<td>Добавление заставки в приложение</td>
<td>См. в разделе <a href="how-to-add-a-splash-screen-to-a-wpf-application.html">Добавление в WPF-приложение экрана-заставки</a>.</td>
</tr>
<tr>
<td>Запуск приложения</td>
<td>Воспользуйтесь методом <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.run">Application.Run</a>.</td>
</tr>
<tr>
<td>Остановка приложения</td>
<td>Используйте <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown">Shutdown</a> метод <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.current">Application.Current</a> объекта.</td>
</tr>
<tr>
<td>Получение аргументов из командной строки</td>
<td>Обрабатывать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Application.Startup</a> и использовать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.startupeventargs.args">StartupEventArgs.Args</a> свойство. Например, см. в разделе <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Application.Startup</a> событий.</td>
</tr>
<tr>
<td>Получение и задание кода завершения приложения</td>
<td>Задайте <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.exiteventargs.applicationexitcode">ExitEventArgs.ApplicationExitCode</a> свойство в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Application.Exit</a> обработчик событий или вызова <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown">Shutdown</a> метод и передайте целое число.</td>
</tr>
<tr>
<td>Обнаружение необработанных исключений и реагирование на них</td>
<td>Обрабатывать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.dispatcherunhandledexception">DispatcherUnhandledException</a> событий.</td>
</tr>
<tr>
<td>Получение и задание ресурсов области определения приложения</td>
<td>Используйте свойство <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.resources">Application.Resources</a>.</td>
</tr>
<tr>
<td>Использование словаря ресурсов области определения приложения</td>
<td>См. в разделе <a href="how-to-use-an-application-scope-resource-dictionary.html">использование словаря ресурсов области определения приложения</a>.</td>
</tr>
<tr>
<td>Получение и задание свойств области определения приложения</td>
<td>Используйте свойство <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.properties">Application.Properties</a>.</td>
</tr>
<tr>
<td>Получение и сохранение состояния приложения</td>
<td>См. в разделе <a href="persist-and-restore-application-scope-properties.html">сохранение и восстановление свойств области определения приложения в сеансах приложения</a>.</td>
</tr>
<tr>
<td>Управление файлами данных без кода, включая файлы ресурсов, файлы содержимого и файлы исходного сайта.</td>
<td>См. в разделе <a href="wpf-application-resource-content-and-data-files.html">ресурса приложения WPF, содержимое и файлы данных</a>.</td>
</tr>
<tr>
<td>Управление окнами в автономных приложениях</td>
<td>См. раздел <a href="wpf-windows-overview.html">Общие сведения об окнах WPF</a>.</td>
</tr>
<tr>
<td>Отслеживание навигации и управление ею</td>
<td>См. в разделе <a href="navigation-overview.html">Общие сведения о переходах</a>.</td>
</tr>
</tbody>
</table>
<p><a name="The_Application_Definition"></a></p>
<h2 id="the-application-definition">Определение приложения</h2>
<p>Чтобы использовать функциональные возможности <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> класса, необходимо реализовать определение приложения. Определение приложения WPF — это класс, производный от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> и настраивается с помощью специальная настройка MSBuild.</p>
<h3 id="implementing-an-application-definition">Реализация определения приложения</h3>
<p>Типичное определение приложения WPF реализуется с помощью разметки и кода. Это позволяет использовать разметку для декларативного задания свойств и ресурсов приложения и регистрации событий, а обработку событий и поведение приложения реализовывать в коде программной части.</p>
<p>В следующем примере показано, как реализовать определение приложения с помощью разметки и кода программной части:</p>
<pre><code class="lang-xaml" name="ApplicationSnippets#ApplicationXAML">&lt;Application 
  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; 
  x:Class=&quot;SDKSample.App&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="ApplicationSnippets#ApplicationCODEBEHIND">using System.Windows;

namespace SDKSample
{
    public partial class App : Application { }
}
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Для совместной работы файла разметки и файла кода программной части должны выполняться указанные ниже условия.</p>
<ul>
<li><p>В разметке <code>Application</code> элемент должен включать <code>x:Class</code> атрибута. При построении приложения существование <code>x:Class</code> в разметке файл вызывает MSBuild для создания <code>partial</code> класс, производный от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> и имеет имя, которое задается параметром <code>x:Class</code> атрибута. Это требуется добавить объявление пространства имен XML для схемы XAML (<code>xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</code>).</p>
</li>
<li><p>В коде программной части класс должен быть <code>partial</code> класс с тем же именем, который задается параметром <code>x:Class</code> атрибут в разметке и должен быть производным от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a>. Это позволяет файл кода должно быть связано с <code>partial</code> класса, созданного для файла разметки при построении приложения (см. в разделе <a href="building-a-wpf-application-wpf.html">построение приложения WPF</a>).</p>
</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>При создании нового проекта приложения WPF или проекта приложения браузера WPF с помощью Visual Studio, определение приложения включается по умолчанию и определяется с помощью разметки и кода.</p>
</div>
<p>Этот код является минимумом, необходимым для реализации определения приложения. Однако на дополнительную конфигурацию MSBuild должен выполняться в определении приложения перед построением и запуском приложения.</p>
<h3 id="configuring-the-application-definition-for-msbuild">Настройка определения приложения для MSBuild</h3>
<p>Автономные приложения и приложения браузера XAML (XBAP) требуют реализации инфраструктуры определенного уровня перед своим запуском. Наиболее важной частью этой инфраструктуры является точка входа. При запуске приложения пользователем операционная система вызывает точку входа, которая является известной функцией для запуска приложений.</p>
<p>Обычно разработчикам требовалось писать весь этот код или его часть самостоятельно в зависимости от технологии. Тем не менее, WPF создает этот код автоматически, при настройке файла разметки для определения приложения в качестве MSBuild <code>ApplicationDefinition</code> элемента, как показано в следующем файле проекта MSBuild:</p>
<pre><code class="lang-xml">&lt;Project   
  DefaultTargets=&quot;Build&quot;  
                        xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;  
  ...  
  &lt;ApplicationDefinition Include=&quot;App.xaml&quot; /&gt;  
  &lt;Compile Include=&quot;App.xaml.cs&quot; /&gt;  
  ...  
&lt;/Project&gt;  
</code></pre>
<p>Так как файл кода содержит код, он помечается как MSBuild <code>Compile</code> элементов, что является нормальным.</p>
<p>Применение этих конфигураций MSBuild к файлам разметки и кода программной части определения приложения заставляет MSBuild для создания кода следующим образом:</p>
<pre><code class="lang-csharp" name="auto-generated-code">using System;
using System.Windows;

namespace SDKSample
{
    public class App : Application
    {
        public App() { }
        [STAThread]
        public static void Main()
        {
            // Create new instance of application subclass
            App app = new App();

            // Code to register events and set properties that were
            // defined in XAML in the application definition
            app.InitializeComponent();

            // Start running the application
            app.Run();
        }

        public void InitializeComponent()
        {
            // Initialization code goes here.
        }
    }
}
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Результирующий код дополняет ваше определение приложения кодом инфраструктуры, которая включает в себя метод точки входа <code>Main</code>. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.stathreadattribute">STAThreadAttribute</a> Атрибут применяется к <code>Main</code> метод, чтобы указать, что основной поток пользовательского интерфейса для приложения WPF является потоком STA, который необходим для приложений WPF. При вызове <code>Main</code> создает новый экземпляр класса <code>App</code> перед вызовом <code>InitializeComponent</code> метод для регистрации событий и задания свойств, реализованных в разметке. Так как <code>InitializeComponent</code> создается автоматически, не нужно явно вызывать <code>InitializeComponent</code> из определения приложения как для <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.page">Page</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> реализаций. Наконец <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.run">Run</a> метод вызывается для запуска приложения.</p>
<p><a name="Getting_the_Current_Application"></a></p>
<h2 id="getting-the-current-application">Получение текущего приложения</h2>
<p>Так как функциональные возможности <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> являются общими для всего приложения, может существовать только один экземпляр <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> класса на <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.appdomain">AppDomain</a>. Для применения этого, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> класс реализован в виде singleton-класса (см. в разделе <a href="https://go.microsoft.com/fwlink/?LinkId=100567">Реализация Singleton в C# </a>), который создает один экземпляр себя и предоставляет общий доступ к нему с помощью <code>static</code><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.current">Current</a> свойство.</p>
<p>Ниже показано, как получить ссылку на <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> объект для текущего <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.appdomain">AppDomain</a>.</p>
<pre><code class="lang-csharp" name="ApplicationManagementOverviewSnippets#GetCurrentAppCODE">// Get current application
Application current = App.Current;
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.current">Current</a> Возвращает ссылку на экземпляр <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> класса. Если требуется ссылка на вашей <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> производного класса, необходимо привести значение <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.current">Current</a> свойства, как показано в следующем примере.</p>
<pre><code class="lang-csharp" name="ApplicationManagementOverviewSnippets#GetSTCurrentAppCODE">// Get strongly-typed current application
App app = (App)App.Current;
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Вы можете проверить значение <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.current">Current</a> в любой момент времени существования <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> объекта. Однако следует соблюдать осторожность. После <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> создается экземпляр класса, в течение во время которого состояние <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> непредсказуемо. В течение этого периода <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> выполняет различные задачи инициализации, необходимые в коде для выполнения, включая установку инфраструктуры приложения, настройку свойств и регистрацию событий. Если вы попытаетесь использовать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> объекта в течение этого периода, код может иметь непредвиденные результаты, особенно в том случае, если он зависит от различных <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> задаваемые свойства.</p>
<p>Когда <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> завершает свою работу инициализации, начинается его время существования.</p>
<p><a name="Application_Lifetime"></a></p>
<h2 id="application-lifetime">Время существования приложения</h2>
<p>Время существования приложения WPF отмечается несколько событий, вызываемых <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> сообщить вам о был начат приложения, активировано, деактивации и завершает работу.</p>
<p><a name="Splash_Screen"></a></p>
<h3 id="splash-screen">Заставка</h3>
<p>Начиная с версии .NET Framework 3.5 SP1, можно указать изображение, которое может использоваться в заставке или <em>экран-заставка</em>. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.splashscreen">SplashScreen</a> Класс позволяет легко отобразить заставку во время загрузки приложения. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.splashscreen">SplashScreen</a> Окно создается и отображается перед <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.run">Run</a> вызывается. Дополнительные сведения см. в разделе <a href="../advanced/application-startup-time.html">время запуска приложения</a> и <a href="how-to-add-a-splash-screen-to-a-wpf-application.html">Добавление в WPF-приложение экрана-заставки</a>.</p>
<p><a name="Starting_an_Application"></a></p>
<h3 id="starting-an-application">Запуск приложения</h3>
<p>После <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.run">Run</a> вызывается и инициализации приложения, оно будет готово к запуску. Этот момент обозначается при <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Startup</a> события:</p>
<pre><code class="lang-csharp" name="Startup-event">using System.Windows;

namespace SDKSample
{
    public partial class App : Application
    {
        void App_Startup(object sender, StartupEventArgs e)
        {
            // Application is running
        }
    }
}
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>На этом этапе в жизни приложения, наиболее распространенный способ — показать пользовательский Интерфейс.</p>
<p><a name="Showing_a_User_Interface"></a></p>
<h3 id="showing-a-user-interface">Отображение пользовательского интерфейса</h3>
<p>Большинство автономных приложений Windows откройте <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> когда начинается выполнение. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Startup</a> Обработчик событий — в одном месте, откуда это можно сделать, как показано в следующем примере кода.</p>
<pre><code class="lang-xaml" name="AppShowWindowHardSnippets#StartupEventMARKUP">&lt;Application
  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
  x:Class=&quot;SDKSample.App&quot; 
  Startup=&quot;App_Startup&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="AppShowWindowHardSnippets#StartupEventCODEBEHIND">using System.Windows;

namespace SDKSample
{
    public partial class App : Application
    {
        void App_Startup(object sender, StartupEventArgs e)
        {
            // Open a window
            MainWindow window = new MainWindow();
            window.Show();
        }
    }
}
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<div class="NOTE">
<h5>Note</h5>
<p>Первый <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> для реализации в автономное приложение становится главного окна приложения по умолчанию. Это <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> объект ссылается <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.mainwindow">Application.MainWindow</a> свойство. Значение <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.mainwindow">MainWindow</a> свойство может быть изменено программными средствами, если другое окно первый экземпляр <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> должно быть главного окна.</p>
</div>
<p>При первом запуске приложение XBAP, он скорее всего, чтобы перейти <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.page">Page</a>. Это показано в приведенном ниже коде.</p>
<pre><code class="lang-xaml" name="XBAPAppStartupSnippets#StartupXBAPMARKUP">&lt;Application 
  x:Class=&quot;SDKSample.App&quot;
  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
  Startup=&quot;App_Startup&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="XBAPAppStartupSnippets#StartupXBAPCODEBEHIND">using System;
using System.Windows;
using System.Windows.Navigation;

namespace SDKSample
{
    public partial class App : Application
    {
        void App_Startup(object sender, StartupEventArgs e)
        {
            ((NavigationWindow)this.MainWindow).Navigate(new Uri(&quot;HomePage.xaml&quot;, UriKind.Relative));
        }
    }
}
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Если вы обрабатываете <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Startup</a> открывать только <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> или перейдите к <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.page">Page</a>, можно задать <code>StartupUri</code> атрибут в разметке.</p>
<p>В следующем примере показано, как использовать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startupuri">StartupUri</a> из отдельного приложения, чтобы открыть <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a>.</p>
<pre><code class="lang-xaml" name="ApplicationManagementOverviewSnippets#OverviewStartupUriMARKUP">&lt;Application
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    StartupUri=&quot;MainWindow.xaml&quot; /&gt;
</code></pre>
<p>В следующем примере показано, как использовать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startupuri">StartupUri</a> из XBAP, чтобы перейти к <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.page">Page</a>.</p>
<pre><code class="lang-xaml" name="PageSnippets#XBAPStartupUriMARKUP">&lt;Application
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    StartupUri=&quot;HomePage.xaml&quot; /&gt;
</code></pre>
<p>Эта разметка действует так же, как и предыдущий код для открытия окна.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Дополнительные сведения о навигации, см. в разделе <a href="navigation-overview.html">Общие сведения о переходах</a>.</p>
</div>
<p>Вам нужно обрабатывать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Startup</a> событие, чтобы открыть <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> необходимо создать его с помощью конструктора не по умолчанию, необходимо задать его свойства либо подписаться на его события перед его отображением или вам необходимо обработать любые аргументы командной строки, были заданы при запуске приложения.</p>
<p><a name="Processing_Command_Line_Arguments"></a></p>
<h3 id="processing-command-line-arguments">Обработка аргументов командной строки</h3>
<p>В Windows автономные приложения можно запустить из командной строки или с рабочего стола. В обоих случаях аргументы командной строки могут быть переданы приложению. В приведенном ниже примере показано приложение, которое запускается с одним аргументом командной строки /StartMinimized:</p>
<p><code>wpfapplication.exe /StartMinimized</code></p>
<p>Во время инициализации приложения WPF, Получает аргументы командной строки из операционной системы и передает их <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Startup</a> обработчик событий через <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.startupeventargs.args">Args</a> свойство <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.startupeventargs">StartupEventArgs</a> параметр. Аргументы командной строки можно извлечь и сохранить с помощью приведенного ниже кода.</p>
<pre><code class="lang-xaml" name="ApplicationStartupSnippets#HandleStartupXAML">&lt;Application
  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
  x:Class=&quot;SDKSample.App&quot;
  Startup=&quot;App_Startup&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="ApplicationStartupSnippets#HandleStartupCODEBEHIND">using System.Windows;

namespace SDKSample
{
    public partial class App : Application
    {
        void App_Startup(object sender, StartupEventArgs e)
        {
            // Application is running
            // Process command line args
            bool startMinimized = false;
            for (int i = 0; i != e.Args.Length; ++i)
            {
                if (e.Args[i] == &quot;/StartMinimized&quot;)
                {
                    startMinimized = true;
                }
            }

            // Create main application window, starting minimized if specified
            MainWindow mainWindow = new MainWindow();
            if (startMinimized)
            {
                mainWindow.WindowState = WindowState.Minimized;
            }
            mainWindow.Show();
        }
    }
}
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Код обрабатывает <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Startup</a> проверяемый ли <strong>/StartMinimized</strong> аргумент командной строки; Если Да, он открывает главное окно с <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstate">WindowState</a> из <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstate#System_Windows_WindowState_Minimized">Minimized</a>. Обратите внимание, что поскольку <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.windowstate">WindowState</a> свойства необходимо задать значение программно, основной <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> должен быть явным образом открыто в коде.</p>
<p>XBAP-приложения не может получить и обработать аргументы командной строки, так как они запускаются с помощью развертывания ClickOnce (см. в разделе <a href="deploying-a-wpf-application-wpf.html">развертывание приложений WPF</a>). Однако они могут извлекать и обрабатывать строковые параметры запроса из URL-адресов, которые используются для их запуска.</p>
<p><a name="Application_Activation_and_Deactivation"></a></p>
<h3 id="application-activation-and-deactivation">Активация и отключение приложения</h3>
<p>Windows позволяет пользователям переключаться между приложениями. Наиболее простой способ — использовать клавиши ALT+TAB. Приложения можно переключить только в том случае, если оно содержит видимое <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> , пользователь может выбрать. Выбранного в данный момент <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> — <em>активного окна</em> (также известный как <em>окно переднего плана</em>) и является <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> , получающий ввод данных пользователем. Приложение с активным окном является <em>активное приложение</em> (или <em>приложения переднего плана</em>). Приложение становится активным в указанных ниже случаях.</p>
<ul>
<li><p>Оно запускается и отображает <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a>.</p>
</li>
<li><p>Пользователь переключается из другого приложения, выбрав <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> в приложении.</p>
</li>
</ul>
<p>Вы может определить, когда приложение активируется при обработке <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.activated">Application.Activated</a> событий.</p>
<p>Аналогичным образом приложение может стать неактивным в указанных ниже случаях.</p>
<ul>
<li><p>Пользователь переключается на другое приложение из текущего.</p>
</li>
<li><p>Приложение завершает работу.</p>
</li>
</ul>
<p>Можно обнаружить, когда приложение становится неактивным, обрабатывая <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.deactivated">Application.Deactivated</a> событий.</p>
<p>Ниже показано, как обрабатывать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.activated">Activated</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.deactivated">Deactivated</a> событий, чтобы определить, активно ли приложение.</p>
<pre><code class="lang-xaml" name="ApplicationActivationSnippets#DetectActivationStateXAML">&lt;Application 
  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
  x:Class=&quot;SDKSample.App&quot;
  StartupUri=&quot;MainWindow.xaml&quot;
  Activated=&quot;App_Activated&quot; 
  Deactivated=&quot;App_Deactivated&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="ApplicationActivationSnippets#DetectActivationStateCODEBEHIND">using System;
using System.Windows;

namespace SDKSample
{
    public partial class App : Application
    {
        bool isApplicationActive;

        void App_Activated(object sender, EventArgs e)
        {
            // Application activated
            this.isApplicationActive = true;
        }

        void App_Deactivated(object sender, EventArgs e)
        {
            // Application deactivated
            this.isApplicationActive = false;
        }
    }
}
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Объект <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> также можно активировать и деактивировать. Дополнительные сведения см. в разделах <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.activated">Window.Activated</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.deactivated">Window.Deactivated</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Ни <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.activated">Application.Activated</a> , ни <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.deactivated">Application.Deactivated</a> вызывается для XBAP.</p>
</div>
<p><a name="Application_Shutdown"></a></p>
<h3 id="application-shutdown">Завершение работы приложения</h3>
<p>Время существования приложения заканчивается, когда оно завершает работу, что может возникнуть по указанным ниже причинам.</p>
<ul>
<li><p>Пользователь закрывает каждый <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a>.</p>
</li>
<li><p>Пользователь закрывает главное <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a>.</p>
</li>
<li><p>Пользователь завершает сеанс Windows, системы или завершая.</p>
</li>
<li><p>Выполнено специальное условие для приложения.</p>
</li>
</ul>
<p>Чтобы помочь в управлении завершением работы приложения, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> предоставляет <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown">Shutdown</a> метод, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> свойство и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.sessionending">SessionEnding</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a> события.</p>
<div class="NOTE">
<h5>Note</h5>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown">Shutdown</a> может вызываться только из приложений, имеющих <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.security.permissions.uipermission">UIPermission</a>. WPF автономных приложений всегда есть это разрешение. Тем не менее XBAP-приложения в песочнице с частичным доверием безопасности зоны Интернета не завершает работу.</p>
</div>
<h4 id="shutdown-mode">Режим завершения работы</h4>
<p>Большинство приложений завершают работу при закрытии главного окна или всех окон. Иногда, однако, другие условия конкретного приложения могут определить, когда приложение завершает работу. Можно указать условия, при которых приложение завершит работу, задав <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> с одним из следующих <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode">ShutdownMode</a> значений перечисления:</p>
<ul>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnLastWindowClose">OnLastWindowClose</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnMainWindowClose">OnMainWindowClose</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnExplicitShutdown">OnExplicitShutdown</a></p>
</li>
</ul>
<p>Значение по умолчанию <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> является <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnLastWindowClose">OnLastWindowClose</a>, что означает, что приложение автоматически завершает работу при закрытии пользователем последнего окна в приложении. Тем не менее, если приложение должно завершить работу при закрытии главного окна, WPF автоматически делает это, если задать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> для <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnMainWindowClose">OnMainWindowClose</a>. Эти действия показаны в следующем примере.</p>
<pre><code class="lang-xaml" name="ApplicationShutdownModeSnippets#OnMainWindowCloseMARKUP">&lt;Application
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    x:Class=&quot;SDKSample.App&quot;
    ShutdownMode=&quot;OnMainWindowClose&quot; /&gt;
</code></pre>
<p>При наличии условия завершения работы приложения, следует установить <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> для <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnExplicitShutdown">OnExplicitShutdown</a>. В данном случае это необходимо завершить работу приложения путем явного вызова <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown">Shutdown</a> метода; в противном случае приложение будет продолжать, даже если закрыты все окна. Обратите внимание, что <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown">Shutdown</a> вызывается неявно при <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> либо <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnLastWindowClose">OnLastWindowClose</a> или <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnMainWindowClose">OnMainWindowClose</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> можно задать из XBAP, но он учитывается; приложение XBAP всегда завершает работу при его переходе в браузере или при закрытии браузера, на котором размещается приложение XBAP. Дополнительные сведения см. в разделе <a href="navigation-overview.html">Общие сведения о переходах</a>.</p>
</div>
<h4 id="session-ending">Завершение сеанса</h4>
<p>Условия завершения работы, описываемым <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> свойства зависят от конкретного приложения. Однако в некоторых случаях приложение может завершить работу в результате выполнения внешнего условия. Наиболее обычное внешнее условие возникает, когда пользователь завершает сеанс Windows при выполнении следующих действий:</p>
<ul>
<li><p>выход из системы;</p>
</li>
<li><p>завершение работы;</p>
</li>
<li><p>перезапуск;</p>
</li>
<li><p>спящий режим.</p>
</li>
</ul>
<p>Чтобы обнаружить при завершении сеанса Windows, можно обрабатывать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.sessionending">SessionEnding</a> событий, как показано в следующем примере.</p>
<pre><code class="lang-xaml" name="ApplicationSessionEndingSnippets#HandlingSessionEndingXAML">&lt;Application 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    x:Class=&quot;SDKSample.App&quot;
    StartupUri=&quot;MainWindow.xaml&quot;
    SessionEnding=&quot;App_SessionEnding&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND">using System.Windows;

namespace SDKSample
{
    public partial class App : Application
    {
        void App_SessionEnding(object sender, SessionEndingCancelEventArgs e)
        {
            // Ask the user if they want to allow the session to end
            string msg = string.Format(&quot;{0}. End session?&quot;, e.ReasonSessionEnding);
            MessageBoxResult result = MessageBox.Show(msg, &quot;Session Ending&quot;, MessageBoxButton.YesNo);

            // End session, if specified
            if (result == MessageBoxResult.No)
            {
                e.Cancel = true;
            }
        }
    }
}
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>В этом примере код проверяет <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.sessionendingcanceleventargs.reasonsessionending">ReasonSessionEnding</a> свойства, чтобы определить способ окончания сеанса Windows. Он использует это значение, чтобы отобразить сообщение подтверждения для пользователя. Если пользователю не нужно завершать сеанс, код задает <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.componentmodel.canceleventargs.cancel">Cancel</a> для <code>true</code> чтобы запретить завершение сеанса Windows.</p>
<div class="NOTE">
<h5>Note</h5>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.sessionending">SessionEnding</a> вызывается для XBAP.</p>
</div>
<h4 id="exit">Exit</h4>
<p>При завершении работы приложения может возникнуть необходимость выполнить окончательную обработку, например сохранение состояния приложения. В подобных случаях можно обрабатывать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a> событий, как <code>App_Exit</code> обработчик события выполняет в следующем примере. Он определен в качестве обработчика событий в <em>App.xaml</em> файл. Его реализация выделяется в <em>App.xaml.cs</em> и <em>Application.xaml.vb</em> файлов.</p>
<pre><code class="lang-xaml" name="Defining-the-Exit-event-handler" highlight-lines="1-7">&lt;Application
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    x:Class=&quot;SDKSample.App&quot;
    StartupUri=&quot;MainWindow.xaml&quot; 
    Startup=&quot;App_Startup&quot; 
    Exit=&quot;App_Exit&quot;&gt;
    &lt;Application.Resources&gt;
        &lt;SolidColorBrush x:Key=&quot;ApplicationScopeResource&quot; Color=&quot;White&quot;&gt;&lt;/SolidColorBrush&gt;
    &lt;/Application.Resources&gt;
&lt;/Application&gt;
</code></pre><pre><code class="lang-csharp" name="Handling-the-Exit-event" highlight-lines="42-55">using System.Windows;
using System.IO;
using System.IO.IsolatedStorage;

namespace SDKSample
{
    public partial class App : Application
    {
        string filename = &quot;App.txt&quot;;

        public App()
        {
            // Initialize application-scope property
            this.Properties[&quot;NumberOfAppSessions&quot;] = 0;
        }

        private void App_Startup(object sender, StartupEventArgs e)
        {
            // Restore application-scope property from isolated storage
            IsolatedStorageFile storage = IsolatedStorageFile.GetUserStoreForDomain();
            try
            {
                using (IsolatedStorageFileStream stream = new IsolatedStorageFileStream(filename, FileMode.Open, storage))
                using (StreamReader reader = new StreamReader(stream))
                {
                    // Restore each application-scope property individually
                    while (!reader.EndOfStream)
                    {
                        string[] keyValue = reader.ReadLine().Split(new char[] {','});
                        this.Properties[keyValue[0]] = keyValue[1];
                    }
                }
            }
            catch (FileNotFoundException ex)
            {
                // Handle when file is not found in isolated storage:
                // * When the first application session
                // * When file has been deleted
            }
        }

        private void App_Exit(object sender, ExitEventArgs e)
        {
            // Persist application-scope property to isolated storage
            IsolatedStorageFile storage = IsolatedStorageFile.GetUserStoreForDomain();
            using (IsolatedStorageFileStream stream = new IsolatedStorageFileStream(filename, FileMode.Create, storage))
            using (StreamWriter writer = new StreamWriter(stream))
            {
                // Persist each application-scope property individually
                foreach (string key in this.Properties.Keys)
                {
                    writer.WriteLine(&quot;{0},{1}&quot;, key, this.Properties[key]);
                }
            }
        }
    }
}
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Полный пример см. в разделе <a href="persist-and-restore-application-scope-properties.html">сохранение и восстановление области определения приложения свойства в сеансах приложения</a>.</p>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a> может обрабатываться автономными приложениями и XBAP-приложения. Для приложения XBAP <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a> вызывается в следующих случаях:</p>
<ul>
<li><p>Приложение XBAP будет выполнен переход от.</p>
</li>
<li><p>В Internet Explorer 7, при закрытии вкладки, на котором размещается приложение XBAP.</p>
</li>
<li><p>Закрывается браузер.</p>
</li>
</ul>
<h4 id="exit-code">Код выхода</h4>
<p>Приложения, как правило, запускаются операционной системой в ответ на запрос пользователя. Однако приложение может быть запущено другим приложением для выполнения определенной задачи. При завершении работы запущенного приложения приложению, которое его запустило, может понадобиться выяснить условие, при котором запущенное приложение завершает работу. В таких ситуациях Windows позволяет приложениям вернуть код выхода приложения при завершении работы. По умолчанию для приложений WPF возвращают значение кода выхода 0.</p>
<div class="NOTE">
<h5>Note</h5>
<p>При отладке из Visual Studio, код выхода приложения отображается в <strong>вывода</strong> окно, когда приложение завершает работу, в сообщении, выглядит следующим образом:</p>
<p><code>The program '[5340] AWPFApp.vshost.exe: Managed' has exited with code 0 (0x0).</code></p>
<p>При открытии <strong>вывода</strong> окно, нажав кнопку <strong>выходные данные</strong> на <strong>представление</strong> меню.</p>
</div>
<p>Чтобы изменить код выхода, вы можете вызвать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown#System_Windows_Application_Shutdown_System_Int32_">Shutdown(Int32)</a> перегрузки, который принимает целочисленный аргумент для кода выхода:</p>
<pre><code class="lang-csharp" name="ApplicationExitSnippets#AppExitCODE">// Shutdown and return a non-default exit code
Application.Current.Shutdown(-1);
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p>Можно определить значение кода выхода и изменить его, обработав <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a> событий. <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a> Обработчику события передаются <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.exiteventargs">ExitEventArgs</a> который обеспечивает доступ к коду выхода с <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.exiteventargs.applicationexitcode">ApplicationExitCode</a> свойство. Дополнительные сведения см. в разделе <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.exit">Exit</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Можно задать код выхода в автономных приложениях и XBAP-приложения. Однако значение кода выхода игнорируется для XBAP.</p>
</div>
<p><a name="Unhandled_Exceptions"></a></p>
<h3 id="unhandled-exceptions">Необработанные исключения</h3>
<p>Иногда приложение может завершить работу из-за неправильного состояния, например когда создается непредвиденное исключение. В этом случае в приложении может не быть кода для обнаружения и обработки исключения. Исключение такого типа является необработанным. Перед закрытием приложения выводится уведомление, похожее на показанное на рисунке ниже.</p>
<p><img src="media/application-management-overview/unhandled-exception-notification.png" alt="Снимок экрана, показывающий уведомление о необработанном исключении."></p>
<p>С точки зрения работы пользователя такое поведение приложения по умолчанию лучше переопределить, выполнив некоторые или все следующие действия:</p>
<ul>
<li><p>отображение понятных для пользователя сведений;</p>
</li>
<li><p>попытка продолжить выполнение приложения;</p>
</li>
<li><p>Запись подробных, понятных разработчику особых сведений в журнале событий Windows.</p>
</li>
</ul>
<p>Реализация этой поддержки зависит от возможности обнаружить необработанные исключения, который является то, что <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.dispatcherunhandledexception">DispatcherUnhandledException</a> для события.</p>
<pre><code class="lang-xaml" name="detecting-unhandled-exceptions">&lt;Application
  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
  x:Class=&quot;SDKSample.App&quot;
  StartupUri=&quot;MainWindow.xaml&quot;
  DispatcherUnhandledException=&quot;App_DispatcherUnhandledException&quot; /&gt;
</code></pre><pre><code class="lang-csharp" name="code-to-detect-unhandled-exceptions">using System.Windows;
using System.Windows.Threading;

namespace SDKSample
{
    public partial class App : Application
    {
        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            // Process unhandled exception

            // Prevent default unhandled exception processing
            e.Handled = true;
        }
    }
}
</code></pre><div class="WARNING">
<h5>Warning</h5>
<p>It looks like the sample you are looking for does not exist.</p>
</div>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.dispatcherunhandledexception">DispatcherUnhandledException</a> Обработчику события передаются <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.threading.dispatcherunhandledexceptioneventargs">DispatcherUnhandledExceptionEventArgs</a> параметр, содержащий контекстные сведения, касающиеся необработанного исключения, включая само исключение (<a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.threading.dispatcherunhandledexceptioneventargs.exception">DispatcherUnhandledExceptionEventArgs.Exception</a>). Эту информацию можно использовать для определения способа обработки исключений.</p>
<p>При обработке <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.dispatcherunhandledexception">DispatcherUnhandledException</a>, следует задать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.threading.dispatcherunhandledexceptioneventargs.handled">DispatcherUnhandledExceptionEventArgs.Handled</a> свойства <code>true</code>; в противном случае WPF по-прежнему рассматривает исключение как необработанное и возвращается к поведению по умолчанию, описанные ранее. Если возникает необработанное исключение и либо <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.dispatcherunhandledexception">DispatcherUnhandledException</a> событие не обрабатывается или событие обрабатывается и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.threading.dispatcherunhandledexceptioneventargs.handled">Handled</a> присваивается <code>false</code>, приложение немедленно завершает работу. Кроме того никакие другие <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> событий. Следовательно, вам нужно обрабатывать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.dispatcherunhandledexception">DispatcherUnhandledException</a> Если ваше приложение имеет код, который должен выполняться до завершения работы приложения.</p>
<p>Хотя приложение может завершить работу в результате возникновения необработанного исключения, приложение обычно завершает работу в ответ на запрос пользователя, как описано в следующем разделе.</p>
<p><a name="Application_Lifetime_Events"></a></p>
<h3 id="application-lifetime-events">Событий приложения</h3>
<p>Автономные приложения и приложения XBAP, не имеют точно одинакового времени жизни. На приведенном ниже рисунке продемонстрированы ключевые события времени существования автономного приложения и показана последовательность, в которой они создаются.</p>
<p><img src="media/applicationmodeloverview-applicationobjectevents.png" alt="Автономное приложение — события объекта Application" title="ApplicationModelOverview_ApplicationObjectEvents"></p>
<p>Аналогичным образом приведенном ниже рисунке продемонстрированы ключевые события времени существования XBAP и показана последовательность, в котором они вызываются.</p>
<p><img src="media/applicationmodeloverview-applicationobjectevents-xbap.png" alt="XBAP — события объекта Application" title="ApplicationModelOverview_ApplicationObjectEvents_xbap"></p>
<h2 id="see-also">См. также</h2>
<ul>
<li><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a></li>
<li><a href="wpf-windows-overview.html">Общие сведения об окнах WPF</a></li>
<li><a href="navigation-overview.html">Общие сведения о переходах</a></li>
<li><a href="wpf-application-resource-content-and-data-files.html">Ресурсы, Содержимое и Файлы данных WPF-приложения</a></li>
<li><a href="pack-uris-in-wpf.html">URI типа &quot;pack&quot; в WPF</a></li>
<li><a href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms749013(v=vs.100)">Модель приложения: Практические руководства</a></li>
<li><a href="index.html">Разработка приложений</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span><a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru">Неофициальная документация по .NET на русском языке</a>. Лицензия: <a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru/blob/main/LICENSE">CC-BY 4.0</a>. Основано на <a href="https://docs.microsoft.com/ru-ru/dotnet/">документации по .NET с Microsoft Docs</a><br>Generated by <strong>DocFX</strong></span><script type="text/javascript">(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(65150713, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/65150713" style="position:absolute; left:-9999px;" alt=""></div></noscript>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
