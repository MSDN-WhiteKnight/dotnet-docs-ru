<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1054;&#1073;&#1097;&#1080;&#1077; &#1089;&#1074;&#1077;&#1076;&#1077;&#1085;&#1080;&#1103; &#1086;&#1073; &#1086;&#1082;&#1085;&#1072;&#1093; WPF | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1054;&#1073;&#1097;&#1080;&#1077; &#1089;&#1074;&#1077;&#1076;&#1077;&#1085;&#1080;&#1103; &#1086;&#1073; &#1086;&#1082;&#1085;&#1072;&#1093; WPF | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="wpf-windows-overview">Общие сведения об окнах WPF</h1>

<p>Пользователи взаимодействуют с Windows Presentation Foundation (WPF) автономных приложений с помощью windows. Основная цель окна — разместить содержимое, которое визуализирует данные и позволяет пользователям взаимодействовать с ними. Автономный WPF приложения предоставляют собственные окна с помощью <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> класса. В данном разделе представлены <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> затем освещаются основы создания и управления окнами в автономных приложениях.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Браузерные WPF приложений, включая XAML-приложения браузера (XBAP) и свободные XAML страниц, не предоставляют собственных окон. Вместо этого они размещаются в окнах, предоставляемых Windows Internet Explorer. См. в разделе <a href="wpf-xaml-browser-applications-overview.html">Общие сведения о приложениях браузера WPF XAML</a>.</p>
</div>
<p><a name="TheWindowClass"></a></p>
<h2 id="the-window-class">Класс окна</h2>
<p>На следующем рисунке показана составляющие части окна:</p>
<p><img src="media/wpf-windows-overview/window-constituent-elements.png" alt="Снимок экрана, показывающий элементов окна."></p>
<p>Окно разделено на две области: неклиентскую и клиентскую.</p>
<p><em>Неклиентской области</em> окна реализуется WPF и включает части окна, которые являются общими для большинства окон, включая следующие:</p>
<ul>
<li><p>Граница.</p>
</li>
<li><p>Заголовок окна.</p>
</li>
<li><p>Значок.</p>
</li>
<li><p>Кнопки &quot;Свернуть&quot;, &quot;Развернуть&quot; и &quot;Восстановить&quot;.</p>
</li>
<li><p>Кнопка &quot;Закрыть&quot;.</p>
</li>
<li><p>Системное меню с элементами, которые позволяют пользователям свернуть, развернуть, восстановить, перемещать, изменять размеры и закрыть окно.</p>
</li>
</ul>
<p><em>Клиентской области</em> окна находится внутри неклиентской области окна и используется разработчиками для добавления содержимого конкретного приложения, такие как строки меню, панелей инструментов и элементов управления.</p>
<p>В WPF, окно инкапсулируется <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> класс, который используется для следующих целей:</p>
<ul>
<li><p>Отобразить окно.</p>
</li>
<li><p>Настроить размер, положение и внешний вид окна.</p>
</li>
<li><p>Разместить содержимое конкретного приложения.</p>
</li>
<li><p>Управлять временем существования окна.</p>
</li>
</ul>
<p><a name="DefiningAWindow"></a></p>
<h2 id="implementing-a-window">Реализация окна</h2>
<p>Реализация типичного окна включает внешний вид и поведение, где <em>внешний вид</em> определяет, как окно отображается для пользователей и <em>поведение</em> определяет функционирование окна при взаимодействии пользователей с ним. В WPF, вы можете реализовать внешний вид и поведение окна с помощью кода, либо или XAML разметки.</p>
<p>Как правило, тем не менее, внешний вид окна реализуется с помощью XAML разметки, а его поведение реализуется с помощью кода программной части, как показано в следующем примере.</p>
<pre><code class="lang-xaml" name="WindowsOverviewSnippets#MarkupAndCodeBehindWindowMARKUP">&lt;Window 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    x:Class=&quot;SDKSample.MarkupAndCodeBehindWindow&quot;&gt;
  
  &lt;!-- Client area (for content) --&gt;
  
&lt;/Window&gt;
</code></pre><pre><code class="lang-csharp" name="WindowsOverviewSnippets#MarkupAndCodeBehindWindowCODEBEHIND">using System.Windows;

namespace SDKSample
{
    public partial class MarkupAndCodeBehindWindow : Window
    {
        public MarkupAndCodeBehindWindow()
        {
            InitializeComponent();
        }
    }
}
</code></pre>
<p>Чтобы включить XAML файла разметки и файл с выделенным кодом для совместной работы, необходимо выполнение следующих условий:</p>
<ul>
<li><p>В разметке <code>Window</code> элемент должен включать <code>x:Class</code> атрибута. При построении приложения существование <code>x:Class</code> в разметке вызывает файл Microsoft Build Engine (MSBuild) для создания <code>partial</code> класс, производный от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> и имеет имя, которое задается параметром <code>x:Class</code> атрибута. Это требует добавления параметра XML объявление пространства имен для XAML схемы ( <code>xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</code> ). Созданный <code>partial</code> класс реализует <code>InitializeComponent</code> метод, который вызывается для регистрации событий и задания свойств, реализованных в разметке.</p>
</li>
<li><p>В коде программной части класс должен быть <code>partial</code> класс с тем же именем, который задается параметром <code>x:Class</code> атрибут в разметке и он должен быть производным от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a>. Это позволяет файл кода должно быть связано с <code>partial</code> класса, созданного для файла разметки при построении приложения (см. в разделе <a href="building-a-wpf-application-wpf.html">построение приложения WPF</a>).</p>
</li>
<li><p>В коде программной части <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> класс должен реализовывать конструктор, который вызывает <code>InitializeComponent</code> метод. <code>InitializeComponent</code> реализуется разметки созданным файлом <code>partial</code> класс для регистрации событий и задания свойств, которые определены в разметке.</p>
</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>При добавлении нового <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> в проект с помощью Microsoft Visual Studio, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> реализуется с помощью разметки и кода и включает необходимую конфигурацию для создания связи между файлами разметки и кода как описанные здесь.</p>
</div>
<p>При такой конфигурации можно сосредоточиться на определении внешнего вида окна в XAML разметки и реализации его поведения в коде. В следующем примере показано окно с кнопкой, реализованной в XAML разметки и обработчик событий для кнопки <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.controls.primitives.buttonbase.click">Click</a> событий, реализован в коде.</p>
<pre><code class="lang-xaml" name="WindowsOverviewWindowWithButtonSnippets#MarkupAndCodeBehindWindowMARKUP">&lt;Window 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    x:Class=&quot;SDKSample.MarkupAndCodeBehindWindow&quot;&gt;
  &lt;!-- Client area (for content) --&gt;
  &lt;Button Click=&quot;button_Click&quot;&gt;Click This Button&lt;/Button&gt;
&lt;/Window&gt;
</code></pre><pre><code class="lang-csharp" name="WindowsOverviewWindowWithButtonSnippets#MarkupAndCodeBehindWindowCODEBEHIND">using System.Windows;

namespace SDKSample
{
    public partial class MarkupAndCodeBehindWindow : Window
    {
        public MarkupAndCodeBehindWindow()
        {
            InitializeComponent();
        }

        void button_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show(&quot;Button was clicked.&quot;);
        }
    }
}
</code></pre>
<p><a name="ConfiguringWindowForMSBuild"></a></p>
<h2 id="configuring-a-window-definition-for-msbuild">Настройка определения окна для MSBuild</h2>
<p>Реализация окна определяет его конфигурацию для MSBuild. Для окна, которое определяется с помощью XAML разметки и кода:</p>
<ul>
<li><p>XAML файлы разметки настраиваются как MSBuild<code>Page</code> элементов.</p>
</li>
<li><p>Файлы кода программной части настраиваются как MSBuild<code>Compile</code> элементов.</p>
</li>
</ul>
<p>Это показано в следующем MSBuild файл проекта.</p>
<pre><code class="lang-xml">&lt;Project ...  
                xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;  
    ...  
    &lt;Page Include=&quot;MarkupAndCodeBehindWindow.xaml&quot; /&gt;  
    &lt;Compile Include=&quot; MarkupAndCodeBehindWindow.xaml.cs&quot; /&gt;  
    ...  
&lt;/Project&gt;  
</code></pre>
<p>Сведения о построении WPF приложений, см. в разделе <a href="building-a-wpf-application-wpf.html">построение приложения WPF</a>.</p>
<p><a name="WindowLifetime"></a></p>
<h2 id="window-lifetime">Время существования окна</h2>
<p>Как и любой класс, окно имеет время существования, которое начинается с момента создания его экземпляра, после чего оно открывается, активируется, деактивируется и, в конечном счете, закрывается.</p>
<p><a name="Opening_a_Window"></a></p>
<h3 id="opening-a-window">Открытие окна</h3>
<p>Чтобы открыть окно, сначала создайте его экземпляр, как показано в следующем примере.</p>
<pre><code class="lang-xaml" name="WindowsOverviewStartupEventSnippets#AppMARKUP">&lt;Application
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    x:Class=&quot;SDKSample.App&quot;
    Startup=&quot;app_Startup&quot;&gt;
&lt;/Application&gt;
</code></pre><pre><code class="lang-csharp" name="WindowsOverviewStartupEventSnippets#AppCODEBEHIND">using System.Windows;
namespace SDKSample
{
    public partial class App : Application
    {
        void app_Startup(object sender, StartupEventArgs e)
        {
            // Create a window
            MarkupAndCodeBehindWindow window = new MarkupAndCodeBehindWindow();

            // Open a window
            window.Show();
        }
    }
}
</code></pre>
<p>В этом примере <code>MarkupAndCodeBehindWindow</code> создается при запуске приложения, который происходит при <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startup">Startup</a> события.</p>
<p>При создании экземпляра окна, ссылку на него автоматически добавляется в список windows под управлением <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> объекта (см. в разделе <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.windows">Application.Windows</a>). Кроме того, первое окно для создания экземпляра по умолчанию задается <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a> как главное окно приложения (см. в разделе <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.mainwindow">Application.MainWindow</a>).</p>
<p>Наконец, открывается окно путем вызова <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.show">Show</a> метода; результат показан на рисунке ниже.</p>
<p><img src="media/wpf-windows-overview/window-opened-show-method.png" alt="Окно открывается путем вызова Window.Show"></p>
<p>Окно, которое открывается путем вызова <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.show">Show</a> безрежимным окном, это означает, что приложение работает в режиме, который позволяет пользователям активировать и другие окна в одном приложении.</p>
<div class="NOTE">
<h5>Note</h5>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.showdialog">ShowDialog</a> вызывается для открытия окна, такие как диалоговые окна в модальном режиме. См. в разделе <a href="dialog-boxes-overview.html">Общие сведения о полях диалогового окна</a> Дополнительные сведения.</p>
</div>
<p>Когда <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.show">Show</a> является именем, окно выполняет работу по инициализации, перед его отображением Чтобы установить инфраструктуру, которая позволяет принимать ввод данных пользователем. При инициализации окна <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.sourceinitialized">SourceInitialized</a> события и отображения окна.</p>
<p>Для быстрого вызова <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startupuri">StartupUri</a> можно задать, чтобы указать первое окно, которое открывается автоматически при запуске приложения.</p>
<pre><code class="lang-xaml" name="WindowsOverviewSnippets#ApplicationStartupUriMARKUP">&lt;Application
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    x:Class=&quot;SDKSample.App&quot;
    StartupUri=&quot;PlainWindow.xaml&quot; /&gt;
</code></pre>
<p>При запуске приложения окном, заданным параметром значение <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.startupuri">StartupUri</a> открывается немодальном режиме; внутри окно открывается путем вызова его <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.show">Show</a> метод.</p>
<p><a name="Ownership"></a></p>
<h4 id="window-ownership">Владение окном</h4>
<p>Окно, которое открывается с помощью <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.show">Show</a> метод не имеет неявной связи с окном, которое он создан; пользователи могут взаимодействовать с любым из окон независимо от другого, это означает, что любое окно может выполнять следующее:</p>
<ul>
<li><p>Перекрывать другое (если только одно из окон не имеет его <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.topmost">Topmost</a> свойство значение <code>true</code>).</p>
</li>
<li><p>Сворачиваться, разворачиваться и восстанавливаться без влияния на другое окно.</p>
</li>
</ul>
<p>Для некоторых окон требуется связь с окном, которое их открывает. Например Интегрированная среда разработки (IDE) приложение может открывать окна свойств и окна инструментов, типичное поведение которых перекрыть окно, которое их создает. Кроме того, такие окна должны всегда закрываться, сворачиваться, разворачиваться и восстанавливаться вместе с окном, которое их создало. Такую связь можно установить, сделав одно окно <em>собственные</em> другой и можно сделать путем установки <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.owner">Owner</a> свойство <em>собственного окна</em> со ссылкой на <em>владельца окно</em>. Эти действия показаны в следующем примере.</p>
<pre><code class="lang-csharp" name="WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE">// Create a window and make this window its owner
Window ownedWindow = new Window();
ownedWindow.Owner = this;
ownedWindow.Show();
</code></pre>
<p>После установки владения:</p>
<ul>
<li><p>Окно во владении может ссылаться на окно-владелец, проверяя значение его <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.owner">Owner</a> свойство.</p>
</li>
<li><p>Окно-владелец может обнаруживать все окна, окна, проверив значение его <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.ownedwindows">OwnedWindows</a> свойство.</p>
</li>
</ul>
<p><a name="Preventing"></a></p>
<h4 id="preventing-window-activation">Предотвращение активации окна</h4>
<p>Существуют сценарии, где windows не должны активироваться при отображении, например диалог windows messenger стиле интернет-приложения или окна уведомлений приложения электронной почты.</p>
<p>Если приложение содержит окно, которое не должно активироваться при отображении, можно задать его <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.showactivated">ShowActivated</a> свойства <code>false</code> перед вызовом <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.show">Show</a> метода в первый раз. Результат:</p>
<ul>
<li><p>Окно не активируется.</p>
</li>
<li><p>Окна <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.activated">Activated</a> событие не происходит.</p>
</li>
<li><p>Текущее активированное окно останется активным.</p>
</li>
</ul>
<p>Однако окно активируется, если пользователь щелкнет его неклиентскую или клиентскую область. В этом случае:</p>
<ul>
<li><p>Окно активируется.</p>
</li>
<li><p>Окна <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.activated">Activated</a> события.</p>
</li>
<li><p>Ранее активированное окно деактивируется.</p>
</li>
<li><p>Окна <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.deactivated">Deactivated</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.activated">Activated</a> вызываются события в ответ на действия пользователя.</p>
</li>
</ul>
<p><a name="Window_Activation"></a></p>
<h3 id="window-activation">Активация окна</h3>
<p>При первом открытии окна оно становится активным (если он отображается с <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.showactivated">ShowActivated</a> присвоено <code>false</code>). <em>Активного окна</em> — это окно, в настоящий момент захватывает входные данные пользователя, например нажатий клавиш и щелчки мышью. Когда окно становится активным, он выдает <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.activated">Activated</a> событий.</p>
<div class="NOTE">
<h5>Note</h5>
<p>При первом открытии окна <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.loaded">Loaded</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.contentrendered">ContentRendered</a> события вызываются после <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.activated">Activated</a> события. С учетом этого окно может считаться открытым при <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.contentrendered">ContentRendered</a> возникает.</p>
</div>
<p>После активизации окна пользователь может активировать другое окно в том же приложении или активировать другое приложение. В этом случае текущее активное окно становится неактивным и вызывает <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.deactivated">Deactivated</a> событий. Аналогично, когда пользователь выбирает неактивное окно, окно снова становится активным и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.activated">Activated</a> возникает.</p>
<p>Одна из основных причин для обработки <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.activated">Activated</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.deactivated">Deactivated</a> — для включения и отключения функций, которые могут выполняться только при активном окне. Например, некоторые окна отображают интерактивное содержимое, которое требует постоянного ввода данных или внимания пользователя, включая игры и видеопроигрыватели. Ниже приведен упрощенный видеопроигрыватель, демонстрирующий способ обработки <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.activated">Activated</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.deactivated">Deactivated</a> для реализации такого поведения.</p>
<pre><code class="lang-xaml" name="WindowsOverviewSnippets#ActivationDeactivationMARKUP">&lt;Window
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    x:Class=&quot;SDKSample.CustomMediaPlayerWindow&quot;
    Activated=&quot;window_Activated&quot;
    Deactivated=&quot;window_Deactivated&quot;&gt;

    &lt;!-- Media Player --&gt;
    &lt;MediaElement 
      Name=&quot;mediaElement&quot; 
      Stretch=&quot;Fill&quot; 
      LoadedBehavior=&quot;Manual&quot; 
      Source=&quot;numbers.wmv&quot; /&gt;

&lt;/Window&gt;
</code></pre><pre><code class="lang-csharp" name="WindowsOverviewSnippets#ActivationDeactivationCODEBEHIND">using System;
using System.Windows;

namespace SDKSample
{
    public partial class CustomMediaPlayerWindow : Window
    {
        public CustomMediaPlayerWindow()
        {
            InitializeComponent();
        }

        void window_Activated(object sender, EventArgs e)
        {
            // Recommence playing media if window is activated
            this.mediaElement.Play();
        }

        void window_Deactivated(object sender, EventArgs e)
        {
            // Pause playing if media is being played and window is deactivated
            this.mediaElement.Pause();
        }
    }
}
</code></pre>
<p>Другие типы приложений могут выполнять код в фоновом режиме, когда окно деактивировано. Например, почтовый клиент может продолжать опрашивать почтовый сервер, пока пользователь работает с другими приложениями. Такие приложения часто обеспечивают другое или дополнительное поведение, когда главное окно не активно. В случае почтовой программы это может означать как добавление нового почтового элемента в папку &quot;Входящие&quot;, так и добавление значка уведомления на панель задач. Значок уведомления требуется отображать, только если почтовое окно неактивно, что можно определить, проверив <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.isactive">IsActive</a> свойство.</p>
<p>Если фоновая задача завершается, окно может потребоваться более срочном уведомлять пользователя, вызвав <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.activate">Activate</a> метод. Если пользователь взаимодействует с другое приложение активируется, когда <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.activate">Activate</a> вызове кнопке панели задач окна мигает. Если пользователь взаимодействует с текущим приложением, вызов метода <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.activate">Activate</a> перенесет окно на передний план.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Можно обрабатывать активацию области приложения с помощью <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.activated">Application.Activated</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.deactivated">Application.Deactivated</a> события.</p>
</div>
<p><a name="Closing_a_Window"></a></p>
<h3 id="closing-a-window">Закрытие окна</h3>
<p>Время существования окна заканчивается, когда пользователь его закрывает. Окно может быть закрыто с помощью элементов в неклиентской области, включая следующие:</p>
<ul>
<li><p><strong>Закрыть</strong> элемент <strong>системы</strong> меню.</p>
</li>
<li><p>Нажатие клавиш ALT+F4.</p>
</li>
<li><p>Нажав клавишу <strong>закрыть</strong> кнопки.</p>
</li>
</ul>
<p>Можно указать дополнительные способы закрытия окна для клиентской области, к наиболее типичным из которых относятся следующие:</p>
<ul>
<li><p><strong>Выхода</strong> элемент <strong>файл</strong> меню, обычно для главных окон приложений.</p>
</li>
<li><p>Объект <strong>закрыть</strong> элемент <strong>файл</strong> меню, обычно для вторичных окон приложений.</p>
</li>
<li><p>Объект <strong>отменить</strong> кнопка, обычно для модального диалогового окна.</p>
</li>
<li><p>Объект <strong>закрыть</strong> кнопка, обычно для немодального диалогового окна.</p>
</li>
</ul>
<p>Чтобы закрыть окно в ответ на один из этих пользовательских механизмов, необходимо вызвать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.close">Close</a> метод. В следующем примере реализуется возможность закрытия окна, выбрав <strong>выхода</strong> на <strong>файл</strong> меню.</p>
<pre><code class="lang-xaml" name="WindowsOverviewSnippets#WindowWithFileExitMARKUP">&lt;Window 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    x:Class=&quot;SDKSample.WindowWithFileExit&quot;&gt;
  
  &lt;Menu&gt;
    &lt;MenuItem Header=&quot;_File&quot;&gt;
      &lt;MenuItem Header=&quot;E_xit&quot; Click=&quot;fileExitMenuItem_Click&quot; /&gt;
    &lt;/MenuItem&gt;
  &lt;/Menu&gt;
  
&lt;/Window&gt;
</code></pre><pre><code class="lang-csharp" name="WindowsOverviewSnippets#WindowWithFileExitCODEBEHIND">using System.Windows;

namespace SDKSample
{
    public partial class WindowWithFileExit : System.Windows.Window
    {
        public WindowWithFileExit()
        {
            InitializeComponent();
        }

        void fileExitMenuItem_Click(object sender, RoutedEventArgs e)
        {
            // Close this window
            this.Close();
        }
    }
}
</code></pre>
<p>При закрытии окно вызывает два события: <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.closing">Closing</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.closed">Closed</a>.</p>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.closing">Closing</a> Возникает перед закрытием окна и предоставляет механизм, с помощью окно, которое может быть прервано замыкания. Одна из распространенных причин, препятствующих закрытию окна, заключается в том, что содержимое окна содержит измененные данные. В этом случае <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.closing">Closing</a> событие можно обработать для определения данных является &quot;грязным&quot; и, таким образом, чтобы запрашивать у пользователя, следует ли закрыть окно без сохранения данных или отменить закрытие окна. В следующем примере показано ключевые аспекты обработки <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.closing">Closing</a>.</p>
<pre><code class="lang-csharp" name="WindowClosingSnippets">using System; // EventArgs
using System.ComponentModel; // CancelEventArgs
using System.Windows; // window

namespace CSharp
{
    public partial class DataWindow : Window
    {
        // Is data dirty
        bool isDataDirty = false;

        public DataWindow()
        {
            InitializeComponent();
        }

        void documentTextBox_TextChanged(object sender, EventArgs e)
        {
            this.isDataDirty = true;
        }

        void DataWindow_Closing(object sender, CancelEventArgs e)
        {
            MessageBox.Show(&quot;Closing called&quot;);

            // If data is dirty, notify user and ask for a response
            if (this.isDataDirty)
            {
                string msg = &quot;Data is dirty. Close without saving?&quot;;
                MessageBoxResult result =
                  MessageBox.Show(
                    msg,
                    &quot;Data App&quot;,
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);
                if (result == MessageBoxResult.No)
                {
                    // If user doesn't want to close, cancel closure
                    e.Cancel = true;
                }
            }
        }
    }
}
</code></pre>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.closing">Closing</a> Обработчику события передаются <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.componentmodel.canceleventargs">CancelEventArgs</a>, который реализует <code>Boolean</code><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.componentmodel.canceleventargs.cancel">Cancel</a> задание для свойства <code>true</code> для предотвращения закрытия окна.</p>
<p>Если <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.closing">Closing</a> не обрабатывается или обрабатывается, но не отменено, оно будет закрыто. Непосредственно перед фактическим закрытием окна <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.closed">Closed</a> возникает. На этом этапе невозможно предотвратить закрытие окна.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Приложение можно настроить таким образом, чтобы завершить работу автоматически при любом закрытии главного окна приложения (см. в разделе <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.mainwindow">MainWindow</a>) или закрытии последнего окна. Дополнительные сведения см. в разделе <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a>.</p>
</div>
<p>Хотя окно может быть явно закрыто с помощью механизмов, предоставляемых в неклиентской и клиентской областях, окно может быть неявно Закрыто в результате поведения в других частях приложения или Windows, включая следующие:</p>
<ul>
<li><p>Пользователь выходит из системы или завершает работу Windows.</p>
</li>
<li><p>Закрывается владелец окна (см. в разделе <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.owner">Owner</a>).</p>
</li>
<li><p>Закрывается главное окно приложения и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdownmode">ShutdownMode</a> является <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.shutdownmode#System_Windows_ShutdownMode_OnMainWindowClose">OnMainWindowClose</a>.</p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application.shutdown">Shutdown</a> вызывается.</p>
</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>После закрытия окно нельзя открыть повторно.</p>
</div>
<p><a name="Window_Lifetime_Events"></a></p>
<h3 id="window-lifetime-events">События времени существования окна</h3>
<p>Ниже показана последовательность основных событий во время существования окна:</p>
<p><img src="media/wpf-windows-overview/window-lifetime-events.png" alt="Схема, показывающая события за время существования окна."></p>
<p>Ниже показана последовательность основных событий во время существования окна, которое отображается без активации (<a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.showactivated">ShowActivated</a> присваивается <code>false</code> перед отображением окна):</p>
<p><img src="media/wpf-windows-overview/window-lifetime-no-activation.png" alt="Схема, показывающая события за время существования окна без активации."></p>
<p><a name="WindowLocation"></a></p>
<h2 id="window-location">Расположение окна</h2>
<p>Когда окно открыто, оно располагается в координатах x и y относительно рабочего стола. Это расположение можно определить, проверив <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.left">Left</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.top">Top</a> свойства, соответственно. Можно задать эти свойства, чтобы изменить расположение окна.</p>
<p>Можно также указать начальное расположение <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> при его первом отображении, установив <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.windowstartuplocation">WindowStartupLocation</a> свойство с одним из следующих <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstartuplocation">WindowStartupLocation</a> значений перечисления:</p>
<ul>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstartuplocation#System_Windows_WindowStartupLocation_CenterOwner">CenterOwner</a> (по умолчанию)</p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstartuplocation#System_Windows_WindowStartupLocation_CenterScreen">CenterScreen</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstartuplocation#System_Windows_WindowStartupLocation_Manual">Manual</a></p>
</li>
</ul>
<p>Если начальное расположение указано как <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstartuplocation#System_Windows_WindowStartupLocation_Manual">Manual</a>и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.left">Left</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.top">Top</a> свойства не задано, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> появится запрос Windows расположения в.</p>
<p><a name="Topmost_Windows_and_Z_Order"></a></p>
<h3 id="topmost-windows-and-z-order">Окна верхнего уровня и Z-порядок</h3>
<p>Помимо расположения в координатах x и y, окно имеет координату по оси z, которая определяет его вертикальную позицию относительно других окон. Это называется z-порядком окна. Существует два типа: обычный z-порядок и верхний z-порядок. Расположение окна в <em>обычном z порядке</em> определяется, является ли активной или нет. По умолчанию окно находится в обычном z-порядке. Расположение окна в <em>верхнем z порядке</em> также определяется, является ли активной или нет. Кроме того, окна в самом верхнем z-порядке всегда расположены над окнами в обычном z-порядке. Окно располагается в верхнем z порядке, задав его <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.topmost">Topmost</a> свойства <code>true</code>.</p>
<pre><code class="lang-xaml" name="WindowsOverviewSnippets#TopmostWindowMARKUP1">&lt;Window 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    Topmost=&quot;True&quot;&gt;
&lt;/Window&gt;
</code></pre>
<p>В каждом z-порядке активное в данный момент окно появляется поверх всех других окон в том же z-порядке.</p>
<p><a name="WindowSize"></a></p>
<h2 id="window-size">Размер окна</h2>
<p>Помимо расположения на рабочем столе, окно имеет размер, определяемый несколькими свойствами, включая различные свойства ширины и высоты и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.sizetocontent">SizeToContent</a>.</p>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.minwidth">MinWidth</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.width">Width</a>, и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.maxwidth">MaxWidth</a> используются для управления диапазоном ширины окна во время существования, которые настраиваются, как показано в следующем примере.</p>
<pre><code class="lang-xaml" name="WindowsOverviewSnippets#WidthWindowMARKUP1">&lt;Window 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    MinWidth=&quot;300&quot; Width=&quot;400&quot; MaxWidth=&quot;500&quot;&gt;
&lt;/Window&gt;
</code></pre>
<p>Высота окна управляется <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.minheight">MinHeight</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.height">Height</a>, и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.maxheight">MaxHeight</a>и настроены, как показано в следующем примере.</p>
<pre><code class="lang-xaml" name="WindowsOverviewSnippets#HeightWindowMARKUP1">&lt;Window 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    MinHeight=&quot;300&quot; Height=&quot;400&quot; MaxHeight=&quot;500&quot;&gt;
&lt;/Window&gt;
</code></pre>
<p>Так как различные значения ширины и высоты определяют диапазон, то что ширина и высота изменяемого окна могут находиться в любом месте указанного диапазона для соответствующего измерения. Чтобы определить текущую ширину и высоту, проверьте <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.actualwidth">ActualWidth</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.actualheight">ActualHeight</a>, соответственно.</p>
<p>Если вы хотите, ширину и высоту окна будет иметь размер, соответствующий размер окна содержимого, можно использовать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.sizetocontent">SizeToContent</a> свойство, которое имеет следующие значения:</p>
<ul>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.sizetocontent#System_Windows_SizeToContent_Manual">Manual</a>. Нет эффекта (по умолчанию).</p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.sizetocontent#System_Windows_SizeToContent_Width">Width</a>. Ширине содержимого, который имеет тот же эффект, что и установка <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.minwidth">MinWidth</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.maxwidth">MaxWidth</a> по ширине содержимого.</p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.sizetocontent#System_Windows_SizeToContent_Height">Height</a>. Высоте содержимого, который имеет тот же эффект, что и установка <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.minheight">MinHeight</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.maxheight">MaxHeight</a> по высоте содержимого.</p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.sizetocontent#System_Windows_SizeToContent_WidthAndHeight">WidthAndHeight</a>. По размеру содержимого ширину и высоту, которая имеет тот же эффект, что и установка <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.minheight">MinHeight</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.maxheight">MaxHeight</a> равными высоте содержимого, а оба <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.minwidth">MinWidth</a> и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.maxwidth">MaxWidth</a> по ширине содержимого.</p>
</li>
</ul>
<p>В следующем примере показано окно, размеры которого автоматически устанавливаются равными его содержимому по вертикали и по горизонтали при первом отображении.</p>
<pre><code class="lang-xaml" name="WindowsOverviewSnippets#SizeToContentWindowMARKUP1">&lt;Window 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; 
    SizeToContent=&quot;WidthAndHeight&quot;&gt;
&lt;/Window&gt;
</code></pre>
<p>В следующем примере показано, как задать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.sizetocontent">SizeToContent</a> свойства в коде, чтобы указать, как размер окна изменяется в соответствии с содержимым.</p>
<pre><code class="lang-csharp" name="HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE">
// Manually alter window height and width
this.SizeToContent = SizeToContent.Manual;

// Automatically resize width relative to content
this.SizeToContent = SizeToContent.Width;

// Automatically resize height relative to content
this.SizeToContent = SizeToContent.Height;

// Automatically resize height and width relative to content
this.SizeToContent = SizeToContent.WidthAndHeight;
</code></pre>
<p><a name="OrderOfPrecedence"></a></p>
<h2 id="order-of-precedence-for-sizing-properties">Порядок приоритета для свойств размера</h2>
<p>Различные свойства размеров окна объединяются для определения диапазона ширины и высоты окна изменяемого размера. Чтобы обеспечить сохранение допустимого диапазона, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> вычисляет значения свойств размера, с использованием следующего порядка приоритета.</p>
<p><strong>Для свойств высоты:</strong></p>
<ol>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.minheight">FrameworkElement.MinHeight</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.maxheight">FrameworkElement.MaxHeight</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.sizetocontent#System_Windows_SizeToContent_Height">SizeToContent.Height</a>/<a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.sizetocontent#System_Windows_SizeToContent_WidthAndHeight">SizeToContent.WidthAndHeight</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.height">FrameworkElement.Height</a></p>
</li>
</ol>
<p><strong>Для свойств ширины:</strong></p>
<ol>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.minwidth">FrameworkElement.MinWidth</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.maxwidth">FrameworkElement.MaxWidth</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.sizetocontent#System_Windows_SizeToContent_Width">SizeToContent.Width</a>/<a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.sizetocontent#System_Windows_SizeToContent_WidthAndHeight">SizeToContent.WidthAndHeight</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.width">FrameworkElement.Width</a></p>
</li>
</ol>
<p>Очередность выполнения также можно определить размер окна, когда она развернута, который управляется с помощью <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.windowstate">WindowState</a> свойство.</p>
<p><a name="WindowState"></a></p>
<h2 id="window-state">Состояние окна</h2>
<p>В течение времени существования окна изменяемого размера оно может иметь три состояния: обычное, свернутое и развернутое. Окно с <em>обычный</em> состояние является состоянием окна по умолчанию. Окно с этим состоянием позволяет пользователю перемещать его и изменять размер, используя захват для изменения размера или границу.</p>
<p>Окно с <em>сведены к минимуму</em> состоянием сворачивается в кнопке панели задач, если <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.showintaskbar">ShowInTaskbar</a> присваивается <code>true</code>; в противном случае оно сворачивается до наименьшего возможного размера оно может быть и размещается в левом нижнем углу рабочего стола. Ни один из типов свернутого окна не может быть изменен с помощью границы или захвата для изменения размера, хотя свернутое окно, которое не отображается на панели задач, можно перетаскивать на рабочем столе.</p>
<p>Окно с <em>в развернутом состоянии</em> состоянием расширяется до максимального размера, который определяется размером до его <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.maxwidth">MaxWidth</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.maxheight">MaxHeight</a>, и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.sizetocontent">SizeToContent</a> свойствами. Как и для свернутого окна, размер развернутого окна нельзя изменить с помощью захвата для изменения размера или перетаскивания границы.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Значения <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.top">Top</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.left">Left</a>, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.width">Width</a>, и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.frameworkelement.height">Height</a> свойства окна всегда представляют значения для обычного состояния, даже в том случае, если окно свернуто или развернуто в настоящее время.</p>
</div>
<p>Состояние окна можно настроить, задав его <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.windowstate">WindowState</a> свойство, которое может иметь одно из следующих <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstate">WindowState</a> значений перечисления:</p>
<ul>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstate#System_Windows_WindowState_Normal">Normal</a> (по умолчанию)</p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstate#System_Windows_WindowState_Maximized">Maximized</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstate#System_Windows_WindowState_Minimized">Minimized</a></p>
</li>
</ul>
<p>В следующем примере показано создание окна, которое отображается развернутым при его открытии.</p>
<pre><code class="lang-xaml" name="WindowsOverviewSnippets#WindowStateWindowMARKUP1">&lt;Window 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    WindowState=&quot;Maximized&quot;&gt;
&lt;/Window&gt;
</code></pre>
<p>Как правило, следует задать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.windowstate">WindowState</a> для настройки начального состояния окна. После отображения окна изменяемого размера пользователи могут нажимать кнопки свертывания, развертывания и восстановления на панели заголовка окна, чтобы изменить состояние окна.</p>
<p><a name="WindowAppearance"></a></p>
<h2 id="window-appearance">Внешний вид окна</h2>
<p>Можно изменить внешний вид клиентской области окна, добавляя в нее определенное содержимое, такое как кнопки, метки и текстовые поля. Для настройки неклиентской области, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> предоставляет несколько свойств, которые включают <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.icon">Icon</a> для установки значка окна и <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.title">Title</a> для установки заголовка.</p>
<p>Можно также изменить внешний вид и поведение границы неклиентской области, настраивая режим изменения размера окна, стиль окна и отображение в виде кнопки на панели задач рабочего стола.</p>
<p><a name="Resize_Mode"></a></p>
<h3 id="resize-mode">Режим изменения размера</h3>
<p>В зависимости от <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.windowstyle">WindowStyle</a> свойство, можно управлять как (и нужно ли) пользователь может изменять размер окна. Выбор стиля окна влияет ли пользователь изменять размер окна, перетаскивая его границу мышью, является ли <strong>свернуть</strong>, <strong>развернуть</strong>, и <strong>изменение размера</strong> кнопки отображаются в неклиентской области, и, если они отображаются, включены ли они.</p>
<p>Можно настроить изменение размера окна, задав его <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.resizemode">ResizeMode</a> свойство, которое может принимать одно из следующих <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.resizemode">ResizeMode</a> значений перечисления:</p>
<ul>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.resizemode#System_Windows_ResizeMode_NoResize">NoResize</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.resizemode#System_Windows_ResizeMode_CanMinimize">CanMinimize</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.resizemode#System_Windows_ResizeMode_CanResize">CanResize</a> (по умолчанию)</p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.resizemode#System_Windows_ResizeMode_CanResizeWithGrip">CanResizeWithGrip</a></p>
</li>
</ul>
<p>Как и в <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.windowstyle">WindowStyle</a>, режим изменения размера окна редко изменяется во время существования, это означает, что вы скорее установим его из XAML разметки.</p>
<pre><code class="lang-xaml" name="WindowsOverviewSnippets#ResizeModeWindowMARKUP1">&lt;Window 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    ResizeMode=&quot;CanResizeWithGrip&quot;&gt;
&lt;/Window&gt;
</code></pre>
<p>Обратите внимание, что можно определить, является ли окно развернуто, свернуто или восстановлено, проверяя <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.windowstate">WindowState</a> свойство.</p>
<p><a name="Window_Style"></a></p>
<h3 id="window-style">Стиль окна</h3>
<p>Граница, предоставляемая из неклиентской области окна, подходит для большинства приложений. Однако существуют ситуации, когда требуются различные типы границ либо границы вовсе не требуются, в зависимости от типа окна.</p>
<p>Для управления типом границы окна, установите его <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.windowstyle">WindowStyle</a> свойство с одним из следующих значений <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstyle">WindowStyle</a> перечисления:</p>
<ul>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstyle#System_Windows_WindowStyle_None">None</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstyle#System_Windows_WindowStyle_SingleBorderWindow">SingleBorderWindow</a> (по умолчанию)</p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstyle#System_Windows_WindowStyle_ThreeDBorderWindow">ThreeDBorderWindow</a></p>
</li>
<li><p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstyle#System_Windows_WindowStyle_ToolWindow">ToolWindow</a></p>
</li>
</ul>
<p>На следующем рисунке показаны последствия этих стилей окон:</p>
<p><img src="media/wpf-windows-overview/window-border-styles.png" alt="Иллюстрация стили границ окна."></p>
<p>Можно задать <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.windowstyle">WindowStyle</a> одним XAML разметки или кода; так как это редко изменяется во время существования окна, то скорее задать его с помощью XAML разметки.</p>
<pre><code class="lang-xaml" name="WindowsOverviewSnippets#WindowStyleWindowMARKUP1">&lt;Window 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    WindowStyle=&quot;ToolWindow&quot;&gt;
&lt;/Window&gt;
</code></pre><h4 id="non-rectangular-window-style">Непрямоугольный стиль окна</h4>
<p>Существуют также ситуации, где стилей границ, предоставляемых <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.windowstyle">WindowStyle</a> позволяет вам потребуется недостаточно. Например, вы можете создать приложение с непрямоугольной границей, таких как Проигрыватель Windows Media (Microsoft) использует.</p>
<p>Например рассмотрим речи пузырьковой окно, показанное на следующем рисунке:</p>
<p><img src="media/wpf-windows-overview/non-rectangular-window-figure.png" alt="Окно пузырьковой речи с текстом перетащите Me."></p>
<p>Этот тип окна можно создать, задав <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.windowstyle">WindowStyle</a> свойства <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.windowstyle#System_Windows_WindowStyle_None">None</a>и с помощью специальной поддержки, <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> прозрачности.</p>
<pre><code class="lang-xaml" name="WindowsOverviewSnippets#TransparentWindowMARKUP1">&lt;Window 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    WindowStyle=&quot;None&quot;
    AllowsTransparency=&quot;True&quot;
    Background=&quot;Transparent&quot;&gt;
&lt;/Window&gt;
</code></pre>
<p>Это сочетание значений указывает, что окно отрисовывается полностью прозрачным. В этом состоянии нельзя использовать элементы оформления неклиентской области окна (кнопки &quot;Закрыть&quot;, &quot;Минимизировать&quot;, &quot;Развернуть&quot; и &quot;Восстановить&quot; и т. д.). Следовательно, необходимо предоставить свои собственные элементы.</p>
<p><a name="Task_Bar_Presence"></a></p>
<h3 id="task-bar-presence">Наличие панели задач</h3>
<p>По умолчанию внешний вид окна включает кнопку панели задач, как показано на следующем рисунке:</p>
<p><img src="media/wpf-windows-overview/window-taskbar-button.png" alt="Снимок экрана: окно с кнопкой панели задач."></p>
<p>Некоторые типы окон не имеют кнопки панели задач, таких как окна сообщений и диалоговые окна (см. в разделе <a href="dialog-boxes-overview.html">Общие сведения о полях диалогового окна</a>). Вы можете управлять, отображаются ли кнопки панели задач для окна, задав <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window.showintaskbar">ShowInTaskbar</a> свойство (<code>true</code> по умолчанию).</p>
<pre><code class="lang-xaml" name="WindowsOverviewSnippets#ShowInTaskbarWindowMARKUP1">&lt;Window 
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    ShowInTaskbar=&quot;False&quot;&gt;
&lt;/Window&gt;
</code></pre>
<p><a name="SecurityConsiderations"></a></p>
<h2 id="security-considerations">Вопросы безопасности</h2>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a> требуется <code>UnmanagedCode</code> создания разрешения безопасности. Для приложений, установленных и запускаемых с локального компьютера, это включено в набор разрешений, предоставленных приложению.</p>
<p>Однако это выходит за рамки набора разрешений для приложений, запущенных из Интернета или локальной интрасети с помощью ClickOnce. Следовательно, пользователи будут получать ClickOnce предупреждение системы безопасности и должны будут повысить набор разрешений для приложения до полного доверия.</p>
<p>Кроме того XBAP не может отображать окна или диалоговые окна по умолчанию. Обсуждение безопасности автономных приложений, см. в разделе <a href="../wpf-security-strategy-platform-security.html">стратегия безопасности WPF — безопасность платформы</a>.</p>
<p><a name="Other_Types_of_Windows"></a></p>
<h2 id="other-types-of-windows">Другие типы окон</h2>
<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.navigation.navigationwindow">NavigationWindow</a> — Это окно, предназначенное для предоставления навигации по содержимому. Дополнительные сведения см. в разделе <a href="navigation-overview.html">Общие сведения о переходах</a>).</p>
<p>Диалоговые окна — это окна, которые часто используются для сбора информации от пользователя для выполнения функции. Например, когда пользователь хочет открыть файл, <strong>открыть файл</strong> диалоговое окно обычно отображается в приложении, чтобы получить имя файла от пользователя. Дополнительные сведения см. в разделе <a href="dialog-boxes-overview.html">Общие сведения о диалоговых окнах</a>.</p>
<h2 id="see-also">См. также</h2>
<ul>
<li><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.window">Window</a></li>
<li><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.messagebox">MessageBox</a></li>
<li><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.navigation.navigationwindow">NavigationWindow</a></li>
<li><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.application">Application</a></li>
<li><a href="dialog-boxes-overview.html">Общие сведения о диалоговых окнах</a></li>
<li><a href="building-a-wpf-application-wpf.html">Построение приложения WPF</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span><a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru">Неофициальная документация по .NET на русском языке</a>. Лицензия: <a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru/blob/main/LICENSE">CC-BY 4.0</a>. Основано на <a href="https://docs.microsoft.com/ru-ru/dotnet/">документации по .NET с Microsoft Docs</a><br>Generated by <strong>DocFX</strong></span><script type="text/javascript">(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(65150713, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/65150713" style="position:absolute; left:-9999px;" alt=""></div></noscript>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
