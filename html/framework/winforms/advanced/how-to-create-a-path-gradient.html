<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>&#1055;&#1088;&#1072;&#1082;&#1090;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1077; &#1088;&#1091;&#1082;&#1086;&#1074;&#1086;&#1076;&#1089;&#1090;&#1074;&#1086;. &#1057;&#1086;&#1079;&#1076;&#1072;&#1085;&#1080;&#1077; &#1075;&#1088;&#1072;&#1076;&#1080;&#1077;&#1085;&#1090;&#1072; &#1074;&#1076;&#1086;&#1083;&#1100; &#1082;&#1086;&#1085;&#1090;&#1091;&#1088;&#1072; | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="&#1055;&#1088;&#1072;&#1082;&#1090;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1077; &#1088;&#1091;&#1082;&#1086;&#1074;&#1086;&#1076;&#1089;&#1090;&#1074;&#1086;. &#1057;&#1086;&#1079;&#1076;&#1072;&#1085;&#1080;&#1077; &#1075;&#1088;&#1072;&#1076;&#1080;&#1077;&#1085;&#1090;&#1072; &#1074;&#1076;&#1086;&#1083;&#1100; &#1082;&#1086;&#1085;&#1090;&#1091;&#1088;&#1072; | &#1053;&#1077;&#1086;&#1092;&#1080;&#1094;&#1080;&#1072;&#1083;&#1100;&#1085;&#1072;&#1103; &#1076;&#1086;&#1082;&#1091;&#1084;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1103; .NET ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="how-to-create-a-path-gradient">Практическое руководство. Создание градиента вдоль контура</h1>

<p><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.drawing2d.pathgradientbrush">PathGradientBrush</a> Класс позволяет настраивать то, как вы постепенно изменение цвета заливки фигуры. Например можно указать один цвет для центра контура, а другой — для границы пути. Можно также определить отдельные цвета для каждой из нескольких точек на границе пути.</p>
<div class="NOTE">
<h5>Note</h5>
<p>В GDI+, путь представляет собой последовательность линий и кривых, поддерживаемых <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.drawing2d.graphicspath">GraphicsPath</a> объекта. Дополнительные сведения о GDI+ пути, см. в разделе <a href="graphics-paths-in-gdi.html">контуры в GDI +</a> и <a href="constructing-and-drawing-paths.html">Constructing и рисование контуров</a>.</p>
</div>
<h3 id="to-fill-an-ellipse-with-a-path-gradient">Заливка эллипса с градиента вдоль контура</h3>
<ul>
<li><p>В следующем примере заполняется эллипса с кисти градиента контура. Имеет значение центрального цвета на синем и граничным цветом — зеленовато-голубой. На следующем рисунке заполненного эллипса.</p>
<p><img src="media/how-to-create-a-path-gradient/gradient-path-filled-ellipse.png" alt="Градиент контура осуществляется заливка эллипса."></p>
<p>По умолчанию кисти градиента контура не распространяется за пределами границы пути. При использовании пути градиентной кисти для заливки фигуры, которая выходит за пределы границ пути области экрана за пределами контура заполняться не будет.</p>
<p>На следующем рисунке показано, что происходит при изменении <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.graphics.fillellipse">FillEllipse</a> вызов в следующий код, чтобы <code>e.Graphics.FillRectangle(pthGrBrush, 0, 10, 200, 40)</code>:</p>
<p><img src="media/how-to-create-a-path-gradient/gradient-path-extended-beyond-boundary.png" alt="Градиент контура выходили за пределы границ пути."></p>
<pre><code class="lang-csharp" name="System.Drawing.UsingaGradientBrush#11">// Create a path that consists of a single ellipse.
GraphicsPath path = new GraphicsPath();
path.AddEllipse(0, 0, 140, 70);

// Use the path to construct a brush.
PathGradientBrush pthGrBrush = new PathGradientBrush(path);

// Set the color at the center of the path to blue.
pthGrBrush.CenterColor = Color.FromArgb(255, 0, 0, 255);

// Set the color along the entire boundary 
// of the path to aqua.
Color[] colors = { Color.FromArgb(255, 0, 255, 255) };
pthGrBrush.SurroundColors = colors;

e.Graphics.FillEllipse(pthGrBrush, 0, 0, 140, 70);

</code></pre>
<p>Предыдущий пример кода предназначен для работы с Windows Forms и требует <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.forms.painteventargs">PaintEventArgs</a> e, который является параметром из <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.forms.painteventhandler">PaintEventHandler</a>.</p>
</li>
</ul>
<h3 id="to-specify-points-on-the-boundary">Указание точек на границе</h3>
<ul>
<li><p>В следующем примере создается градиентной кисти путь из пути форме четырехконечной звезды. В коде устанавливается <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.drawing2d.pathgradientbrush.centercolor">CenterColor</a> свойство, которое задает цвет в центре звезды как красный. Затем устанавливается <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.drawing2d.pathgradientbrush.surroundcolors">SurroundColors</a> свойство, чтобы указать различные цвета (хранящиеся в <code>colors</code> массива) отдельных точек в <code>points</code> массива. Последняя инструкция кода заливку пути в форме звезды с помощью кисти градиента контура.</p>
<pre><code class="lang-csharp" name="System.Drawing.UsingaGradientBrush#12">// Put the points of a polygon in an array.
Point[] points = {
   new Point(75, 0),
   new Point(100, 50),
   new Point(150, 50),
   new Point(112, 75),
   new Point(150, 150),
   new Point(75, 100),
   new Point(0, 150),
   new Point(37, 75),
   new Point(0, 50),
   new Point(50, 50)};

// Use the array of points to construct a path.
GraphicsPath path = new GraphicsPath();
path.AddLines(points);

// Use the path to construct a path gradient brush.
PathGradientBrush pthGrBrush = new PathGradientBrush(path);

// Set the color at the center of the path to red.
pthGrBrush.CenterColor = Color.FromArgb(255, 255, 0, 0);

// Set the colors of the points in the array.
Color[] colors = {
   Color.FromArgb(255, 0, 0, 0),
   Color.FromArgb(255, 0, 255, 0),
   Color.FromArgb(255, 0, 0, 255), 
   Color.FromArgb(255, 255, 255, 255),
   Color.FromArgb(255, 0, 0, 0),
   Color.FromArgb(255, 0, 255, 0),
   Color.FromArgb(255, 0, 0, 255),
   Color.FromArgb(255, 255, 255, 255),
   Color.FromArgb(255, 0, 0, 0),  
   Color.FromArgb(255, 0, 255, 0)};

pthGrBrush.SurroundColors = colors;

// Fill the path with the path gradient brush.
e.Graphics.FillPath(pthGrBrush, path);

</code></pre></li>
<li><p>В следующем примере рисуется градиента вдоль контура без <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.drawing2d.graphicspath">GraphicsPath</a> в коде. Конкретного <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.drawing2d.pathgradientbrush.-ctor">PathGradientBrush</a> конструктор в примере, получает массив точек, но не требует <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.drawing2d.graphicspath">GraphicsPath</a> объекта. Кроме того, обратите внимание, что <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.drawing2d.pathgradientbrush">PathGradientBrush</a> используется для заливки прямоугольника, а не путь. Прямоугольник больше, чем замкнутый контур, используемый для задания кисти, поэтому часть прямоугольника не закрашивается кистью. Ниже показан прямоугольник (пунктирная линия) и часть прямоугольника, созданный при помощи кисти градиента контура:</p>
<p><img src="media/how-to-create-a-path-gradient/gradient-painted-path-gradient-brush.png" alt="Часть градиента, созданный при помощи кисти градиента контура."></p>
<pre><code class="lang-csharp" name="System.Drawing.UsingaGradientBrush#13">// Construct a path gradient brush based on an array of points.
PointF[] ptsF = {
   new PointF(0, 0), 
   new PointF(160, 0), 
   new PointF(160, 200),
   new PointF(80, 150),
   new PointF(0, 200)};

PathGradientBrush pBrush = new PathGradientBrush(ptsF);

// An array of five points was used to construct the path gradient
// brush. Set the color of each point in that array.
Color[] colors = {
   Color.FromArgb(255, 255, 0, 0),  // (0, 0) red
   Color.FromArgb(255, 0, 255, 0),  // (160, 0) green
   Color.FromArgb(255, 0, 255, 0),  // (160, 200) green
   Color.FromArgb(255, 0, 0, 255),  // (80, 150) blue
   Color.FromArgb(255, 255, 0, 0)}; // (0, 200) red

pBrush.SurroundColors = colors;

// Set the center color to white.
pBrush.CenterColor = Color.White;

// Use the path gradient brush to fill a rectangle.
e.Graphics.FillRectangle(pBrush, new Rectangle(0, 0, 160, 200));
</code></pre></li>
</ul>
<h3 id="to-customize-a-path-gradient">Чтобы настроить градиента вдоль контура</h3>
<ul>
<li><p>Одним из способов настройки кисти градиента контура является установка его <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.drawing2d.pathgradientbrush.focusscales">FocusScales</a> свойство. Это свойство определяет внутренний путь, расположенную внутри главный путь. Центрального цвета везде в пределах этого внутреннего пути, а не только в центральной точке.</p>
<p>В следующем примере создается на основе эллиптической пути кисти градиента контура. Код задает в качестве цвета границы на синий, устанавливает центрального цвета на голубой и затем использует путь градиентной кисти для заливки по контуру.</p>
<p>Затем код задает коэффициенты масштабирования кисти градиента контура. Коэффициент масштабирования по x имеет значение 0.3 и масштабирования по оси y имеет значение 0,8. Этот код вызывает <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.graphics.translatetransform">TranslateTransform</a> метод <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.graphics">Graphics</a> объекта таким образом, последующий вызов <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.graphics.fillpath">FillPath</a> осуществляется заливка эллипса, который находится справа от первого эллипса.</p>
<p>Чтобы увидеть эффект коэффициенты масштабирования, представьте себе небольшой эллипса, который совпадает с основной эллипс центром. Небольшой (внутренний) эллипс представляет собой основной эллипс, вдвое 0.3 и по вертикали с коэффициентом 0,8 горизонтально масштабировать (относительно ее центра). При перемещении от границы внешнего эллипса к границе внутреннего эллипса цвет плавно меняется от синего на голубой. При перемещении от границы внутреннего эллипса к общему центру зеленовато-голубой цвет сохраняется.</p>
<p>На рисунке ниже показан результат выполнения кода. Эллипс в левой части — голубой цвет только в центральной точки. Эллипс в правой — голубой везде в пределах внутреннего пути.</p>
</li>
</ul>
<p><img src="media/how-to-create-a-path-gradient/focus-scales-aqua-inner-outer-ellipse.png" alt="Эффект градиента для коэффициенты масштабирования"></p>
<pre><code class="lang-csharp" name="System.Drawing.UsingaGradientBrush#14">// Create a path that consists of a single ellipse.
GraphicsPath path = new GraphicsPath();
path.AddEllipse(0, 0, 200, 100);

// Create a path gradient brush based on the elliptical path.
PathGradientBrush pthGrBrush = new PathGradientBrush(path);

// Set the color along the entire boundary to blue.
Color[] color = { Color.Blue };
pthGrBrush.SurroundColors = color;

// Set the center color to aqua.
pthGrBrush.CenterColor = Color.Aqua;

// Use the path gradient brush to fill the ellipse. 
e.Graphics.FillPath(pthGrBrush, path);

// Set the focus scales for the path gradient brush.
pthGrBrush.FocusScales = new PointF(0.3f, 0.8f);

// Use the path gradient brush to fill the ellipse again.
// Show this filled ellipse to the right of the first filled ellipse.
e.Graphics.TranslateTransform(220.0f, 0.0f);
e.Graphics.FillPath(pthGrBrush, path);
</code></pre><h3 id="to-customize-with-interpolation">Настройка с интерполяцией</h3>
<ul>
<li><p>Чтобы указать массив интерполяции цветов и позиций интерполяции является другим способом настройки кисти градиента контура.</p>
<p>В следующем примере создается исходя треугольником кисти градиента контура. В коде устанавливается <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.drawing2d.pathgradientbrush.interpolationcolors">InterpolationColors</a> свойство кисти градиента контура, чтобы указать массив цветов интерполяции (темно-зеленый, голубой, синий), а также массив позиций интерполяции (0, 0,25, 1). При перемещении от границы треугольника к центральной точке цвет плавно меняется от темно-зеленый голубой, а затем из голубой цвет на синий. Изменение темно-зеленого цвета на голубой происходит на 25 процентов от расстояния от темно-зеленого до синего.</p>
<p>Ниже показан треугольник, заполненный градиентной кисти пользовательский путь.</p>
<p><img src="media/how-to-create-a-path-gradient/gradient-brush-filled-triangle.png" alt="Треугольник заполняется пользовательский путь градиентной кисти."></p>
<pre><code class="lang-csharp" name="System.Drawing.UsingaGradientBrush#15">// Vertices of the outer triangle
Point[] points = {
   new Point(100, 0),
   new Point(200, 200),
   new Point(0, 200)};

// No GraphicsPath object is created. The PathGradientBrush
// object is constructed directly from the array of points.
PathGradientBrush pthGrBrush = new PathGradientBrush(points);

Color[] colors = {
   Color.FromArgb(255, 0, 128, 0),    // dark green
   Color.FromArgb(255, 0, 255, 255),  // aqua
   Color.FromArgb(255, 0, 0, 255)};   // blue

float[] relativePositions = {
   0f,       // Dark green is at the boundary of the triangle.
   0.4f,     // Aqua is 40 percent of the way from the boundary
             // to the center point.
   1.0f};    // Blue is at the center point.

ColorBlend colorBlend = new ColorBlend();
colorBlend.Colors = colors;
colorBlend.Positions = relativePositions;
pthGrBrush.InterpolationColors = colorBlend;

// Fill a rectangle that is larger than the triangle
// specified in the Point array. The portion of the
// rectangle outside the triangle will not be painted.
e.Graphics.FillRectangle(pthGrBrush, 0, 0, 200, 200);
</code></pre></li>
</ul>
<h3 id="to-set-the-center-point">Чтобы задать точку center</h3>
<ul>
<li><p>По умолчанию центральная точка градиентной кисти путь находится в центре путь, используемый для создания кисти. Можно изменить расположение точки center, задав <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.drawing2d.pathgradientbrush.centerpoint">CenterPoint</a> свойство <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.drawing2d.pathgradientbrush">PathGradientBrush</a> класса.</p>
<p>В следующем примере создается на основе эллиптического кисти градиента контура. Центром эллипса является точка (70, 35), но центральную точку градиента кисти путь имеет значение (120, 40).</p>
<pre><code class="lang-csharp" name="System.Drawing.UsingaGradientBrush#16">// Create a path that consists of a single ellipse.
GraphicsPath path = new GraphicsPath();
path.AddEllipse(0, 0, 140, 70);

// Use the path to construct a brush.
PathGradientBrush pthGrBrush = new PathGradientBrush(path);

// Set the center point to a location that is not
// the centroid of the path.
pthGrBrush.CenterPoint = new PointF(120, 40);

// Set the color at the center of the path to blue.
pthGrBrush.CenterColor = Color.FromArgb(255, 0, 0, 255);

// Set the color along the entire boundary 
// of the path to aqua.
Color[] colors = { Color.FromArgb(255, 0, 255, 255) };
pthGrBrush.SurroundColors = colors;

e.Graphics.FillEllipse(pthGrBrush, 0, 0, 140, 70);

</code></pre>
<p>Ниже показан закрашенный эллипс и центральную точку градиента кисти пути:</p>
<p><img src="media/how-to-create-a-path-gradient/gradient-path-filled-ellipse-center-point.png" alt="Градиент контура с помощью закрашенный эллипс и центральную точку."></p>
</li>
<li><p>Можно задать центральную точку градиента кисти путь в расположение вне пути, который использовался для создания кисти. В следующем примере заменяется вызов для установки <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.drawing.drawing2d.pathgradientbrush.centerpoint">CenterPoint</a> свойство в приведенном выше коде.</p>
<pre><code class="lang-csharp" name="System.Drawing.UsingaGradientBrush#17">pthGrBrush.CenterPoint = new PointF(145, 35);
</code></pre>
<p>На следующем рисунке показан выходные данные этого изменения:</p>
<p><img src="media/how-to-create-a-path-gradient/gradient-path-center-point-outside.png" alt="Градиент контура с центральной точкой за пределами контура."></p>
<p>В приведенном выше рисунке в крайней правой точки эллипса не являются чисто синими (несмотря на то, что они очень близки). Цвета градиента располагаются так, как если бы заливки достиг точки (145, 35), где цвет является чисто синим (0, 0, 255). Никогда не дойти до точки (145, 35), так как путь Градиентная кисть закрашивает только в пределах заданного пути.</p>
</li>
</ul>
<h2 id="compiling-the-code">Компиляция кода</h2>
<p>Предыдущий пример предназначен для работы с Windows Forms, и они требуют <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.forms.painteventargs">PaintEventArgs</a> <code>e</code>, который является параметром <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.windows.forms.control.paint">Paint</a> обработчик событий.</p>
<h2 id="see-also">См. также</h2>
<ul>
<li><a href="using-a-gradient-brush-to-fill-shapes.html">Заливка фигур с помощью градиентной кисти</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span><a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru">Неофициальная документация по .NET на русском языке</a>. Лицензия: <a href="https://github.com/MSDN-WhiteKnight/dotnet-docs-ru/blob/main/LICENSE">CC-BY 4.0</a>. Основано на <a href="https://docs.microsoft.com/ru-ru/dotnet/">документации по .NET с Microsoft Docs</a><br>Generated by <strong>DocFX</strong></span><script type="text/javascript">(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(65150713, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/65150713" style="position:absolute; left:-9999px;" alt=""></div></noscript>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
